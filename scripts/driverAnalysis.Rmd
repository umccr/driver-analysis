---
title: "Driver analyses summary"
author: "UMCCR"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: readable
    toc: true
    toc_float: true
    code_folding: hide
  rmdformats::material:
    highlight: kate
params:
  maf_dir: 
  maf_files: 
  datasets: 
  q_value: 
  ratios_ci: 
  hypermut_sample_cutoff: 
  max_muts_per_gene: 
  ucsc_genome_assembly: 
  genes_list: 
  genes_blacklist: 
  samples_blacklist: 
  nonSyn_list: 
  oncodrivefml: 
  oncodrivefml_p: 
  oncodrivefml_q: 
  oncodrivefml_conf: 
  remove_duplicated_variants: 
  out_folder: 'Driver_analysis_report'
---

Selection analyses and cancer driver discovery results for dataset(s) **`r gsub(",", ", ", params$datasets) `** using the following methods:

* **[dNdScv](https://github.com/im3sanger/dndscv){target="_blank"}** (see paper by [Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"} for details)
* **[OncodriveClust](https://bioconductor.org/packages/release/bioc/vignettes/maftools/inst/doc/maftools.html#92_detecting_cancer_driver_genes_based_on_positional_clustering){target="_blank"}** (see paper by [Tamborero *et al*, 2013](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"} for details)
* **[OncodriveFML](https://bitbucket.org/bbglab/oncodrivefml.git){target="_blank"}** (see paper by [Mularoni et al., 2016](https://www.ncbi.nlm.nih.gov/pubmed/27311963){target="_blank"} for details)
* **[MutSig](http://software.broadinstitute.org/cancer/cga/mutsig){target="_blank"}** (see paper by [Lawrence et al., 2013](https://www.ncbi.nlm.nih.gov/pubmed/23770567){target="_blank"} for details, ...work in progress)
* **[Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/rest_api){target="_blank"}** (CGI) (see paper by [Tamborero et al., 2018](https://www.ncbi.nlm.nih.gov/pubmed/29592813){target="_blank"} for details, ...work in progress)
* **[CHASMplus](https://github.com/KarchinLab/CHASMplus){target="_blank"}** (see paper by [Tokheim and Karchin., preprint](https://www.biorxiv.org/content/10.1101/313296v4){target="_blank"} for details, ...work in progress)
* **[Hierarchical HotNet](https://github.com/raphael-group/hierarchical-hotnet){target="_blank"}** (see paper by [Reyna et al., 2015](https://www.ncbi.nlm.nih.gov/pubmed/30423088){target="_blank"} for details, ...work in progress)

```{r define_functions, comment=NA, message=FALSE, warning=FALSE}
##### Define functions

##### Create 'not in' operator
"%!in%" <- function(x,table) match(x,table, nomatch = 0) == 0

##### Verify gene names. Some driver analysis methods, like dNdScv, output specific gene variants (e.g. CDKN2A.p14arf and CDKN2A.p16INK4a) rather than genes. This function removes anything followed by '.'
verify_genes <- function(genes) {
  
  genes.verified = unique(str_replace(string = genes, pattern = "\\..*", replacement = ""))
  
  return( genes.verified )
}

##### Perfrom oncodrive analysis. Clusters variants based on their position to detect disease causing genes
oncodrive.mod <- function(mafInfo, dataset, AACol, gl) {

  ##### Check whether it's possible to run oncodrive analysis for given dataset by calculating cluster scores
  nonsyn.scores <- parse_prot(mafInfo, AACol = AACol, gl = gl, m = 5, calBg = FALSE, nBg = 100)
    
  if ( !is.null(nonsyn.scores) ) {
      
    ##### Cluster variants based on their position to detect disease causing genes
    sig = oncodrive(maf = mafInfo, AACol = AACol, minMut = 5, pvalMethod = 'zscore')
    
    oncodrive.plot <- plotOncodrive(res = sig, fdrCutOff = 0.05, useFraction = FALSE)
      
    return(list(sig, oncodrive.plot))
  }
}

##### Functon to calcluate cluster score (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). It's required in order check whether it's possible to run oncodrive analysis for given dataset
parse_prot <- function(dat, AACol, gl, m, calBg = FALSE, nBg){

  mafInfo <- dat
  dat <- mafInfo@data
  
  if(is.null(AACol)){
    pchange = c('HGVSp_Short', 'Protein_Change', 'AAChange')
    if(pchange[pchange %in% colnames(dat)] > 0){
      pchange = suppressWarnings(pchange[pchange %in% colnames(dat)][1])
      message(paste0("Assuming protein change information are stored under column ", pchange,". Use argument AACol to override if necessary."))
      colnames(dat)[which(colnames(dat) == pchange)] = 'AAChange'
    }else{
      message('Available fields:')
      print(colnames(dat))
      stop('AAChange field not found in MAF. Use argument AACol to manually specifiy field name containing protein changes.')
    }
  }else{
    colnames(dat)[which(colnames(dat) == AACol)] = 'AAChange'
  }

  all.prot.dat = dat[,.(Hugo_Symbol, Variant_Classification, AAChange)]
  all.prot.dat = all.prot.dat[Variant_Classification != 'Splice_Site']
  #parse AAchanges to get postion
  prot.spl = strsplit(x = as.character(all.prot.dat$AAChange), split = '.', fixed = TRUE)
  prot.conv = sapply(sapply(prot.spl, function(x) x[length(x)]), '[', 1)

  all.prot.dat[,conv := prot.conv]
  all.prot.dat = all.prot.dat[!conv == 'NULL']

  #If conversions are in HGVSp_long (default HGVSp) format, we will remove strings Ter followed by anything (e.g; p.Asn1986GlnfsTer13)
  pos = gsub(pattern = 'Ter.*', replacement = '',x = all.prot.dat$conv)

  #Following parsing takes care of most of HGVSp_short and HGVSp_long format
  pos = gsub(pattern = '[[:alpha:]]', replacement = '', x = pos)
  pos = gsub(pattern = '\\*$', replacement = '', x = pos) #Remove * if nonsense mutation ends with *
  pos = gsub(pattern = '^\\*', replacement = '', x = pos) #Remove * if nonsense mutation starts with *
  pos = gsub(pattern = '\\*.*', replacement = '', x = pos) #Remove * followed by position e.g, p.C229Lfs*18

  pos = suppressWarnings( as.numeric(sapply(strsplit(x = pos, split = '_', fixed = TRUE), '[', 1)) )
  all.prot.dat[,pos := pos]

  all.prot.dat = all.prot.dat[!is.na(pos)] #Remove NA's

  gene.sum = mafInfo@gene.summary
  gene.sum = merge(x = gene.sum, y = gl, by = 'Hugo_Symbol', all.x = TRUE)
  gene.sum = gene.sum[!is.na(aa.length)]

  num_mut_colIndex = which(colnames(gene.sum) == 'total')
  aalen_colIndex = which(colnames(gene.sum) == 'aa.length')

  #Get background threshold
  gene.sum$th = apply(gene.sum, 1, function(x) get_threshold(gene_muts = as.numeric(x[num_mut_colIndex]), gene_length = as.numeric(x[aalen_colIndex])))
  #use only genes with atleast 2 (or m ) mutations.
  gene.sum = gene.sum[total >= m]

  if(calBg){
    if(nrow(gene.sum) < nBg){
      #message("Not enough genes to build background. Using predefined values. (Mean = 0.279; SD = 0.13)")
      return(NULL)
    } else{
      syn.res = c()
      pb <- txtProgressBar(min = 0, max = nrow(gene.sum), style = 3) #progress bar

      for(i in 1:nrow(gene.sum)){
        prot.dat = all.prot.dat[Hugo_Symbol %in% gene.sum[i, Hugo_Symbol]]
        syn.res = rbind(syn.res, cluster_prot(prot.dat = prot.dat, gene = gene.sum[i, Hugo_Symbol], th = gene.sum[i, th], protLen = gene.sum[i,aa.length]))
        setTxtProgressBar(pb, i)
      }
      return(syn.res)
    }
  } else{
    nonsyn.res = c()
    #pb <- txtProgressBar(min = 0, max = nrow(gene.sum), style = 3) #progress bar

    for(i in 1:nrow(gene.sum)){
      hs = gene.sum[i, Hugo_Symbol]
      #print(hs)
      prot.dat = all.prot.dat[Hugo_Symbol %in% hs]
      nonsyn.res = rbind(nonsyn.res, cluster_prot(prot.dat = prot.dat, gene = hs, th = gene.sum[Hugo_Symbol %in% hs, th], protLen = gene.sum[Hugo_Symbol %in% hs, aa.length]))
      #setTxtProgressBar(pb, i)
    }
    return(nonsyn.res)
  }
}

###### Estimate threshhold based on binaomial distribution (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). Required for parse_prot function
get_threshold <- function(gene_muts, gene_length){
  th = which(unlist(lapply(X = 2:gene_muts, FUN = function(x) dbinom(x = x, size = gene_muts, prob = 1/gene_length) )) < 0.01)[1]
  return(th+1)
}

###### Clustering function (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). Required for parse_prot function
cluster_prot <- function(prot.dat, gene, th, protLen){

  mergeDist = 5 #hard coded inter event distance.
  #prot.dat = all.prot.dat[Hugo_Symbol == gene]

  #Summarise counts per position
  pos.counts = prot.dat[,.N,pos]
  pos.counts = pos.counts[order(pos)]

  #classify position as meaningful if its greater than background threshhold.
  pos.counts$cluster = ifelse(test = pos.counts$N >= th, yes = 'meaningful', no = 'nonMeaningful')

  #Just choose meaningful positions
  clust.tbl = pos.counts[cluster %in% 'meaningful']
  nonclust.tbl = pos.counts[cluster %in% 'nonMeaningful']

  if(nrow(clust.tbl) == 0){
    #message(paste('No meaningful positions found for', gene, sep=' '))
    return(NULL)
  }

  clust.tbl$distance = c(0,diff(clust.tbl$pos)) #calculate inter event distance.

  #If more than one meaningful positions are found within a 5 aa distance, join them to form a cluster.
  if(nrow(clust.tbl) > 1){

    #initialize variables.
    cstart = end = clust.tbl[1,pos]
    n = clust.tbl[1,N]
    cdf = c()
    cluster = 1

    #Go through entire table and update variables.
    for(i in 2:nrow(clust.tbl)){
      pos = clust.tbl[i,pos]

      d = clust.tbl[i,distance]

      if(d < mergeDist){
        end = pos
        n = n + clust.tbl[i,N]
      }else{
        tempdf = data.frame(cluster = paste('cluster', cluster, sep='_'), start = cstart, end = end ,N = n)
        cdf = rbind(cdf, tempdf)
        cstart = end = pos
        n = clust.tbl[i,N]
        cluster = cluster + 1
      }
    }
    cdf = rbind(cdf, data.frame(cluster = paste('cluster', cluster, sep='_'), start = cstart, end = end ,N = n))
  } else {
    cdf = data.frame(cluster = 'cluster_1', start = clust.tbl$pos, end = clust.tbl$pos ,N = clust.tbl$N)
  }

  #merge adjacent variants to clusters.
  for(i in 1:nrow(cdf)){
    tempcdf = cdf[i,]
    nonclust.tbl$startDist = nonclust.tbl$pos - tempcdf$start
    nonclust.tbl$endDist = nonclust.tbl$pos - tempcdf$end

    merge.adj.to.start = nonclust.tbl[startDist >= -5 & startDist <= 0]
    if(nrow(merge.adj.to.start) > 0){
      tempcdf$start = merge.adj.to.start[which(merge.adj.to.start$startDist == min(merge.adj.to.start$startDist)),pos]
      tempcdf$N = tempcdf$N + sum(merge.adj.to.start$N)
    }

    merge.adj.to.end = nonclust.tbl[endDist <= 5 & endDist >= 0]
    if(nrow(merge.adj.to.end) > 0){
      tempcdf$end = merge.adj.to.end[which(merge.adj.to.end$endDist == max(merge.adj.to.end$endDist)),pos]
      tempcdf$N = tempcdf$N + sum(merge.adj.to.end$N)
    }
    cdf[i,] = tempcdf
  }
  cdf$Hugo_Symbol = gene

  #Calcluate cluster score.

  total.muts = nrow(prot.dat) #total variants for this gene.
  clusterScores = c()

  for(i in 1:nrow(cdf)){
    temp.prot.dat = prot.dat[pos >= as.numeric(cdf$start[i]) & pos <= as.numeric(cdf$end[i])]
    temp.prot.dat.summary = temp.prot.dat[,.N, pos]
    temp.prot.dat.summary[,fraction:= N/total.muts]

    peak = temp.prot.dat.summary[N == max(N), pos]

    posVector = as.numeric(temp.prot.dat.summary[,pos])
    fractionMutVector = unlist(lapply(posVector, FUN = function(x) temp.prot.dat.summary[pos == x, fraction]))
    distanceVector = suppressWarnings(abs(posVector - peak))

    clusterScores = c(clusterScores,  sum( fractionMutVector / (sqrt(2)^ distanceVector)))

  }

  cdf$clusterScore = clusterScores

  gene.clust.res = data.frame(Hugo_Symbol = gene, clusters = nrow(cdf), muts_in_clusters = sum(cdf$N), clusterScores = sum(cdf$clusterScore), protLen = protLen)
  return(gene.clust.res)
}

###### Generate lollipop plot for each dataset for selected gene
lollipops.datasets <- function(mafInfo, datasets, gene) {
  
  ##### Create a list to store MAF info for individual datasets
  for ( dataset in datasets ) {
    
    ##### Check if the gene has any mutations in correspoding dataset
    if ( nrow(subsetMaf(maf = mafInfo[[dataset]], includeSyn = TRUE, genes = gene, 
        query = "Variant_Type != 'CNV'")) != 0 ) {
      
      ##### Drawing lollipop for the top 10 genes in each dataset
      ##### Check if the amino acid changes information is available in MAF provided files. The script expects column called "HGVSp_Short", which is produced with vcf2maf (https://github.com/mskcc/vcf2maf) when converting VCFs to MAFs (https://github.com/cBioPortal/cbioportal/issues/2996) and describes a mutation's amino acid change. The "aa_mutation" field used for annotation in ICGC samples is also acceptable. NOTE: other possibilities are: "Protein_Change", "AAChange""
       if ( "HGVSp_Short" %in% maftools::getFields(mafInfo[[dataset]]) && gene %in% mafInfo[[dataset]]@data$Hugo_Symbol ) {
        
        cat(paste("\n\n <b>", dataset, "</b> \n\n", sep=" "))
        
        ##### Make it plot to a dummy graphics device file (e.g. /dev/null) to avoid plotting to the console
        pdf(file="/dev/null")
        lollipopPlot.image <- capture.output(maftools::lollipopPlot(maf = mafInfo[[dataset]], gene = gene, AACol = "HGVSp_Short", printCount = FALSE, showDomainLabel = FALSE, repel = FALSE, labelPos = "all" , showMutationRate = TRUE, cBioPortal = TRUE, fn = paste0(mutationMapsDir, "/", paste(dataset, gene, sep="_"))))
        invisible(dev.off())
        
        ##### Export pdf to png
        lollipopPlot.image <- image_read_pdf(paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".pdf", sep = ""), pages = NULL, density = 300)
        image_write(lollipopPlot.image, path = paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".png", sep = ""), format = "png")
        
        ##### Read in the oncoplots PNG files
        cat("![](",paste(paste0(mutationMapsDir, "/", paste(dataset, gene, sep="_")), ".png", sep = ""),")")
        cat("<br/><br/><br/>")
        
        ##### Remove redundant pdf plot
        file.remove(paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".pdf", sep = ""))
    
      } else if ( "aa_mutation" %in% maftools::getFields(mafInfo[[dataset]]) && gene %in% mafInfo[[dataset]]@data$Hugo_Symbo ) {
        
        cat(paste("\n\n <b>", dataset, "</b> \n\n", sep=" "))
        
        ##### Make it plot to a dummy graphics device file (e.g. /dev/null) to avoid plotting to the console
        pdf(file="/dev/null")
        lollipopPlot.image <- capture.output(maftools::lollipopPlot(maf = mafInfo[[dataset]], gene = gene, AACol = "aa_mutation", printCount = FALSE, showDomainLabel = FALSE, repel = FALSE, labelPos = "all" , showMutationRate = TRUE, cBioPortal = TRUE, fn = paste0(mutationMapsDir, "/", paste(dataset, gene, sep="_"))))
        invisible(dev.off())
        
        ##### Export pdf to png
        lollipopPlot.image <- image_read_pdf(paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".pdf", sep = ""), pages = NULL, density = 300)
        image_write(lollipopPlot.image, path = paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".png", sep = ""), format = "png")
        
        ##### Read in the oncoplots PNG files
        cat("![](",paste(paste0(mutationMapsDir, "/", paste(dataset, gene, sep="_")), ".png", sep = ""),")")
        cat("<br/><br/><br/>")
        
        ##### Remove redundant pdf plot
        file.remove(paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".pdf", sep = ""))
      
      ##### ...otherwise leave a message
      } else {
        
        ##### Check if the genes has any synonymous vatiants
        if ( "HGVSp_Short" %in% names(mafInfo[[dataset]]@maf.silent) && gene %in% mafInfo[[dataset]]@maf.silent$Hugo_Symbol  ) {
        
          cat(paste("This section was skipped for dataset", dataset, "since only synonymous variants were detected in", gene, "gene.\n\n\n\n", sep=" "))
      
        } else if ( "aa_mutation" %in% names(mafInfo[[dataset]]@maf.silent) && gene %in% mafInfo[[dataset]]@maf.silent$Hugo_Symbol  ) {
          
          cat(paste("This section was skipped for dataset", dataset, "since only synonymous variants were detected in", gene, "gene.\n\n\n\n", sep=" "))
      
        } else {
          cat(paste("This section was skipped for dataset", dataset, "since the corresponding MAF does not contain field with amino acid changes details!\n\n\n\n", sep=" "))
        }
      }
        
      } else {
        
      cat(paste("\n\n <b>", dataset, "</b> \n\n", sep=" "))
      cat(paste("Gene <i>", gene, "</i> has no mutations reported in dataset", dataset, "\n\n\n\n", sep=" "))
    }
  }
}
```

```{r load_libraries, warning=FALSE}
suppressMessages(library(knitr))
suppressMessages(library(maftools))
suppressMessages(library(dndscv))
suppressMessages(library(ggplot2))
suppressMessages(library(DT))
suppressMessages(library(UpSetR))
suppressMessages(library(stringr))
suppressMessages(library(magick))
```

```{r load_data, message=FALSE, warning=FALSE, results='hide'}
##### Split the string of MAF files and put them into a vector
mafFiles <- unlist(strsplit(params$maf_files, split=',', fixed=TRUE))
mafFiles <- paste(params$maf_dir, mafFiles, sep="/")

##### Split the string of datasets names and put them into a vector
datasets.list <- unlist(strsplit(params$datasets, split=',', fixed=TRUE))

##### Read MAF files and put associated info into a list
##### Create a list to store MAF info for individual datasets
mafInfo <- vector("list", length(mafFiles))
names(mafInfo) <- datasets.list

##### NOTE: maftools by default summarises only non-synonymous variants with high/moderate variant consequences and ignores silent variants (https://github.com/PoisonAlien/maftools/issues/63), which are stored in "maf.silent" slot of the class MAF object (mafInfo[[i]]@maf.silent)
for ( i in 1:length(mafFiles) ) {
  mafInfo[[i]] <- maftools::read.maf(maf = mafFiles[i], vc_nonSyn = params$nonSyn_list, removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE)
}

##### Read in list of genes of interest of specified
if ( !is.na(params$genes_list) ){
  
  goi <- unique(read.table(params$genes_list, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)[,1])
}

##### Create directory for output files
outDir <- paste(params$maf_dir, params$out_folder, sep = "/")
if ( !file.exists(params$out_folder) ){

  dir.create(outDir, recursive=TRUE)
}

##### Read in OncodriveFML analysis results (https://oncodrivefml.readthedocs.io/en/latest/output.html)
runOncodrivefmlChunk <- FALSE

if ( !is.na(params$oncodrivefml) ){
  
  oncodriveFML.res <- unlist(strsplit(params$oncodrivefml, split=',', fixed=TRUE))
  
  oncodriveFML.res.table <- vector("list", length(mafFiles))
  names(oncodriveFML.res.table) <- datasets.list
  
  for ( i in 1:length(mafFiles) ) {
    
    ##### Read in the results table
    if ( file.exists(paste0(oncodriveFML.res[i], ".tsv")) ) {
      
      oncodriveFML.res.table[[i]] <- read.table(paste0(oncodriveFML.res[i], ".tsv"), sep="\t", as.is=FALSE, header=TRUE, row.names=NULL)
      
    } else {
      ##### Create empty data frame
      oncodriveFML.res.table[[i]] <- data.frame(matrix(NA, nrow = 0, ncol = 12))
      names(oncodriveFML.res.table[[i]]) <- c("GENE_ID", "MUTS", "MUTS_RECURRENCE", "SAMPLES", "P_VALUE", "Q_VALUE", "P_VALUE_NEG", "Q_VALUE_NEG", "SNP", "MNP", "INDELS", "SYMBOL")
    }
  }
  runOncodrivefmlChunk <- TRUE
  
}

##### Read in OncodriveFML configuration file (https://oncodrivefml.readthedocs.io/en/latest/output.html)
oncodrivefml.conf <- NULL

if ( !is.na(params$oncodrivefml_conf) ){
  
  ##### Read in the results table
  if ( file.exists(paste0(oncodriveFML.res[i], ".tsv")) ) {
      
    oncodrivefml.conf <- read.table(params$oncodrivefml_conf, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL, comment.char="")
      
  }
}

##### Initiate a list to record sinigficant driver genes for each dataset
signif_genes.datasets <- vector("list", length(mafFiles))
names(signif_genes.datasets) <- datasets.list

##### Initiate a list to record sinigficant driver genes for each method
if ( runOncodrivefmlChunk ) {
  
  methods <- c("dNdScv", "dNdSloc", "OncodriveCLUST", "OncodriveFML")
} else {
  methods <- c("dNdScv", "dNdSloc", "OncodriveCLUST")
}

signif_genes.methods <- vector("list", length(methods))
names(signif_genes.methods) <- methods
```

```{r exclude_samples, comment = NA, message=FALSE, warning=FALSE}
##### Exclude user-derined samples(s) from the analysis
if ( !is.na(params$samples_blacklist) ) {
    
  for ( i in 1:length(mafFiles) ) {
      
    ##### Read in list of samples to be excluded
    exclsamples.df <- read.table(params$samples_blacklist, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL)
    exclsamples <- unique(exclsamples.df[,"Tumor_Sample_Barcode"])
    
    samples2keep <- unlist(unique( mafInfo[[i]]@maf.silent[, "Tumor_Sample_Barcode"]))[ unlist(unique(mafInfo[[i]]@maf.silent[, "Tumor_Sample_Barcode"])) %!in% exclsamples ]
    
    ##### Subset the maf object to exclude use-defined sample(s)
    ##### Initially don't save the subset output as maf object, as this will exlude samples with no non-synonymous mutations from the summary
    mafInfo[[i]] <- subsetMaf(maf = mafInfo[[i]], tsb = as.vector(samples2keep), genes = NULL, fields = NULL, query = NULL, mafObj = FALSE, includeSyn = TRUE, dropLevels=TRUE)
    
    ##### Now read the data subset as a maf object
    mafInfo[[i]] <- maftools::read.maf(maf = mafInfo[[i]], vc_nonSyn = params$nonSyn_list, removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE)
  }
}
```

```{r exclude_genes, comment = NA, message=FALSE, warning=FALSE}
##### Exclude user-derined gene(s) from the analysis
if ( !is.na(params$genes_blacklist) ) {
    
  for ( i in 1:length(mafFiles) ) {
    
    ##### Read in list of genes to be excluded
    exclgenes <- unique(read.table(params$genes_blacklist, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)[,1])
    
    genes2keep <- unique( mafInfo[[i]]@data$Hugo_Symbol)[ unique( mafInfo[[i]]@data$Hugo_Symbol) %!in% exclgenes ]
  
    ##### Subset the maf object to exclude use-defined gene(s)
    ##### Initially don't save the subset output as maf object, as this will exlude samples with no non-synonymous mutations from the summary
    mafInfo[[i]] <- subsetMaf(maf = mafInfo[[i]], tsb = NULL, genes = genes2keep, fields = NULL, query = NULL, mafObj = FALSE, includeSyn = TRUE)
    
    ##### Now read the data subset as a maf object
    mafInfo[[i]] <- maftools::read.maf(maf = mafInfo[[i]], vc_nonSyn = params$nonSyn_list, removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE)
  }
} else {
  
  genes2keep <- mafInfo[[i]]@gene.summary$Hugo_Symbol
}
```

```{r silent_variants, comment = NA, message=FALSE, warning=FALSE}
##### Identify and record samples with no non-synonymous mutations
##### Prepare list to store all samples and samples with > 0 non-synonymous variants
MAF_samples <- vector("list", length(datasets.list))
names(MAF_samples) <- datasets.list
MAF_samples.silent.df <- NULL

##### Loop through MAF files
for ( i in 1:length(mafFiles) ) {
  
  ##### Identify samples with no non-synonymours variants according to corresponding MAF file
  MAF_samples[[i]]$all <- unlist(unique(mafInfo[[i]]@maf.silent[, "Tumor_Sample_Barcode"]))
  MAF_samples[[i]]$nonsyn <- unlist(maftools::getSampleSummary(mafInfo[[i]])[, "Tumor_Sample_Barcode"])
  MAF_samples[[i]]$silent <-  MAF_samples[[i]]$all[ MAF_samples[[i]]$all %!in% MAF_samples[[i]]$nonsyn  ]
  
  ##### Check if there thre are any samples with no non-synonymours variants. If so, add them to data frame
  if ( length(MAF_samples[[i]]$silent) > 0 ) {
    for ( sample in MAF_samples[[i]]$silent ) {
      
      MAF_samples.silent.df <- rbind( MAF_samples.silent.df, cbind( datasets.list[i], sample))
    }
    colnames(MAF_samples.silent.df) <- c("Dataset", "Sample")
  }
}
```

```{r dndscv_format_data, comment = NA, message=FALSE, warning=FALSE }
##### The input data is supposed to be a data.frame with five columns (sampleID, chr, pos, ref [base], mutant [base])
##### Convert the MAF calss objest to the format relevant for dndscv
dndscvInfo <- vector("list", length(mafFiles))
names(dndscvInfo) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  
  dndscvInfo[[i]] <- rbind(mafInfo[[i]]@data[, c("Tumor_Sample_Barcode", "Chromosome", "Start_Position", "Reference_Allele", "Tumor_Seq_Allele2")], mafInfo[[i]]@maf.silent[, c("Tumor_Sample_Barcode", "Chromosome", "Start_Position", "Reference_Allele", "Tumor_Seq_Allele2")])
  names(dndscvInfo[[i]]) <- c("sampleID", "chr", "pos", "ref", "mut")
}
```

```{r dndscv_driver_analysis, comment = NA, message=FALSE, warning=FALSE }
##### Run dN/dS approach for cancer driver discovery using dNdScv option, which combines local information (synonymous mutations in the gene) and global information (variation of the mutation rate across genes, exploiting epigenomic covariates) to estimate the background mutation rate

##### Get reference database
eval(parse( text=paste0("data(refcds_hg", params$ucsc_genome_assembly, ", package=\"dndscv\")")))

dndsout <- vector("list", length(mafFiles))
names(dndsout) <- datasets.list

ci <- vector("list", length(mafFiles))
names(ci) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  
  ##### Run analysis for selected genes
  if ( !is.na(params$genes_list) ){
    
    ##### First, check if all genes are in the RefCDS transcripts object
    RefCDSgenes <- goi[ goi %in% sapply(RefCDS, function(x) x$gene_name) ]
    
    dndsout[[i]] <- dndscv(dndscvInfo[[i]], gene_list = goi, refdb = paste0("hg", as.character(params$ucsc_genome_assembly)), sm = "192r_3w", kc = "cgc81", cv = paste0("hg", as.character(params$ucsc_genome_assembly)), max_muts_per_gene_per_sample = params$max_muts_per_gene, max_coding_muts_per_sample = params$hypermut_sample_cutoff, use_indel_sites = TRUE, min_indels = 5, maxcovs = 20, constrain_wnon_wspl = TRUE, outp = 3, numcode = 1, outmats = TRUE)
    
    ##### Calculate confidence intervals for the dN/dS ratios per gene
    if ( params$ratios_ci ) {
      ci[[i]] = geneci(dndsout[[i]])
    }
    
  ##### Run analysis for all genes
  } else {
    
    ##### First, check if all genes are in the RefCDS transcripts object
    RefCDSgenes <- genes2keep[ genes2keep %in% sapply(RefCDS, function(x) x$gene_name) ]
    
    dndsout[[i]] <- dndscv(dndscvInfo[[i]], gene_list = RefCDSgenes, refdb = paste0("hg", as.character(params$ucsc_genome_assembly)), sm = "192r_3w", kc = "cgc81", cv = paste0("hg", as.character(params$ucsc_genome_assembly)), max_muts_per_gene_per_sample = params$max_muts_per_gene, max_coding_muts_per_sample = params$hypermut_sample_cutoff, use_indel_sites = TRUE, min_indels = 5, maxcovs = 20, constrain_wnon_wspl = TRUE, outp = 3, numcode = 1, outmats = TRUE)

    ##### Calculate confidence intervals for the dN/dS ratios per gene
    if ( params$ratios_ci ) {
      ci[[i]] = geneci(dndsout[[i]])
    }
  }
}
```

```{r dndscv_summarise, comment = NA, message=FALSE, warning=FALSE}
##### Write dndscv summary into a file
sel_cv <- vector("list", length(mafFiles))
names(sel_cv) <- datasets.list

theta <- vector("list", length(mafFiles))
names(theta) <- datasets.list

signif_genes_cv <- vector("list", length(mafFiles))
names(signif_genes_cv) <- datasets.list

signif_genes_loc <- vector("list", length(mafFiles))
names(signif_genes_loc) <- datasets.list

exclsamples <- vector("list", length(mafFiles))
names(exclsamples) <- datasets.list

exclmuts <- vector("list", length(mafFiles))
names(exclmuts) <- datasets.list

globaldnds <- vector("list", length(mafFiles))
names(globaldnds) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  
  ##### Calculate theta estimtates
  theta[[i]] <- round(dndsout[[i]]$nbreg$theta, digits = 2)
  
  ##### Get a table of significant genes
  sel_cv[[i]] <- dndsout[[i]]$sel_cv
  signif_genes_cv[[i]] <- sel_cv[[i]][sel_cv[[i]]$qglobal_cv < params$q_value, ]
  rownames(signif_genes_cv[[i]]) = NULL
  
  ##### Organise the table of significant genes
  ##### Add confidence intervals for the dN/dS ratios per gene
  if ( params$ratios_ci ) {
    
    signif_genes_cv[[i]] <- merge( signif_genes_cv[[i]], ci[[i]], by.x="gene_name", by.y="gene", all.x = TRUE, all.y = FALSE, sort = FALSE)
    
    ##### Organise the table of significant genes
    signif_genes_cv[[i]] <- signif_genes_cv[[i]][ , c("gene_name", "pglobal_cv", "qglobal_cv", "n_syn", "n_mis", "n_non", "n_spl", "n_ind", "wmis_cv", "mis_low", "mis_high", "pmis_cv", "qmis_cv", "wnon_cv", "wspl_cv", "tru_mle", "tru_low", "tru_high", "ptrunc_cv", "qtrunc_cv", "pallsubs_cv", "qallsubs_cv", "wind_cv", "pind_cv")]
    
  } else {
    
    ##### Organise the table of significant genes
    signif_genes_cv[[i]] <- signif_genes_cv[[i]][ , c("gene_name", "pglobal_cv", "qglobal_cv", "n_syn", "n_mis", "n_non", "n_spl", "n_ind", "wmis_cv", "pmis_cv", "qmis_cv", "wnon_cv", "wspl_cv", "ptrunc_cv", "qtrunc_cv", "pallsubs_cv", "qallsubs_cv", "wind_cv", "pind_cv")]
  }

  ##### Record excluded (hypermutated) samples
  if (!is.null(dndsout[[i]]$exclsamples)) {
    
    exclsamples[[i]] <- as.data.frame(dndsout[[i]]$exclsamples)
    names(exclsamples[[i]]) <- "sampleID"
      
  } else {
    
    exclsamples[[i]] <- data.frame(matrix(ncol = 1, nrow = 0))
    names(exclsamples[[i]]) <- "sampleID"
  }
  
  ##### Record excluded mutations (mutations when encountering too many mutations per gene in the same sample)
  if (!is.null(dndsout[[i]]$exclmuts)) {
    
    exclmuts[[i]] <- dndsout[[i]]$exclmuts
    exclmuts[[i]] <- exclmuts[[i]][, c("gene", "sampleID", "chr", "pos", "ref", "mut", "start", "end", "geneind")]
  
    } else {
    
    exclmuts[[i]] <- data.frame(matrix(ncol = 9, nrow = 0))
    names(exclmuts[[i]]) <- c("gene", "sampleID", "chr", "pos", "ref", "mut", "start", "end", "geneind")
  }
  
  ##### Extract global maximum-likelihood estimates (MLEs) for the dN/dS ratios across all genes
  globaldnds[[i]] <- dndsout[[i]]$globaldnds
  
  ##### Extract results from the local neutrality test based on the dNdSloc model
  signif_genes_loc[[i]] <- dndsout[[i]]$sel_loc[ dndsout[[i]]$sel_loc$qall_loc < params$q_value, ]
  rownames(signif_genes_loc[[i]]) = NULL
  
  ##### Organise the table of significant genes
  signif_genes_loc[[i]] <- signif_genes_loc[[i]][ , c("gene_name", "pall_loc", "qall_loc", "n_syn", "n_mis", "n_non", "n_spl", "wmis_loc", "pmis_loc", "qmis_loc", "wnon_loc", "wspl_loc")]
    
  ##### Record sinigficant driver genes for each dataset and method
  signif_genes.datasets[[i]] <- list(dNdScv = as.character(signif_genes_cv[[i]]$gene_name), dNdSloc = as.character(signif_genes_loc[[i]]$gene_name))
  
  signif_genes.methods[[i]] <- vector("list", length(datasets.list))
  names(signif_genes.methods[[i]]) <- datasets.list
  
  signif_genes.methods$dNdScv[[i]] <- as.character(signif_genes_cv[[i]]$gene_name)
  signif_genes.methods$dNdSloc[[i]] <- as.character(signif_genes_loc[[i]]$gene_name)
}
```

```{r exclude_hypermutators, comment = NA, message=FALSE, warning=FALSE}
##### Exclude hypermutators from MAF object based on user-derined threshold
mafInfo.all <- mafInfo

for ( i in 1:length(mafFiles) ) {
  
  if ( nrow(exclsamples[[i]]) > 0 ) {
    
    sample2keep <- unique( mafInfo[[i]]@data$Tumor_Sample_Barcode)[ unique( mafInfo[[i]]@data$Tumor_Sample_Barcode) %!in% exclsamples[[i]]$sampleID ]
      
    ##### Extract required data from MAF
    mafInfo[[i]] <- subsetMaf(maf = mafInfo[[i]], tsb = sample2keep, genes = NULL, fields = NULL, query = NULL, mafObj = TRUE, includeSyn = TRUE)
  }
}
```

```{r oncodriveCLUST_analysis,  include=FALSE }
##### In this chunk the clusters variants are calculated, but the results are reported in the next chunk
##### Import protein info data provided within maftools package
gl <- data.table::fread(input = paste("zcat <", system.file("extdata", "prot_len.txt.gz", package = "maftools")), sep = "\t", stringsAsFactors = FALSE)

##### Create a list to store MAF info for individual datasets
oncodriveClust.res <- vector("list", length(mafFiles))
names(oncodriveClust.res) <- datasets.list

signif_genes.methods$OncodriveCLUST <- vector("list", length(datasets.list))
names(signif_genes.methods$OncodriveCLUST) <- datasets.list
  
###### Generate separate plot for each dataset
for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the amino acid changes information is available in MAF provided files. The script expects column called "HGVSp_Short", which is produced with vcf2maf (https://github.com/mskcc/vcf2maf) when converting VCFs to MAFs (https://github.com/cBioPortal/cbioportal/issues/2996) and describes a mutation's amino acid change. The "aa_mutation" field used for annotation in ICGC samples is also acceptable.
  if ( "HGVSp_Short" %in% maftools::getFields(mafInfo[[i]]) ) {
          
    oncodriveClust.res[[datasets.list[i]]] <- oncodrive.mod(mafInfo[[i]], datasets.list[i], AACol = "HGVSp_Short", gl) 

  } else if ( "aa_mutation" %in% maftools::getFields(mafInfo[[i]]) ) {
    
    oncodriveClust.res[[datasets.list[i]]] <- oncodrive.mod(mafInfo[[i]], datasets.list[i], AACol = "aa_mutation", gl)
    
  } else {
    cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n\n\n", sep=" "))
  }
  
  ##### Order results by genes' increasing FDR and then by decreasing total number of mutations
  oncodriveClust.res[[datasets.list[i]]][[1]] <- oncodriveClust.res[[datasets.list[i]]][[1]][ order(oncodriveClust.res[[datasets.list[i]]][[1]][, "fdr"],  rev(unlist(oncodriveClust.res[[datasets.list[i]]][[1]][, "total"]))) , ]
  
  ##### Record sinigficant driver genes for each dataset and method
  signif_genes.datasets[[i]]$OncodriveCLUST <- as.character(oncodriveClust.res[[datasets.list[i]]][[1]]$Hugo_Symbol)
  signif_genes.methods$OncodriveCLUST[[i]] <- as.character(oncodriveClust.res[[datasets.list[i]]][[1]]$Hugo_Symbol)
}
```

```{r oncodriveFML_load_results,  include=FALSE, eval=runOncodrivefmlChunk}
##### Create a list to store OncodriveFML info for individual datasets
signif_genes.methods$oncodriveFML <- vector("list", length(datasets.list))
names(signif_genes.methods$oncodriveFML) <- datasets.list

oncodriveFML.res.table.signif <- vector("list", length(datasets.list))
names(oncodriveFML.res.table.signif) <- datasets.list

###### Record results for each dataset
for ( i in 1:length(mafFiles) ) {
  
  ##### Move gene name to the first column
  col_idx <- grep("SYMBOL", names(oncodriveFML.res.table[[i]]))
  oncodriveFML.res.table[[i]] <- subset(oncodriveFML.res.table[[i]], select=c(names(oncodriveFML.res.table[[i]])[c(col_idx, c(1:ncol(oncodriveFML.res.table[[i]]))[-col_idx])]))

  ##### Order the table by P_VALUE, MUTS and SAMPLES
  oncodriveFML.res.table[[i]] <- oncodriveFML.res.table[[i]][ order(oncodriveFML.res.table[[i]]$P_VALUE), ]
  oncodriveFML.res.table[[i]] <- oncodriveFML.res.table[[i]][ order( oncodriveFML.res.table[[i]]$MUTS, oncodriveFML.res.table[[i]]$SAMPLES, decreasing = TRUE), ]
    
  ##### Record sinigficant driver genes for each dataset and method
  signif_genes.datasets[[i]]$OncodriveFML <- unique(c(as.character(oncodriveFML.res.table[[i]]$SYMBOL)[ oncodriveFML.res.table[[i]]$P_VALUE < params$oncodrivefml_p  ], as.character(oncodriveFML.res.table[[i]]$SYMBOL)[ oncodriveFML.res.table[[i]]$Q_VALUE < params$oncodrivefml_q ]))
  signif_genes.methods$OncodriveFML[[i]] <- unique(c(as.character(oncodriveFML.res.table[[i]]$SYMBOL)[ oncodriveFML.res.table[[i]]$P_VALUE < params$oncodrivefml_p  ], as.character(oncodriveFML.res.table[[i]]$SYMBOL)[ oncodriveFML.res.table[[i]]$Q_VALUE < params$oncodrivefml_q ]))
  
  ##### Remove NAs
  signif_genes.datasets[[i]]$OncodriveFML <- signif_genes.datasets[[i]]$OncodriveFML[ !is.na(signif_genes.datasets[[i]]$OncodriveFML)]
  signif_genes.methods$OncodriveFML[[i]] <- signif_genes.methods$OncodriveFML[[i]][ !is.na(signif_genes.methods$OncodriveFML[[i]])]
  
  ##### Report the sinig
  oncodriveFML.res.table.signif[[i]] <- oncodriveFML.res.table[[i]][ oncodriveFML.res.table[[i]]$SYMBOL %in%  signif_genes.datasets[[i]]$OncodriveFML , ]
}
```

```{r driver_genes_summary, comment = NA, message=FALSE, warning=FALSE}
##### Compute the intersections between cancer driver genes detected by various methods
signif_genes.upset <- vector("list", length(mafFiles))
names(signif_genes.upset) <- datasets.list

signif_genes.upset.mod <- vector("list", length(mafFiles))
names(signif_genes.upset.mod) <- datasets.list

signif_genes <- vector("list", length(mafFiles))
names(signif_genes) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  
  signif_genes[[i]] <- verify_genes(unlist(signif_genes.datasets[[i]]))
  
  if ( length(signif_genes[[i]]) > 0 ) {
    
    ##### Create empty data frame for the upset() function (0 = not driver gene, 1 = driver gene)
    signif_genes.upset[[i]] <- data.frame(matrix(NA, nrow = length(signif_genes.datasets[[i]]), ncol = length(signif_genes[[i]])))
    names(signif_genes.upset[[i]]) <- signif_genes[[i]]
    rownames(signif_genes.upset[[i]]) <- names(signif_genes.datasets[[i]])
    
    ##### Check which genes were detected by individual method
    for( gene in signif_genes[[i]] ) {
      
      for ( j in 1:length(signif_genes.datasets[[i]]) ) {
        
        if ( gene %in% verify_genes(signif_genes.datasets[[i]][[j]]) ) {
          
          signif_genes.upset[[i]][ names(signif_genes.datasets[[i]][j]) , gene] <- 1
          
        } else {
          signif_genes.upset[[i]][ names(signif_genes.datasets[[i]][j]) , gene] <- 0
        }
      }
    }
    
    ##### Add column with summarised counts for each gene and organise the intersections summary table
    signif_genes.upset.mod[[i]] <- as.data.frame(t(signif_genes.upset[[i]]))
    signif_genes.upset.mod[[i]]$Total <- rowSums( signif_genes.upset.mod[[i]] )
    signif_genes.upset.mod[[i]] <- signif_genes.upset.mod[[i]][ order( signif_genes.upset.mod[[i]][, "Total"], signif_genes.upset.mod[[i]][, "dNdScv"], signif_genes.upset.mod[[i]][, "dNdSloc"], signif_genes.upset.mod[[i]][, "OncodriveCLUST"], decreasing = TRUE),  ] 
    
    for ( j in 1:length(signif_genes.datasets[[i]])) {
    
      signif_genes.upset.mod[[i]][ signif_genes.upset.mod[[i]][, j] == 1, j ] <- "Yes"
      signif_genes.upset.mod[[i]][ signif_genes.upset.mod[[i]][, j] == 0, j ] <- "No"
    }
  }
}
```

## Datasets  {.tabset}

This report summarises and visualises driver analyses results for the following dataset(s):

```{r datasets, comment = NA}
##### Present patient cohorts to be summarised
datasets.df <- as.data.frame( cbind(datasets.list, unlist(strsplit(params$maf_files, split=',', fixed=TRUE))) )
names(datasets.df) <- c("Dataset", "MAF file")

DT::datatable( data = datasets.df, filter = "none", extensions = 'Buttons', options = list(pageLength = length(mafFiles), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy')) ) %>%
        DT::formatStyle( columns = names(datasets.df), 'text-align' = 'center' )
```

### Overall summary

Table(s) with basic information about each dataset based on data in corresponding MAF file(s).

```{r overll_summary, comment = NA, message=FALSE, warning=FALSE}
##### Present a MAF file summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable( data = mafInfo.all[[i]]@summary, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "none", extensions = 'Buttons', options = list(pageLength = nrow(mafInfo.all[[i]]@summary), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis')) ) %>%
        DT::formatStyle( columns = names(mafInfo.all[[i]]@summary), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### Samples summary {.tabset}

#### Samples with non-synonymous variant(s)

Table(s) summarising samples in individual datasets. Each table contains per-sample information (rows) about *number of different types of mutations* (columns), as well as the *total number of mutations* reported in corresponding MAF file. Note, only **samples with detected non-synonymous variant(s)** are reported in the table below.

```{r sample_summary, comment = NA, warning=FALSE}
##### Present a sample table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable( data = maftools::getSampleSummary(mafInfo.all[[i]]), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
        DT::formatStyle( columns = names(maftools::getSampleSummary(mafInfo.all[[i]])), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()
```

***

#### Samples with no non-synonymous variants

Table listing sample(s) in which **no non-synonymous variants** were detected and hence will not be included in the summary tables/plots.

```{r sample_no_nonsynonymous, comment = NA, warning=FALSE}
##### report samples with no non-synonymous variants according to corresponding MAF file
if ( !is.null(MAF_samples.silent.df) ) {

  DT::datatable( data = MAF_samples.silent.df, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong("Samples with no non-synonymours variants detected")), filter = "top", extensions = 'Buttons', options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy')) ) %>%
        DT::formatStyle( columns = names(MAF_samples.silent.df), 'text-align' = 'center' )
  
} else {
  cat("Non-synonymous variants were detected in all samples.\n\n\n")
}

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

#### Excluded samples

List of samples excluded from the analysis.

```{r excluded_samples_table, comment = NA, message=FALSE, warning=FALSE}
##### Present a samples table in the html report
if ( !is.na(params$samples_blacklist) ) {
    
  DT::datatable(data = exclsamples.df, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;'), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 1), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
      DT::formatStyle( columns = names(exclsamples.df), 'text-align' = 'center' )
  
} else {
  cat("No samples were excluded.\n\n\n")
}
```

***

#### Hypermutator samples

Table(s) listing sample(s) with > `r params$hypermut_sample_cutoff` coding mutations. These have been removed from the analyses to protect against loss of sensitivity from ultra-hypermutators.

```{r hypermutator_samples, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = exclsamples[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(exclsamples[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 1), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
        DT::formatStyle( columns = names(exclsamples[[i]]), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### Genes summary {.tabset}

#### Mutated genes

Table(s) summarising mutated genes in individual datasets. Each table contains per-gene information (rows) about *number of different types of mutations* (columns), as well as the *total number of mutations* reported in corresponding MAF file. The last two columns contain the *number of samples with mutations/alterations* in the corresponding gene.

```{r gene_summary, warning=FALSE}
##### Present a gene table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable(data = maftools::getGeneSummary(mafInfo.all[[i]]), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
        DT::formatStyle( columns = names(maftools::getGeneSummary(mafInfo.all[[i]])), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list
```

***

#### Excluded genes

List of genes excluded from the analysis.

```{r excluded_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Present a gene table in the html report
if ( !is.na(params$genes_blacklist) ) {
    
  DT::datatable(data = data.frame(Gene = exclgenes), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;'), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
    DT::formatStyle( columns = "Gene", 'text-align' = 'center' )
  
} else {
  cat("No genes were excluded.\n\n\n")
}
```

***

## Driver genes detection

### dN/dS {.tabset}

Selection analyses and cancer driver discovery using [dNdScv](https://github.com/im3sanger/dndscv){target="_blank"} R package. It provides *maximum-likelihood dN/dS* methods designed to quantify selection in cancer and somatic evolution ([Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"}). The package contains functions two different models (**dNdScv** and **dNdSloc**) to quantify dN/dS ratios for missense, nonsense and essential splice mutations, at the level of individual genes, groups of genes or at whole-genome level. The [dNdScv](https://github.com/im3sanger/dndscv){target="_blank"} package was designed to detect cancer driver genes (i.e. genes under positive selection in cancer) on datasets ranging from a few samples to thousands of samples, in whole-exome/genome or targeted sequencing studies.

<details>
<summary>dNdScv model</summary>

Combines local information (synonymous mutations in the gene) and global information (variation of the mutation rate across genes, exploiting epigenomic covariates) to estimate the background mutation rate. It is a preferred model in most situations.
</details>

<details>
<summary>dNdSloc model</summary>

Based on local neutrality test, in which the number of synonymous mutations in a gene is used to infer the local mutation rate ([Wong *et al*., 2014](https://www.ncbi.nlm.nih.gov/pubmed/24316979){target="_blank"}), without exploiting additional information from other genes. This test is typically only powered in very large datasets.
</details>

<details>
<summary>Which model to use?</summary>
***dNdScv*** is a preferred model in most situations. However, low estimates of theta (θ, the overdispersion parameter), particularly θ < 1, may reflect problems with the suitability of the dNdScv model for the dataset. In these cases, it is reasonable to consider the traditional *dN/dS* (***dNdSloc***) model.
</details>

<details>
<summary>Samples/mutations exclusion</summary>
By default, it is assumed that mutation data is mapped to the **GRCh37/hg19**. The *buildref* function (described [here](http://htmlpreview.github.io/?http://github.com/im3sanger/dndscv/blob/master/vignettes/buildref.html){target="_blank"}) can be used to generate the necessary reference file to run [dNdScv](https://github.com/im3sanger/dndscv){target="_blank"} on others assembly.

**Ultra-hypermutator samples** (with > `r params$hypermut_sample_cutoff` coding mutations) **are removed** and **mutations with > `r params$max_muts_per_gene` mutations per gene** in the same sample **are subsampled** to protect against loss of sensitivity from ultra-hypermutators and from clustered artefacts.
</details>

The estimated **theta** (θ, the overdispersion parameter) value(s) for dataset(s) `r names(unlist(theta))` are: **`r unlist(theta)`**, respectively.

***

**NOTE**: this analysis uses **only non-synonymous variants** defined as variants with the following consequences: *`r params$nonSyn_list`*.

<details>
<summary>Variants consequence impact definitions</summary>
<font size="2">

* [*High impact variant consequence*](http://asia.ensembl.org/Help/Glossary?id=535){target="_blank"} -	the variant is assumed to have high (disruptive) impact in the protein, probably causing protein truncation, loss of function or triggering nonsense mediated decay.

* [*Moderate impact variant consequence*](http://asia.ensembl.org/Help/Glossary?id=535){target="_blank"} -	a non-disruptive variant that might change protein effectiveness.

* [*Low impact variant consequence*](http://asia.ensembl.org/Help/Glossary?id=535){target="_blank"} -	a variant that is assumed to be mostly harmless or unlikely to change protein behaviour.

Variants with high/moderate variant consequences include: *frame shift deletions*, *frame shift deletions*, *splice site mutations*, *translation start site mutations*, *nonsense mutation*, *nonstop mutations*, *in-frame deletion*, *in-frame insertions* and *missense mutation*.

</font> 
</details>

***

#### Plots {.tabset}

##### dNdScv

*X-axis* indicates the *number of variants* observed in individual genes and *y-axis* illustrates *global q-values* in -log10 scale. The *size* of the points is proportional to -log10 *p-values* based on all non-synonymous substitutions detected in individual genes. The *colour* scale reflects *p-values* computed for indels, with purple and yellow indicating low and high *p-values*, respectively.

```{r dndscv_plot, comment = NA, message=FALSE, warning=FALSE}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  if ( nrow(signif_genes_cv[[i]]) > 0 ) {
      
    ##### Avoid q-values of 0 by assigning 1*10^-16 to extremely low q-values
    q_global <- signif_genes_cv[[i]]$qglobal_cv
    q_global[ q_global == 0 ] <- 1*10^-16
    p_subs <- signif_genes_cv[[i]]$pallsubs_cv
    p_subs[ p_subs == 0 ] <- 1*10^-16
    p_ind <- signif_genes_cv[[i]]$pind_cv
    p_ind[ p_ind == 0 ] <- 1*10^-16
    
    ##### Sum up all mutations
    mutations_no <- rowSums(signif_genes_cv[[i]][ , names(signif_genes_cv[[i]]) %in% c("n_syn", "n_mis", "n_non", "n_spl", "n_ind") ])
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(signif_genes_cv[[i]]$gene_name, q_global, mutations_no, p_subs, p_ind )
    colnames(data.df) <- c("gene", "q_global", "mutations_no", "p_subs", "p_ind")
    
    ##### Calculate x and y axis rangeby adding 10% of the original range
    x_range <- c(0, max(data.df$mutations_no) + max(data.df$mutations_no)*0.1)
    y_range <- c(0, max(-log(data.df$q_global,10)) + max(-log(data.df$q_global,10))*0.1)
    
    ##### Generate scatter-plot
    p <- plot_ly(data.df, x = ~mutations_no, y = -log(data.df$q_global,10), color = data.df$p_ind, size = -log(data.df$p_subs,10), text = ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
      add_text(textfont = list(size = 10), textposition = "top") %>%
      layout(title = datasets.list[i], xaxis = list(title = "Number of mutations", range = x_range), yaxis = list(title = "-log10( q-value )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = TRUE, legend = list(orientation = "v", y = 0.9))
  
    ##### Add plot to the list for htmlwidgets
    widges.list[[i]] <- as_widget(ggplotly(p))
    
    ##### Save the plot as html (PLOTLY)
    htmlwidgets::saveWidget(as_widget(p), paste0(outDir, "/driver_analysis_dndscv_plot_", datasets.list[i], ".html"), selfcontained = TRUE)
    
  } else {
      cat(paste("None of the mutated genes demonstrated significant global q-value in dataset", datasets.list[i], "\n\n\n\n", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

##### dNdSloc

*X-axis* indicates the *number of variants* observed in individual genes and *y-axis* illustrates *q-values* (in -log10 scale) based on all non-synonymous substitutions. The *size* of the points is proportional to -log10 *q-values* based exclusively on missense substitutions detected in individual genes.

```{r dndsloc_plot, comment = NA, message=FALSE, warning=FALSE}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  if ( nrow(signif_genes_loc[[i]]) > 0 ) {
    
    ##### Avoid q-values of 0 by assigning 1*10^-16 to extremely low q-values
    q_all <- signif_genes_loc[[i]]$qall_loc
    q_all[ q_all == 0 ] <- 1*10^-16
    q_mis <- signif_genes_loc[[i]]$qmis_loc
    q_mis[ q_mis == 0 ] <- 1*10^-16
    
    ##### Sum up all mutations
    mutations_no <- rowSums(signif_genes_loc[[i]][ , names(signif_genes_loc[[i]]) %in% c("n_syn", "n_mis", "n_non", "n_spl") ])
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(signif_genes_loc[[i]]$gene_name, q_all, mutations_no, q_mis )
    colnames(data.df) <- c("gene", "q_all", "mutations_no", "q_mis")
    
    ##### Calculate x and y axis rangeby adding 10% of the original range
    x_range <- c(0, max(data.df$mutations_no) + max(data.df$mutations_no)*0.1)
    y_range <- c(0, max(-log(data.df$q_all,10)) + max(-log(data.df$q_all,10))*0.1)
    
    ##### Generate scatter-plot
    p <- plot_ly(data.df, x = ~mutations_no, y = -log(data.df$q_all,10), size = -log(data.df$q_mis,10), text= ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
      add_text(textfont = list(size = 10), textposition = "top") %>%
      layout(title = datasets.list[i], xaxis = list(title = "Number of mutations", range = x_range), yaxis = list(title = "-log10( q-value )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE )

    ##### Add plot to the list for htmlwidgets
    widges.list[[i]] <- as_widget(ggplotly(p))
    
    ##### Save the plot as html (PLOTLY)
    htmlwidgets::saveWidget(as_widget(p), paste0(outDir, "/driver_analysis_dndsloc_plot_", datasets.list[i], ".html"), selfcontained = TRUE)
  
  } else {
    cat(paste("None of the mutated genes demonstrated significant q-value in dataset", datasets.list[i], "\n\n\n\n", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

#### Significant cancer genes {.tabset}

##### dNdScv

*P-values* for substitutions are obtained by *likelihood-ratio tests* as described in [Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"} and *q-values* are obtained by *Benjamini-Hodgberg’s multiple testing correction*. The table(s) also include information on the number of substitutions of each class observed in each gene, as well as *maximum-likelihood estimates* (*MLEs*) of the *dN/dS ratios* for each gene, for **missense** (*wmis*), **nonsense** (*wnon*), essential **splice site** mutations (*wspl*) and **indels** (*wind*). The *global q-values* integrating all mutation types are available in the ***qglobal_cv*** and *qallsubs_cv* columns for analyses with and without indels, respectively.

```{r dndscv_results_summary, comment = NA, message=FALSE, warning=FALSE}
##### Present dndscv results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  if ( params$ratios_ci) {
    
    widges.list[[i]] <- DT::datatable( data = signif_genes_cv[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_cv[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
          DT::formatStyle( columns = names(signif_genes_cv[[i]]), 'text-align' = 'center' ) %>%
    formatRound(columns = c("wmis_cv","wnon_cv", "wspl_cv", "wind_cv", "mis_mle", "tru_mle", "mis_low", "tru_low", "mis_high", "tru_high"), 1) %>%
    formatRound(columns = c("pglobal_cv", "qglobal_cv", "pmis_cv", "ptrunc_cv", "pallsubs_cv", "pind_cv", "qmis_cv", "qtrunc_cv", "qallsubs_cv", "pglobal_cv", "qglobal_cv"), 6)
    
  } else {
    
    widges.list[[i]] <- DT::datatable( data = signif_genes_cv[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_cv[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
          DT::formatStyle( columns = names(signif_genes_cv[[i]]), 'text-align' = 'center' ) %>%
    formatRound(columns = c("wmis_cv", "wnon_cv", "wspl_cv", "wind_cv"), 1) %>%
    formatRound(columns = c("pglobal_cv", "qglobal_cv", "pmis_cv", "qmis_cv", "ptrunc_cv", "qtrunc_cv", "pallsubs_cv", "qallsubs_cv", "pind_cv"), 6)
  }
}

##### Print a list of htmlwidgets
widges.list
```

<details>
<summary>Table legend</summary>
<font size="2">

* **syn** - synonymous mutations
* **mis** - missense mutations
* **non** - nonsense mutations
* **spl** - splice site mutations
* **trunc** - all truncating mutations together (including nonsense and splice site mutations)
* **ind** - indels
* **allsubs** - all mutation types without indels
* **global** - all mutation types including indels
</font> 
</details>

***

##### dNdSloc

*P-values* are obtained from per-gene neutrality tests performed using *traditional dN/dS model*, in which the local mutation rate for a gene is estimated exclusively from the synonymous mutations observed in individual genes ([Wong *et al*., 2014](https://www.ncbi.nlm.nih.gov/pubmed/24316979){target="_blank"}). *Q-values* are obtained by *Benjamini-Hodgberg’s multiple testing correction*. The table(s) also include information on the number of substitutions of each class observed in each gene, as well as *maximum-likelihood estimates* (*MLEs*) of the *dN/dS ratios* for each gene, for **missense** (*wmis*), **nonsense** (*wnon*) and essential **splice site** mutations (*wspl*). The *q-values* integrating all mutation types are available in the ***qall_loc*** column.

```{r dndsloc_results_summary, comment = NA, message=FALSE, warning=FALSE}
##### Present dndscv results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = signif_genes_loc[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_loc[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
        DT::formatStyle( columns = names(signif_genes_loc[[i]]), 'text-align' = 'center' ) %>%
  formatRound(columns = c("wmis_loc", "wnon_loc", "wspl_loc"), 1) %>%
  formatRound(columns = c("pall_loc", "qall_loc", "pmis_loc", "qmis_loc"), 6)
}

##### Print a list of htmlwidgets
widges.list
```

<details>
<summary>Table legend</summary>
<font size="2">

* **syn** - synonymous mutations
* **mis** - missense mutations
* **non** - nonsense mutations
* **spl** - splice site mutations
* **all** - all mutation types
</font> 
</details>

***

#### Global dN/dS estimates

Table(s) presenting global *maximum-likelihood estimates* (*MLEs*) for the *dN/dS ratios* across all genes. dN/dS ratios with associated confidence intervals are calculated for **missense** (*wmis*), **nonsense** (*wnon*) and essential **splice site** substitutions (*wspl*) separately, as well as for **all non-synonymous** substitutions (*wall*) and for **all truncating** substitutions together (*wtru*), which include nonsense and essential splice site mutations.

<details>
<summary>What global dN/dS ratios indicate?</summary>
Global dN/dS ratios in somatic evolution of cancer, and seemingly of healthy somatic tissues, appear to show a near-universal pattern of **dN/dS ~1**, with exome-wide dN/dS ratios typically slightly higher than 1 ([Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"}). The global **dN/dS < 1** is typically caused by contamination of the catalogue of somatic mutations with germline SNPs. An exception are melanoma tumours, which show a bias towards slight underestimation of dN/dS due to the signature of ultraviolet-induced mutations extending beyond the trinucleotide model. The global **dN/dS << 1** reflects a problem of SNP contamination or an inadequate substitution model, and so the evaluation of global dN/dS values can help identify problems in certain datasets.
</details>

```{r global_dnds_estimates, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = globaldnds[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(globaldnds[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
        DT::formatStyle( columns = names(globaldnds[[i]]), 'text-align' = 'center' ) %>%
    formatRound(columns = c("mle", "cilow", "cihigh"), 1) 
}

##### Print a list of htmlwidgets
widges.list
```

<details>
<summary>Table legend</summary>
<font size="2">

* **wmis** - global dN/dS ratios for missense mutations
* **wnon** - global dN/dS ratios for nonsense mutations
* **wspl** - global dN/dS ratios for splice site mutations
* **wtru** - global dN/dS ratios for all truncating mutations together (including nonsense and splice site mutations)
* **wall** - global dN/dS ratios for all non-synonymous mutation types
</font> 
</details>

***
#### Subsampled mutations

Table(s) listing coding mutations within genes with > `r params$max_muts_per_gene` mutations per gene in same sample. These have been removed from the analysis to protect against loss of sensitivity from clustered artefacts.

```{r subsampled_mutations, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = exclmuts[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(exclmuts[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
        DT::formatStyle( columns = names(exclmuts[[i]]), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveClust {.tabset}

Cancer driver genes detection based on positional clustering using [OncodriveClust](http://bg.upf.edu/group/projects/oncodrive-clust.php){target="_blank"} algorithm is based on the fact that most of the variants in cancer causing genes are enriched at few specific loci (hot-spots). According to this concept mutations in these regions potentially change the function of these proteins in a manner that provides an adaptive advantage to cancer cells and consequently are positively selected during clonal evolution of tumours. This property can thus be used to nominate novel candidate driver genes, as described in the paper [OncodriveClust](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"} by [Tamborero *et al*, 2013](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"}.

***

**NOTE**: this analysis uses **only non-synonymous variants** defined as variants with the following consequences: *`r params$nonSyn_list`*.

<details>
<summary>Variants consequence impact definitions</summary>
<font size="2">

* [*High impact variant consequence*](http://asia.ensembl.org/Help/Glossary?id=535){target="_blank"} -	the variant is assumed to have high (disruptive) impact in the protein, probably causing protein truncation, loss of function or triggering nonsense mediated decay.

* [*Moderate impact variant consequence*](http://asia.ensembl.org/Help/Glossary?id=535){target="_blank"} -	a non-disruptive variant that might change protein effectiveness.

* [*Low impact variant consequence*](http://asia.ensembl.org/Help/Glossary?id=535){target="_blank"} -	a variant that is assumed to be mostly harmless or unlikely to change protein behaviour.

Variants with high/moderate variant consequences include: *frame shift deletions*, *frame shift deletions*, *splice site mutations*, *translation start site mutations*, *nonsense mutation*, *nonstop mutations*, *in-frame deletion*, *in-frame insertions* and *missense mutation*.

</font> 
</details>

***

#### Plot

The *size* of the points on the scatter-plot(s) is proportional to the *number of clusters* found in individual genes. *X-axis* indicates the *number of variants* observed in these clusters and *y-axis* illustrates *false discovery rate* (FDR) values in -log10 scale. The *colour* scale reflects *cluster scores*, with yellow and purple indicating high and low values, respectively. Cluster score of 1 means that a single hotspot hosts all observed variants.

```{r oncodriveCLUST_plot, comment = NA, message=FALSE, warning=FALSE}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  if ( !is.null(oncodriveClust.res[[datasets.list[i]]]) ) {
    
    if ( nrow(oncodriveClust.res[[datasets.list[i]]][[1]]) > 0 ) {
      
      ##### Avoid q-values of 0 by assigning 1*10^-16 to extremely low q-values
      oncodriveClust.res.table <- oncodriveClust.res[[datasets.list[i]]][[1]]
      fdr <- oncodriveClust.res.table$fdr
      fdr[ fdr == 0 ] <- 1*10^-16
      
      ##### Prepare data frame for plotting with plotly
      data.df <- data.frame(oncodriveClust.res.table$Hugo_Symbol, fdr, oncodriveClust.res.table$muts_in_clusters, oncodriveClust.res.table$clusterScores, oncodriveClust.res.table$clusters )
      colnames(data.df) <- c("gene", "fdr", "mutations_no", "clusterScores", "clusters")
      
      ##### Calculate x and y axis rangeby adding 10% of the original range
      x_range <- c(0, max(data.df$mutations_no) + max(data.df$mutations_no)*0.1)
      y_range <- c(0, max(-log(data.df$fdr,10)) + max(-log(data.df$fdr,10))*0.1)
      
      ##### Generate scatter-plot
      p <- plot_ly(data.df, x = ~mutations_no, y = -log(data.df$fdr,10), color = data.df$clusterScores, size = data.df$clusters, text= ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
        add_text(textfont = list(size = 10), textposition = "top") %>%
        layout(title = datasets.list[i], xaxis = list(title = "Number of mutations in clusters", range = x_range), yaxis = list(title = "-log10( FDR )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = TRUE, legend = list(orientation = "v", y = 0.9))
    
      ##### Add plot to the list for htmlwidgets
      widges.list[[i]] <- as_widget(ggplotly(p))
      
      ##### Save the plot as html (PLOTLY)
      htmlwidgets::saveWidget(as_widget(p), paste0(outDir, "/driver_analysis_oncodriveCLUST_plot_", datasets.list[i], ".html"), selfcontained = TRUE)
    
    } else {
      cat(paste("None of the mutated genes demonstrated significant cluster score in dataset", datasets.list[i], "\n\n\n\n", sep=" "))
    }
  } else {
      cat(paste("It was not possible to calculate cluster scores for dataset", datasets.list[i], "\n\n\n\n", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

#### Significant cancer genes

Table(s) presenting per-dataset [OncodriveClust](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"} results, including *cluster scores*, *p-values*, *false discovery rate (FDR) values*, *number of mutations in clusters*, as well as the *fraction of mutations in clusters*. Cluster score of 1 means that a single hotspot hosts all observed variants.

```{r oncodriveCLUST_table, comment=NA, warning=FALSE}
##### Generate tables with oncodriveCLUST results
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  if ( !is.null(oncodriveClust.res[[datasets.list[i]]]) ) {
      
    widges.list[[i]] <- DT::datatable(data = oncodriveClust.res[[datasets.list[i]]][[1]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
      DT::formatStyle( columns = names(oncodriveClust.res[[datasets.list[i]]][[1]]), 'text-align' = 'center' ) %>%
  formatRound(columns = c("clusterScores", "zscore", "fract_muts_in_clusters"), 1) %>%
  formatRound(columns = c("pval", "fdr"), 6)
  
  } else {
    cat(paste("It was not possible to calculate cluster scores for dataset", datasets.list[i], "\n\n\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveFML {.tabset}

[OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} is a method designed to analyse the pattern of somatic mutations across tumours in both **coding and non-coding genomic regions** to identify signals of positive selection, and therefore, their involvement in tumorigenesis. The identification of protein coding genes, promoters, untranslated regions, intronic splice regions, and lncRNAs-containing driver mutations in several malignancies using [OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} is described by [Mularoni et al., 2016](https://www.ncbi.nlm.nih.gov/pubmed/27311963){target="_blank"}.

[OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} results are **`r if ( runOncodrivefmlChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

`r if ( runOncodrivefmlChunk ) { c(paste0("The p- and q-values used for calling driver genes were set to ", params$oncodrivefml_p, " and ", params$oncodrivefml_q, ", respectively.")) } else { c(" ") }`

<details>
<summary>OncodriveFML settings</summary>
<font size="2">

`r if ( !is.null(oncodrivefml.conf) ) { c(gsub("],", "]: ", paste0(unlist(oncodrivefml.conf), collapse = ", "), perl = TRUE)) } else { c("OncodriveFML configuration file is not available.") }`
</font> 
</details>

#### Plot

[Q-Q plot](https://en.wikipedia.org/wiki/Q%E2%80%93Q_plot){target="_blank"} with *y-axis* presenting -log10 of the *computed p-values* and *x-axis* the -log10 of the *expected p-values*. The genomic elements that have a lighter colour are the ones for which the number of mutated samples does not reach the minimum required to perform multiple test correction. All genomic regions above the red line are annotated and represent those with *Q-value* below *0.1*. The ones between the green line and the red line are the ones with a *Q-value* between *0.25* and *0.1*.
 
```{r oncodriveFML_plot_static, comment = NA, message=FALSE, warning=FALSE, results="asis", eval=runOncodrivefmlChunk}
for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the OncodriveFML results plot (HTML) exists
  if ( file.exists(paste0(oncodriveFML.res[i], ".png")) ) {
    
    ##### Read in the oncodriveFML PNG files
    cat(paste("\n\n <b>", datasets.list[i], "</b> \n\n", sep=" "))
    cat("![](",paste(paste0(oncodriveFML.res[i], ".png")),")")
    cat("<br/><br/><br/>")

    ##### Copy the OncodriveFML results plot (HTML and PNG) to the report folder
    file.copy(paste0(oncodriveFML.res[i], ".png"), paste0(outDir, "/driver_analysis_OncodriveFML_plot_", datasets.list[i], ".png"), overwrite = TRUE, copy.mode = TRUE, copy.date = FALSE)
    file.copy(paste0(oncodriveFML.res[i], ".html"), paste0(outDir, "/driver_analysis_OncodriveFML_plot_", datasets.list[i], ".html"), overwrite = TRUE, copy.mode = TRUE, copy.date = FALSE)
    
  } else {
    cat(paste("OncodriveFML results plot \"", paste0(oncodriveFML.res[i], ".png"), "\" is not present for dataset", datasets.list[i], "\n\n\n\n", sep=" "))
  }
}
```

***

#### Significant cancer genes

Table(s) presenting per-dataset [OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} results, including *p-values*, *q-values*, as well as the *number of mutations* that are *SNPs*, multi nucleotide polymorphisms (*MNPs*) and insertions or deletions (*INDELS*).

```{r oncodriveFML_table, comment=NA, warning=FALSE, eval=runOncodrivefmlChunk}
##### Generate tables with oncodriveFML results
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the OncodriveFML results plot (HTML) exists
  if ( file.exists(paste0(oncodriveFML.res[i], ".html")) ) {
    
    widges.list[[i]] <- DT::datatable(data = oncodriveFML.res.table.signif[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
      DT::formatStyle( columns = names(oncodriveFML.res.table[[i]]), 'text-align' = 'center' ) %>%
  formatRound(columns = c("P_VALUE", "Q_VALUE", "P_VALUE_NEG", "Q_VALUE_NEG"), 6)
  
  } else {
    cat(paste("OncodriveFML results table \"", paste0(oncodriveFML.res[i], ".tsv"), "\" is not present for dataset", datasets.list[i], "\n\n\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

<details>
<summary>Table legend</summary>
<font size="2">

* **MUTS** - number of mutations found in the dataset for that gene
* **MUTS_RECURRENCE** - number of mutations that do not occur in the same position
* **SAMPLES** - number of mutated samples in the gene
* **P_VALUE** - times that the observed value is higher than or equal to the expected value, divided by the number of randomizations
* **Q_VALUE** - *P_VALUE* corrected using the *Benjamini-Hochberg* correction (for samples with at least 2 samples)
* **P_VALUE_NEG** - times that the observed value is lower than or equal to the expected value, divided by the number of randomizations
* **Q_VALUE_NEG** - *P_VALUE_NEG* corrected using the *Benjamini-Hochberg* correction (for samples with at least 2 samples)
</font> 
</details>

***

### MutSig {.tabset}

... work in progress

[MutSig](http://software.broadinstitute.org/cancer/cga/mutsig){target="_blank"} (see paper by [Lawrence et al., 2013](https://www.ncbi.nlm.nih.gov/pubmed/23770567){target="_blank"} for details)

***

### Cancer Genome Interpreter {.tabset}

... work in progress

[Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/rest_api){target="_blank"} (CGI) (see paper by [Tamborero et al., 2018](https://www.ncbi.nlm.nih.gov/pubmed/29592813){target="_blank"} for details)

***

### CHASMplus {.tabset}

... work in progress

[CHASMplus](https://github.com/KarchinLab/CHASMplus){target="_blank"} (see paper by [Tokheim and Karchin., preprint](https://www.biorxiv.org/content/10.1101/313296v4){target="_blank"} for details)

***

### Hierarchical HotNet {.tabset}

[Hierarchical HotNet](https://github.com/raphael-group/hierarchical-hotnet){target="_blank"} (see paper by [Reyna et al., 2015](https://www.ncbi.nlm.nih.gov/pubmed/30423088){target="_blank"} for details) is an improved version of [HotNet2](https://github.com/raphael-group/hotnet2).

... work in progress

***

## Mutation maps {.tabset .tabset-fade}

Lollipop plot(s) showing mutation spots on protein structure for the top **10 driver genes** detected by the following methods: **`r paste(names(signif_genes.datasets[[i]]), collapse = ", ")`**. Many oncogenes have a preferential sites which are mutated more often than any other locus. These spots are considered to be mutational hot-spots and lollipop plots can be used to display them along with rest of the mutations. Note, that lollipop plot(s) are generated for MAF files containing field with amino acid changes details. The longest transcript is used if multiple transcripts are available.

```{r prot_structre, comment = NA, message=FALSE, warning=FALSE}
##### Get list of proteins for which structure is available within maftools
gff = system.file('extdata', 'protein_domains.RDs', package = 'maftools')
gff = readRDS(file = gff)
```

### dNdScv {.tabset}
 
#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdScv))[1]) ) { verify_genes(unlist(signif_genes.methods$dNdScv))[1] }`

```{r lollipop_plot_dNdScv_1, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
###### Generate lollipop plot

##### Create directory for pdf files
mutationMapsDir <- paste0(normalizePath(outDir), "/", "MAF_mutation_maps")

if ( !file.exists(mutationMapsDir) ){
  dir.create(mutationMapsDir, recursive=TRUE)
}

if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdScv))[1]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdScv))[1]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdScv))[1], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdScv))[2]) ) { verify_genes(unlist(signif_genes.methods$dNdScv))[2] }`

```{r lollipop_plot_dNdScv_2, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdScv))[2]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdScv))[2]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdScv))[2], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdScv))[3]) ) { verify_genes(unlist(signif_genes.methods$dNdScv))[3] }`

```{r lollipop_plot_dNdScv_3, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdScv))[3]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdScv))[3]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdScv))[3], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdScv))[4]) ) { verify_genes(unlist(signif_genes.methods$dNdScv))[4] }`

```{r lollipop_plot_dNdScv_4, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdScv))[4]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdScv))[4]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdScv))[4], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdScv))[5]) ) { verify_genes(unlist(signif_genes.methods$dNdScv))[5] }`

```{r lollipop_plot_dNdScv_5, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdScv))[5]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdScv))[5]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdScv))[5], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdScv))[6]) ) { verify_genes(unlist(signif_genes.methods$dNdScv))[6] }`

```{r lollipop_plot_dNdScv_6, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdScv))[6]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdScv))[6]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdScv))[6], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdScv))[7]) ) { verify_genes(unlist(signif_genes.methods$dNdScv))[7] }`

```{r lollipop_plot_dNdScv_7, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdScv))[7]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdScv))[7]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdScv))[7], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdScv))[8]) ) { verify_genes(unlist(signif_genes.methods$dNdScv))[8] }`

```{r lollipop_plot_dNdScv_8, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdScv))[8]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdScv))[8]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdScv))[8], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdScv))[9]) ) { verify_genes(unlist(signif_genes.methods$dNdScv))[9] }`

```{r lollipop_plot_dNdScv_9, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdScv))[9]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdScv))[9]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdScv))[9], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdScv))[10]) ) { verify_genes(unlist(signif_genes.methods$dNdScv))[10] }`

```{r lollipop_plot_dNdScv_10, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdScv))[10]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdScv))[10]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdScv))[10], "is not available\n\n\n\n", sep=" "))
}
```

***

### dNdSloc {.tabset}

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdSloc))[1]) ) { verify_genes(unlist(signif_genes.methods$dNdSloc))[1] }`

```{r lollipop_plot_dNdSloc_1, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdSloc))[1]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdSloc))[1]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdSloc))[1], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdSloc))[2]) ) { verify_genes(unlist(signif_genes.methods$dNdSloc))[2] }`

```{r lollipop_plot_dNdSloc_2, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdSloc))[2]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdSloc))[2]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdSloc))[2], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdSloc))[3]) ) { verify_genes(unlist(signif_genes.methods$dNdSloc))[3] }`

```{r lollipop_plot_dNdSloc_3, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdSloc))[3]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdSloc))[3]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdSloc))[3], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdSloc))[4]) ) { verify_genes(unlist(signif_genes.methods$dNdSloc))[4] }`

```{r lollipop_plot_dNdSloc_4, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdSloc))[4]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdSloc))[4]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdSloc))[4], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdSloc))[5]) ) { verify_genes(unlist(signif_genes.methods$dNdSloc))[5] }`

```{r lollipop_plot_dNdSloc_5, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdSloc))[5]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdSloc))[5]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdSloc))[5], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdSloc))[6]) ) { verify_genes(unlist(signif_genes.methods$dNdSloc))[6] }`

```{r lollipop_plot_dNdSloc_6, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdSloc))[6]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdSloc))[6]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdSloc))[6], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdSloc))[7]) ) { verify_genes(unlist(signif_genes.methods$dNdSloc))[7] }`

```{r lollipop_plot_dNdSloc_7, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdSloc))[7]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdSloc))[7]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdSloc))[7], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdSloc))[8]) ) { verify_genes(unlist(signif_genes.methods$dNdSloc))[8] }`

```{r lollipop_plot_dNdSloc_8, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdSloc))[8]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdSloc))[8]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdSloc))[8], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdSloc))[9]) ) { verify_genes(unlist(signif_genes.methods$dNdSloc))[9] }`

```{r lollipop_plot_dNdSloc_9, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdSloc))[9]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdSloc))[9]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdSloc))[9], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$dNdSloc))[10]) ) { verify_genes(unlist(signif_genes.methods$dNdSloc))[10] }`

```{r lollipop_plot_dNdSloc_10, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$dNdSloc))[10]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$dNdSloc))[10]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$dNdSloc))[10], "is not available\n\n\n\n", sep=" "))
}
```

***

### OncodriveCLUST {.tabset}

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[1]) ) { verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[1] }`

```{r lollipop_plot_OncodriveCLUST_1, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[1]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[1]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[1], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[2]) ) { verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[2] }`

```{r lollipop_plot_OncodriveCLUST_2, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[2]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[2]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[2], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[3]) ) { verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[3] }`

```{r lollipop_plot_OncodriveCLUST_3, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[3]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[3]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[3], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[4]) ) { verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[4] }`

```{r lollipop_plot_OncodriveCLUST_4, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[4]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[4]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[4], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[5]) ) { verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[5] }`

```{r lollipop_plot_OncodriveCLUST_5, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[5]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[5]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[5], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[6]) ) { verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[6] }`

```{r lollipop_plot_OncodriveCLUST_6, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[6]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[6]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[6], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[7]) ) { verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[7] }`

```{r lollipop_plot_OncodriveCLUST_7, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[7]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[7]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[7], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[8]) ) { verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[8] }`

```{r lollipop_plot_OncodriveCLUST_8, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[8]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[8]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[8], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[9]) ) { verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[9] }`

```{r lollipop_plot_OncodriveCLUST_9, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[9]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[9]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[9], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[10]) ) { verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[10] }`

```{r lollipop_plot_OncodriveCLUST_10, comment = NA, message=FALSE, warning=FALSE, results = "asis"}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[10]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[10]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveCLUST))[10], "is not available\n\n\n\n", sep=" "))
}
```

***

### OncodriveFML {.tabset}

**`r if ( runOncodrivefmlChunk ) { c(" ") } else { c("OncodriveFML results are NOT AVAILABLE.") }`**

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveFML))[1]) ) { verify_genes(unlist(signif_genes.methods$OncodriveFML))[1] }`

```{r lollipop_plot_OncodriveFML_1, comment = NA, message=FALSE, warning=FALSE, results = "asis", eval=runOncodrivefmlChunk}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveFML))[1]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveFML))[1]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveFML))[1], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveFML))[2]) ) { verify_genes(unlist(signif_genes.methods$OncodriveFML))[2] }`

```{r lollipop_plot_OncodriveFML_2, comment = NA, message=FALSE, warning=FALSE, results = "asis", eval=runOncodrivefmlChunk}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveFML))[2]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveFML))[2]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveFML))[2], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveFML))[3]) ) { verify_genes(unlist(signif_genes.methods$OncodriveFML))[3] }`

```{r lollipop_plot_OncodriveFML_3, comment = NA, message=FALSE, warning=FALSE, results = "asis", eval=runOncodrivefmlChunk}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveFML))[3]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveFML))[3]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveFML))[3], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveFML))[4]) ) { verify_genes(unlist(signif_genes.methods$OncodriveFML))[4] }`

```{r lollipop_plot_OncodriveFML_4, comment = NA, message=FALSE, warning=FALSE, results = "asis", eval=runOncodrivefmlChunk}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveFML))[4]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveFML))[4]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveFML))[4], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveFML))[5]) ) { verify_genes(unlist(signif_genes.methods$OncodriveFML))[5] }`

```{r lollipop_plot_OncodriveFML_5, comment = NA, message=FALSE, warning=FALSE, results = "asis", eval=runOncodrivefmlChunk}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveFML))[5]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveFML))[5]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveFML))[5], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveFML))[6]) ) { verify_genes(unlist(signif_genes.methods$OncodriveFML))[6] }`

```{r lollipop_plot_OncodriveFML_6, comment = NA, message=FALSE, warning=FALSE, results = "asis", eval=runOncodrivefmlChunk}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveFML))[6]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveFML))[6]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveFML))[6], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveFML))[7]) ) { verify_genes(unlist(signif_genes.methods$OncodriveFML))[7] }`

```{r lollipop_plot_OncodriveFML_7, comment = NA, message=FALSE, warning=FALSE, results = "asis", eval=runOncodrivefmlChunk}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveFML))[7]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveFML))[7]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveFML))[7], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveFML))[8]) ) { verify_genes(unlist(signif_genes.methods$OncodriveFML))[8] }`

```{r lollipop_plot_OncodriveFML_8, comment = NA, message=FALSE, warning=FALSE, results = "asis", eval=runOncodrivefmlChunk}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveFML))[8]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveFML))[8]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveFML))[8], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveFML))[9]) ) { verify_genes(unlist(signif_genes.methods$OncodriveFML))[9] }`

```{r lollipop_plot_OncodriveFML_9, comment = NA, message=FALSE, warning=FALSE, results = "asis", eval=runOncodrivefmlChunk}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveFML))[9]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveFML))[9]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveFML))[9], "is not available\n\n\n\n", sep=" "))
}
```

***

#### `r if ( !is.na(verify_genes(unlist(signif_genes.methods$OncodriveFML))[10]) ) { verify_genes(unlist(signif_genes.methods$OncodriveFML))[10] }`

```{r lollipop_plot_OncodriveFML_10, comment = NA, message=FALSE, warning=FALSE, results = "asis", eval=runOncodrivefmlChunk}
if ( nrow(gff[HGNC %in% verify_genes(unlist(signif_genes.methods$OncodriveFML))[10]]) != 0 ) {
  try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = verify_genes(unlist(signif_genes.methods$OncodriveFML))[10]), silent = TRUE)
} else {
   cat(paste("The protein structure for protein encoded by", verify_genes(unlist(signif_genes.methods$OncodriveFML))[10], "is not available\n\n\n\n", sep=" "))
}
```

***

## Mutations annotation {.tabset}

Table(s) with detailed annotation of coding mutations (detected by the following methods: **`r paste(names(signif_genes.datasets[[i]]), collapse = ", ")`**) in affected samples.

### dNdScv

```{r mutations_annotation_dNdScv, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$dNdScv[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### dNdSloc

```{r mutations_annotation_dNdSloc, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$dNdSloc[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveCLUST

```{r mutations_annotation_OncodriveCLUST, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$OncodriveCLUST[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveFML {.tabset}

**`r if ( runOncodrivefmlChunk ) { c(" ") } else { c("OncodriveFML results are NOT AVAILABLE.") }`**

```{r mutations_annotation_OncodriveFML, comment = NA, message=FALSE, warning=FALSE, eval=runOncodrivefmlChunk}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$OncodriveFML[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE) ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

## Summary {.tabset}

### Per-gene summary table

Table presenting cancer driver genes (rows) detected by the following methods (*columns*): **`r paste(names(signif_genes.datasets[[i]]), collapse = ", ")`**.

```{r driver_genes_summary_table, comment = NA, message=FALSE, warning=FALSE}
##### Presnet the intersections between cancer driver genes detected by various methods
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  if ( length(signif_genes[[i]]) > 0 ) {
    
    ##### Generate a table
    widges.list[[i]] <- DT::datatable( data = signif_genes.upset.mod[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", rownames = TRUE, extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 1), deferRender = TRUE, scrollY = 200, scroller = TRUE)) %>%
      DT::formatStyle( columns = colnames(signif_genes.upset.mod[[i]]), `font-size` = '12px', 'text-align' = 'center' ) %>%
      
      ##### Colour cells according to evidence level and trust rating
      DT::formatStyle(columns = colnames(signif_genes.upset.mod[[i]])[-c(length(signif_genes.upset.mod[[i]]))], 
                      backgroundColor = DT::styleEqual(c("No", "Yes"), c("transparent", "black")), color = DT::styleEqual(c("No", "Yes"), c("black", "white")))
    
  } else {
    cat(paste("None cancer driver gene have been detected by either method in dataset", datasets.list[i], "\n\n\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

### Per-method summary plot

Plot(s) illustrating the intersections of driver analysis results between the following methods: **`r paste(names(signif_genes.datasets[[i]]), collapse = ", ")`**.

```{r driver_genes_summary_plot, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Present the intersections between cancer driver genes detected by various methods
for ( i in 1:length(mafFiles) ) {
  
  if ( length(signif_genes[[i]]) > 0 ) {
    
    cat(paste("\n\n <b>", datasets.list[i], "</b> \n\n", sep=" "))
    
    ##### Generate the upset plot to illustrate the overlap between individual methods
    upset(as.data.frame(t(signif_genes.upset[[i]])), sets = colnames(t(signif_genes.upset[[i]])), sets.bar.color = "#56B4E9", order.by = "freq", empty.intersections = "on", sets.x.label = "Total genes no.", mb.ratio = c(0.5, 0.5))
    
    
  } else {
    cat(paste("None cancer driver gene have been detected by either method in dataset", datasets.list[i], "\n\n\n\n", sep=" "))
  }
}
```

***

## Addendum

<details>
<summary>Parameters</summary>
<font size="2">

```{r params_info, comment = NA}
for ( i in 1:length(params) ) {

  cat(paste("Parameter: ", names(params)[i], "\nValue: ", paste(unlist(params[i]), collapse = ","), "\n\n", sep=""))
}
```

</font>
</details>

<details>
<summary>Session info</summary>
<font size="2">

```{r sessioninfo, comment = NA}
devtools::session_info()
```

</font>
</details>
