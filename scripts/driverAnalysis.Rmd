---
title: "Driver analyses summary"
author: "UMCCR"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: readable
    css: driverAnalysis.css
    toc: true
    toc_float: true
    code_folding: hide
  rmdformats::material:
    highlight: kate
params:
  maf_dir: 
  maf_files: 
  datasets: 
  samples_id_cols: 'Tumor_Sample_Barcode'
  dnds_p: 0.05
  dnds_q: 1
  activedriverwgs_p: 0.05
  activedriverwgs_fdr: 1
  activedriverwgs_cores: 1
  activedriverwgs_all_genes: FALSE
  oncodriveclust_fdr: 0.5
  ratios_ci: FALSE
  hypermut_sample_cutoff: 200
  max_muts_per_gene: 3
  genes_list: 'none'
  genes_blacklist: 'none'
  samples_blacklist: 'none'
  nonSyn_list: 'Frame_Shift_Del,Frame_Shift_Ins,Splice_Site,Translation_Start_Site,Nonsense_Mutation,Nonstop_Mutation,In_Frame_Del,In_Frame_Ins,Missense_Mutation'
  oncodrivefml: 'none'
  oncodrivefml_p: 0.01
  oncodrivefml_q: 0.1
  oncodrivefml_conf: 'none'
  cgi: 'none'
  clinical_info: 'none'
  remove_duplicated_variants: TRUE
  hide_code_btn: TRUE
  out_folder: 'Driver_analysis_report'
  ucsc_genome_assembly: 19
  ensembl_version: 75
  refdb_38: '../data/RefCDS_human_GRCh38.p12.rda'
  cancer_genes: '../data/umccr_cancer_genes.2019-03-20.tsv'
---

Selection analyses and cancer driver discovery results for dataset(s) **`r gsub(",", ", ", params$datasets) `** using the following methods:

* **[dNdScv](https://github.com/im3sanger/dndscv){target="_blank"}** (see paper by [Martincorena *et al*., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"} for details)
* **[ActiveDriverWGS](https://github.com/reimandlab/ActiveDriverWGSR){target="_blank"}** (see paper by [Zhu *et al*., 2020](https://pubmed.ncbi.nlm.nih.gov/31954095){target="_blank"} for details)
* **[OncodriveClust](https://bioconductor.org/packages/release/bioc/vignettes/maftools/inst/doc/maftools.html#92_detecting_cancer_driver_genes_based_on_positional_clustering){target="_blank"}** (see paper by [Tamborero *et al*., 2013](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"} for details)
* **[OncodriveFML](https://bitbucket.org/bbglab/oncodrivefml.git){target="_blank"}** (see paper by [Mularoni *et al*., 2016](https://www.ncbi.nlm.nih.gov/pubmed/27311963){target="_blank"} for details)
* **[Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/rest_api){target="_blank"}** (CGI) (see paper by [Tamborero *et al*., 2018](https://www.ncbi.nlm.nih.gov/pubmed/29592813){target="_blank"} for details)

***

<details>
<summary>Input parameters</summary>
<font size="2">

* **maf_dir**: `r params$maf_dir`
* **maf_files**: `r params$maf_files`
* **datasets**: `r params$datasets`
* **samples_id_cols**: `r params$samples_id_cols`
* **dnds_p**: `r params$dnds_p`
* **dnds_q**: `r params$dnds_q`
* **activedriverwgs_p**: `r params$activedriverwgs_p`
* **activedriverwgs_fdr**: `r params$activedriverwgs_fdr`
* **activedriverwgs_cores**: `r params$activedriverwgs_cores`
* **activedriverwgs_all_genes**: `r params$activedriverwgs_all_genes`
* **oncodriveclust_fdr**: `r params$oncodriveclust_fdr`
* **ratios_ci**: `r params$ratios_ci`
* **hypermut_sample_cutoff**: `r params$hypermut_sample_cutoff`
* **max_muts_per_gene**: `r params$max_muts_per_gene`
* **genes_list**: `r params$genes_list`
* **genes_blacklist**: `r params$genes_blacklist`
* **samples_blacklist**: `r params$samples_blacklist`
* **nonSyn_list**: `r params$nonSyn_list`
* **oncodrivefml**: `r params$oncodrivefml`
* **oncodrivefml_p**: `r params$oncodrivefml_p`
* **oncodrivefml_q**: `r params$oncodrivefml_q`
* **oncodrivefml_conf**: `r params$oncodrivefml_conf`
* **cgi**: `r params$cgi`
* **clinical_info**: `r params$clinical_info`
* **remove_duplicated_variants**: `r params$remove_duplicated_variants`
* **hide_code_btn**: `r params$hide_code_btn`
* **out_folder**: `r params$out_folder`
* **ucsc_genome_assembly**: `r params$ucsc_genome_assembly`
* **ensembl_version**: `r params$ensembl_version`
* **refdb_38**: `r params$refdb_38`

</font> 
</details>

***

```{r code_display, echo = FALSE}
##### Include or exclude the "Code" buttom allowing to "show"/"hide" code chunks from the report
if ( params$hide_code_btn ) {
  writeLines(".btn { display: none ;", con = "driverAnalysis.css")
} else {
  writeLines(" ", con = "driverAnalysis.css")
}
```
 
```{r define_functions, comment=NA, message=FALSE, warning=FALSE}
##### Define functions

##### Create 'not in' operator
"%!in%" <- function(x,table) match(x,table, nomatch = 0) == 0

##### Verify gene names. Some driver analysis methods, like dNdScv, output specific gene variants (e.g. CDKN2A.p14arf and CDKN2A.p16INK4a) rather than genes. This function removes anything followed by '.'
verify_genes <- function(genes) {
  
  genes.verified = unique(str_replace(string = genes, pattern = "\\..*", replacement = ""))
  return( genes.verified )
}

##### Perfrom oncodrive analysis. Clusters variants based on their position to detect disease causing genes
oncodrive_analysis <- function(mafInfo, dataset, gl) {
  
  ##### Check if the amino acid changes information is available in MAF provided files. The script expects column called "HGVSp_Short", which is produced with vcf2maf (https://github.com/mskcc/vcf2maf) when converting VCFs to MAFs (https://github.com/cBioPortal/cbioportal/issues/2996) and describes a mutation's amino acid change. The "aa_mutation" field used for annotation in ICGC samples is also acceptable. NOTE: other possibilities are: "Protein_Change", "AAChange""
  pchange = c('HGVSp_Short', 'Protein_Change', 'AAChange')
      
  ##### Define the column with protein change info
  pchange = pchange[pchange %in% colnames(mafInfo@data)]
  
  ##### Check if the protein change field is not empty
  if ( any(!is.na(as.data.frame(mafInfo@data)[ , pchange  ]))  ) {
        
    ##### Check whether it's possible to run oncodrive analysis for given dataset by calculating cluster scores
    nonsyn.scores <- parse_prot(mafInfo, AACol = pchange, gl = gl, m = 5, calBg = FALSE, nBg = 100)
      
    if ( !is.null(nonsyn.scores) ) {
        
      ##### Cluster variants based on their position to detect disease causing genes
      sig = oncodrive(maf = mafInfo, AACol = pchange, minMut = 5, pvalMethod = 'zscore')
      
      plotOncodrive(res = sig, fdrCutOff = 0.05, useFraction = FALSE)
      oncodrive.plot <- recordPlot()
    } else {
      sig <- NULL
      oncodrive.plot <- NULL
    }
  } else {
    sig <- NULL
    oncodrive.plot <- NULL
  }
  return(list(sig, oncodrive.plot))
}

##### Functon to calcluate cluster score (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). It's required in order check whether it's possible to run oncodrive analysis for given dataset
parse_prot <- function(dat, AACol, gl, m, calBg = FALSE, nBg){

  mafInfo <- dat
  dat <- mafInfo@data
  
  if(is.null(AACol)){
    pchange = c('HGVSp_Short', 'Protein_Change', 'AAChange')
    if(pchange[pchange %in% colnames(dat)] > 0){
      pchange = suppressWarnings(pchange[pchange %in% colnames(dat)][1])
      message(paste0("Assuming protein change information are stored under column ", pchange,". Use argument AACol to override if necessary."))
      colnames(dat)[which(colnames(dat) == pchange)] = 'AAChange'
    }else{
      message('Available fields:')
      print(colnames(dat))
      stop('AAChange field not found in MAF. Use argument AACol to manually specifiy field name containing protein changes.')
    }
  }else{
    colnames(dat)[which(colnames(dat) == AACol)] = 'AAChange'
  }

  all.prot.dat = dat[,.(Hugo_Symbol, Variant_Classification, AAChange)]
  all.prot.dat = all.prot.dat[Variant_Classification != 'Splice_Site']
  #parse AAchanges to get postion
  prot.spl = strsplit(x = as.character(all.prot.dat$AAChange), split = '.', fixed = TRUE)
  prot.conv = sapply(sapply(prot.spl, function(x) x[length(x)]), '[', 1)

  all.prot.dat[,conv := prot.conv]
  all.prot.dat = all.prot.dat[!conv == 'NULL']

  #If conversions are in HGVSp_long (default HGVSp) format, we will remove strings Ter followed by anything (e.g; p.Asn1986GlnfsTer13)
  pos = gsub(pattern = 'Ter.*', replacement = '',x = all.prot.dat$conv)

  #Following parsing takes care of most of HGVSp_short and HGVSp_long format
  pos = gsub(pattern = '[[:alpha:]]', replacement = '', x = pos)
  pos = gsub(pattern = '\\*$', replacement = '', x = pos) #Remove * if nonsense mutation ends with *
  pos = gsub(pattern = '^\\*', replacement = '', x = pos) #Remove * if nonsense mutation starts with *
  pos = gsub(pattern = '\\*.*', replacement = '', x = pos) #Remove * followed by position e.g, p.C229Lfs*18

  pos = suppressWarnings( as.numeric(sapply(strsplit(x = pos, split = '_', fixed = TRUE), '[', 1)) )
  all.prot.dat[,pos := pos]

  all.prot.dat = all.prot.dat[!is.na(pos)] #Remove NA's

  gene.sum = mafInfo@gene.summary
  gene.sum = merge(x = gene.sum, y = gl, by = 'Hugo_Symbol', all.x = TRUE)
  gene.sum = gene.sum[!is.na(aa.length)]

  num_mut_colIndex = which(colnames(gene.sum) == 'total')
  aalen_colIndex = which(colnames(gene.sum) == 'aa.length')

  #Get background threshold
  gene.sum$th = apply(gene.sum, 1, function(x) get_threshold(gene_muts = as.numeric(x[num_mut_colIndex]), gene_length = as.numeric(x[aalen_colIndex])))
  #use only genes with atleast 2 (or m ) mutations.
  gene.sum = gene.sum[total >= m]

  if(calBg){
    if(nrow(gene.sum) < nBg){
      #message("Not enough genes to build background. Using predefined values. (Mean = 0.279; SD = 0.13)")
      return(NULL)
    } else{
      syn.res = c()
      pb <- txtProgressBar(min = 0, max = nrow(gene.sum), style = 3) #progress bar

      for(i in 1:nrow(gene.sum)){
        prot.dat = all.prot.dat[Hugo_Symbol %in% gene.sum[i, Hugo_Symbol]]
        syn.res = rbind(syn.res, cluster_prot(prot.dat = prot.dat, gene = gene.sum[i, Hugo_Symbol], th = gene.sum[i, th], protLen = gene.sum[i,aa.length]))
        setTxtProgressBar(pb, i)
      }
      return(syn.res)
    }
  } else{
    nonsyn.res = c()
    #pb <- txtProgressBar(min = 0, max = nrow(gene.sum), style = 3) #progress bar

    for(i in 1:nrow(gene.sum)){
      hs = gene.sum[i, Hugo_Symbol]
      #print(hs)
      prot.dat = all.prot.dat[Hugo_Symbol %in% hs]
      nonsyn.res = rbind(nonsyn.res, cluster_prot(prot.dat = prot.dat, gene = hs, th = gene.sum[Hugo_Symbol %in% hs, th], protLen = gene.sum[Hugo_Symbol %in% hs, aa.length]))
      #setTxtProgressBar(pb, i)
    }
    return(nonsyn.res)
  }
}

###### Estimate threshhold based on binaomial distribution (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). Required for parse_prot function
get_threshold <- function(gene_muts, gene_length){
  th = which(unlist(lapply(X = 2:gene_muts, FUN = function(x) dbinom(x = x, size = gene_muts, prob = 1/gene_length) )) < 0.01)[1]
  return(th+1)
}

###### Clustering function (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). Required for parse_prot function
cluster_prot <- function(prot.dat, gene, th, protLen){

  mergeDist = 5 #hard coded inter event distance.
  #prot.dat = all.prot.dat[Hugo_Symbol == gene]

  #Summarise counts per position
  pos.counts = prot.dat[,.N,pos]
  pos.counts = pos.counts[order(pos)]

  #classify position as meaningful if its greater than background threshhold.
  pos.counts$cluster = ifelse(test = pos.counts$N >= th, yes = 'meaningful', no = 'nonMeaningful')

  #Just choose meaningful positions
  clust.tbl = pos.counts[cluster %in% 'meaningful']
  nonclust.tbl = pos.counts[cluster %in% 'nonMeaningful']

  if(nrow(clust.tbl) == 0){
    #message(paste('No meaningful positions found for', gene, sep=' '))
    return(NULL)
  }

  clust.tbl$distance = c(0,diff(clust.tbl$pos)) #calculate inter event distance.

  #If more than one meaningful positions are found within a 5 aa distance, join them to form a cluster.
  if(nrow(clust.tbl) > 1){

    #initialize variables.
    cstart = end = clust.tbl[1,pos]
    n = clust.tbl[1,N]
    cdf = c()
    cluster = 1

    #Go through entire table and update variables.
    for(i in 2:nrow(clust.tbl)){
      pos = clust.tbl[i,pos]

      d = clust.tbl[i,distance]

      if(d < mergeDist){
        end = pos
        n = n + clust.tbl[i,N]
      }else{
        tempdf = data.frame(cluster = paste('cluster', cluster, sep='_'), start = cstart, end = end ,N = n)
        cdf = rbind(cdf, tempdf)
        cstart = end = pos
        n = clust.tbl[i,N]
        cluster = cluster + 1
      }
    }
    cdf = rbind(cdf, data.frame(cluster = paste('cluster', cluster, sep='_'), start = cstart, end = end ,N = n))
  } else {
    cdf = data.frame(cluster = 'cluster_1', start = clust.tbl$pos, end = clust.tbl$pos ,N = clust.tbl$N)
  }

  #merge adjacent variants to clusters.
  for(i in 1:nrow(cdf)){
    tempcdf = cdf[i,]
    nonclust.tbl$startDist = nonclust.tbl$pos - tempcdf$start
    nonclust.tbl$endDist = nonclust.tbl$pos - tempcdf$end

    merge.adj.to.start = nonclust.tbl[startDist >= -5 & startDist <= 0]
    if(nrow(merge.adj.to.start) > 0){
      tempcdf$start = merge.adj.to.start[which(merge.adj.to.start$startDist == min(merge.adj.to.start$startDist)),pos]
      tempcdf$N = tempcdf$N + sum(merge.adj.to.start$N)
    }

    merge.adj.to.end = nonclust.tbl[endDist <= 5 & endDist >= 0]
    if(nrow(merge.adj.to.end) > 0){
      tempcdf$end = merge.adj.to.end[which(merge.adj.to.end$endDist == max(merge.adj.to.end$endDist)),pos]
      tempcdf$N = tempcdf$N + sum(merge.adj.to.end$N)
    }
    cdf[i,] = tempcdf
  }
  cdf$Hugo_Symbol = gene

  #Calcluate cluster score.

  total.muts = nrow(prot.dat) #total variants for this gene.
  clusterScores = c()

  for(i in 1:nrow(cdf)){
    temp.prot.dat = prot.dat[pos >= as.numeric(cdf$start[i]) & pos <= as.numeric(cdf$end[i])]
    temp.prot.dat.summary = temp.prot.dat[,.N, pos]
    temp.prot.dat.summary[,fraction:= N/total.muts]

    peak = temp.prot.dat.summary[N == max(N), pos]

    posVector = as.numeric(temp.prot.dat.summary[,pos])
    fractionMutVector = unlist(lapply(posVector, FUN = function(x) temp.prot.dat.summary[pos == x, fraction]))
    distanceVector = suppressWarnings(abs(posVector - peak))

    clusterScores = c(clusterScores,  sum( fractionMutVector / (sqrt(2)^ distanceVector)))

  }

  cdf$clusterScore = clusterScores

  gene.clust.res = data.frame(Hugo_Symbol = gene, clusters = nrow(cdf), muts_in_clusters = sum(cdf$N), clusterScores = sum(cdf$clusterScore), protLen = protLen)
  return(gene.clust.res)
}

###### Generate dataTable for each dataset with all mutation information for selected gene(s), as provided in MAF files. User can filter variants to include only non-synonymous (defualt), silent or all variants
mut.details.datasets <- function(mafInfo, datasets, genes, type = "nonsynonymous") {
  
  ##### Vector with datasets with no mutations reported in selected genes
  datasets.noMut <- NULL
  
  ##### Create a list for htmlwidgets
  widges.list <- htmltools::tagList()
  
  for ( i in 1:length(datasets) ) {
    
    ##### Include all variants
    if ( type == "all" ) {
      
        mut.details.genes <- mafInfo[[datasets[i]]]@data[ mafInfo[[datasets[i]]]@data[, Hugo_Symbol] %in% genes, ]
        mut.details.genes <- rbind(mut.details.genes, mafInfo[[datasets[i]]]@maf.silent[ mafInfo[[datasets[i]]]@maf.silent[, Hugo_Symbol] %in% genes, ] )
        
    ##### Include silent variants
    } else if ( type == "silent" ) {
      
        mut.details.genes <- mafInfo[[datasets[i]]]@maf.silent[ mafInfo[[datasets[i]]]@maf.silent[, Hugo_Symbol] %in% genes, ]
    
    ##### Include only non-synonymous variants
    } else {
      
        mut.details.genes <- mafInfo[[datasets[i]]]@data[ mafInfo[[datasets[i]]]@data[, Hugo_Symbol] %in% genes, ]
    }
    
    if ( nrow(mut.details.genes) != 0 ) {
      
      ##### Sort table by gene symbol and then by sample ID
      mut.details.genes <- mut.details.genes[ order(mut.details.genes$Hugo_Symbol, mut.details.genes$Tumor_Sample_Barcode), ]
      
      #### Move column with Hugo_Symbol to the first place and Tumor_Sample_Barcode to the second
      col_idx <- grep("Tumor_Sample_Barcode", names(mut.details.genes))
      mut.details.genes <- as.data.frame(mut.details.genes)[, c(col_idx, (1:ncol(mut.details.genes))[-col_idx]) ]
      
      col_idx <- grep("Hugo_Symbol", names(mut.details.genes))
      mut.details.genes <- as.data.frame(mut.details.genes)[, c(col_idx, (1:ncol(mut.details.genes))[-col_idx]) ]
      
      widges.list[[i]] <- DT::datatable( data = mut.details.genes, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(mut.details.genes), 'text-align' = 'center' )
      
    } else {
      datasets.noMut <- c(datasets.noMut, datasets[i])
    }
  }
  
  ##### Report datasets with no mutations reported in selected genes
  if ( length(datasets.noMut) != 0 ) {
    if ( type == "nonsynonymous" ) {
      cat(paste("Note, none of queried gene(s) have non-synonymous variants reported in the following dataset(s):", paste(datasets.noMut, collapse = ", "), "\n\n", sep=" "))
    } else if ( type == "silent" ) {
      cat(paste("Note, none of queried gene(s) have silent variants reported in the following dataset(s):", paste(datasets.noMut, collapse = ", "), "\n\n", sep=" "))
    }
  }
  
  ##### Print a list of htmlwidgets
  widges.list
}

###### Generate lollipop plot for each dataset for selected gene
lollipops.datasets <- function(mafInfo, datasets, gene) {
  
  ##### Create a list to store MAF info for individual datasets
  for ( dataset in datasets ) {
    
    mut = subsetMaf(maf = mafInfo[[dataset]], includeSyn = FALSE, genes = gene, mafObj = FALSE, query = "Variant_Type != 'CNV'")
    
    ##### Check if the gene has any mutations in correspoding dataset
    if ( nrow(mut) != 0 ) {
      
      ##### Drawing lollipop for the top 10 genes in each dataset
      ##### Check if the amino acid changes information is available in MAF provided files. The script expects column called "HGVSp_Short", which is produced with vcf2maf (https://github.com/mskcc/vcf2maf) when converting VCFs to MAFs (https://github.com/cBioPortal/cbioportal/issues/2996) and describes a mutation's amino acid change. The "aa_mutation" field used for annotation in ICGC samples is also acceptable. NOTE: other possibilities are: "Protein_Change", "AAChange""
      pchange = c('HGVSp_Short', 'Protein_Change', 'AAChange')
      
      ##### Define the column with protein change info
      pchange = pchange[pchange %in% colnames(mut)]
      
      ##### Check if the protein change field is not empty
      if ( any(!is.na(as.data.frame(mut)[ , pchange  ]))  ) {
        
        cat(paste("\n\n <b>", dataset, "</b> \n\n", sep=" "))
        
        ##### Check if non-synonymous variats are detected
        if ( gene %in% mut$Hugo_Symbol ) {
        
          ##### Make it plot to a dummy graphics device file (e.g. /dev/null) to avoid plotting to the console
          pdf(file=paste0(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".pdf"), width = 8, height = 5)
          lollipopPlot.image <- capture.output(maftools::lollipopPlot(maf = mafInfo[[dataset]], gene = gene, AACol = pchange, printCount = FALSE, showDomainLabel = FALSE, repel = FALSE, labelPos = "all" , showMutationRate = TRUE, cBioPortal = TRUE))
          invisible(dev.off())
          
          ##### Export pdf to png
          lollipopPlot.image <- image_read_pdf(paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".pdf", sep = ""), pages = NULL, density = 300)
          image_write(lollipopPlot.image, path = paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".png", sep = ""), format = "png")
          
          ##### Read in the PNG files
          cat("![](",paste(paste0(mutationMapsDir, "/", paste(dataset, gene, sep="_")), ".png", sep = ""),")")
          cat("<br/><br/><br/>")
          
          ##### Remove redundant pdf plot
          file.remove(paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".pdf", sep = ""))
          while (!is.null(dev.list()))  invisible(dev.off())
        } else {
          cat(paste("**", gene, " have no non-synonymous variants detected in ", dataset, "dataset**.\n\n", sep=" "))
          cat("\n***\n")
        }
        
      ##### ...otherwise leave a message
      } else {
        
        ##### Check if the genes has any synonymous vatiants
        if ( length(pchange[pchange %in% colnames(mafInfo[[dataset]]@maf.silent)]) > 0 && gene %in% mafInfo[[dataset]]@maf.silent$Hugo_Symbol && any(!is.na(as.data.frame(mafInfo[[dataset]]@maf.silent)[ , pchange  ])) ) {
        
          cat(paste("This section was skipped for dataset", dataset, "since only synonymous variants were detected in", gene, "gene.\n\n", sep=" "))
      
        } else {
          cat(paste("This section was skipped for dataset", dataset, "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
        }
      }
        
    } else {
      cat(paste("\n\n <b>", dataset, "</b> \n\n", sep=" "))
      cat(paste("Gene <i>", gene, "</i> has **no coding mutations** reported in dataset", dataset, "\n\n", sep=" "))
    }
  }
}

##### A wrapper to saveWidget which compensates for arguable BUG in saveWidget which requires `file` to be in current working directory (see post https://github.com/ramnathv/htmlwidgets/issues/299 )
saveWidgetFix <- function ( widget, file, ...) {
  wd<-getwd()
  on.exit(setwd(wd))
  outDir<-dirname(file)
  file<-basename(file)
  setwd(outDir);
  htmlwidgets::saveWidget(widget,file=file,...)
}
```

```{r load_libraries, warning=FALSE}
suppressMessages(library(knitr))
suppressMessages(library(maftools))
suppressMessages(library(IRanges))
suppressMessages(library(dndscv))
suppressMessages(library(ActiveDriverWGS))
suppressMessages(library(ggplot2))
suppressMessages(library(DT))
suppressMessages(library(UpSetR))
suppressMessages(library(stringr))
suppressMessages(library(magick))
suppressMessages(library(RCircos))
suppressMessages(library(package=paste0("EnsDb.Hsapiens.v", params$ensembl_version), character.only = TRUE))
```

```{r load_data, message=FALSE, warning=FALSE, results='hide'}
##### Split the string of MAF files and put them into a vector
mafFiles <- unlist(strsplit(params$maf_files, split=',', fixed=TRUE))
mafFiles <- paste(params$maf_dir, mafFiles, sep="/")

##### Split the string of datasets names and put them into a vector
datasets.list <- unlist(strsplit(params$datasets, split=',', fixed=TRUE))

##### Read MAF files and put associated info into a list
##### Create a list to store MAF info for individual datasets
mafInfo <- vector("list", length(mafFiles))
names(mafInfo) <- datasets.list

##### Check if file with clinical information is provided
clinicalInfo <- vector("list", length(mafFiles))
names(clinicalInfo) <- datasets.list

if ( params$clinical_info != "none" ){
  
  clinicalFiles <- unlist(strsplit(params$clinical_info, split=',', fixed=TRUE))
  
  for ( i in 1:length(mafFiles) ) {
    clinicalInfo[[i]] <- read.table(clinicalFiles[[i]], sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote = "")
  }
} else {
  for ( i in 1:length(mafFiles) ) {
    clinicalInfo[[i]] <- NA
  }
} 

##### NOTE: maftools by default summarises only non-synonymous variants with high/moderate variant consequences and ignores silent variants (https://github.com/PoisonAlien/maftools/issues/63), which are stored in "maf.silent" slot of the class MAF object (mafInfo[[i]]@maf.silent)
for ( i in 1:length(mafFiles) ) {
  
  ##### Add clinical information if provided
  if ( !is.na(clinicalInfo[[i]]) ){
    mafInfo[[i]] <- maftools::read.maf(maf = mafFiles[i], vc_nonSyn = unlist(strsplit(params$nonSyn_list, split=',', fixed=TRUE)), removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE, clinicalData = clinicalInfo[[i]])
  } else {
    mafInfo[[i]] <- maftools::read.maf(maf = mafFiles[i], vc_nonSyn = unlist(strsplit(params$nonSyn_list, split=',', fixed=TRUE)), removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE, clinicalData = NULL)
  }
}

##### Change the column to be used to indicate samples' IDs
if ( !is.na(params$samples_id_cols) ) {
  samples_id_cols <- make.names(unlist(strsplit(params$samples_id_cols, split=',', fixed=TRUE)))
  
  for ( i in 1:length(mafFiles) ) {
    
    ##### Check if use-defined column name exists
    if ( samples_id_cols[i] %in% names(mafInfo[[i]]@data) && samples_id_cols[i] != "Tumor_Sample_Barcode" ) {
      
      ##### Change the use-defined column with samples' IDs to "Tumor_Sample_Barcode". If this column name already exist, then renames it to "Tumor_Sample_Barcode.orig"
      maf.data <- rbind(mafInfo[[i]]@data, mafInfo[[i]]@maf.silent)
      
      if ( samples_id_cols[i] %in% names(maf.data) ) {
        names(maf.data) <- gsub("Tumor_Sample_Barcode", "Tumor_Sample_Barcode.orig", names(maf.data))
        names(maf.data) <- gsub(samples_id_cols[i], "Tumor_Sample_Barcode", names(maf.data))
      } else {
        cat(paste0("\nColumn \"", samples_id_cols[i], "\" does not exist in MAF file ", mafFiles[i], "!\n\n"))
      }
      
      ##### Now read the data with changes column names as a maf object
      mafInfo[[i]] <- maftools::read.maf(maf = maf.data, vc_nonSyn = unlist(strsplit(params$nonSyn_list, split=',', fixed=TRUE)), removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE)
    }
  }
}

##### Read in list of genes of interest of specified
if ( params$genes_list != "none" ){
  goi <- unique(read.table(params$genes_list, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)[,1])
}

##### Create directory for output files
outDir <- paste(params$maf_dir, params$out_folder, "results", sep = "/")
if ( !file.exists(params$out_folder) ){
  dir.create(outDir, recursive=TRUE)
}

##### Run dNdS analysis with covariates ("cv" argument) only for data based on GRCh37/hg19 version of the human genome
if ( params$ucsc_genome_assembly == 19 ) {
  dNdS_cov <- TRUE
} else{
  dNdS_cov <- FALSE
}

##### Read in OncodriveFML analysis results (https://oncodrivefml.readthedocs.io/en/latest/output.html)
runOncodrivefmlChunk <- FALSE

if ( params$oncodrivefml != "none" ){
  
  oncodriveFML.res <- unlist(strsplit(params$oncodrivefml, split=',', fixed=TRUE))
  
  oncodriveFML.res.table <- vector("list", length(mafFiles))
  names(oncodriveFML.res.table) <- datasets.list
  
  for ( i in 1:length(mafFiles) ) {
    
    ##### Read in the results table
    if ( file.exists(paste0(oncodriveFML.res[i], ".tsv")) ) {
      
      oncodriveFML.res.table[[i]] <- read.table(paste0(oncodriveFML.res[i], ".tsv"), sep="\t", as.is=FALSE, header=TRUE, row.names=NULL)
      
      runOncodrivefmlChunk <- TRUE
    }
  }
}

##### Read in OncodriveFML configuration file (https://oncodrivefml.readthedocs.io/en/latest/output.html)
oncodrivefml.conf <- NULL

if ( params$oncodrivefml_conf != "none" ){
  
  ##### Read in the results table
  if ( file.exists(paste0(oncodriveFML.res[i], ".tsv")) ) {
    oncodrivefml.conf <- read.table(params$oncodrivefml_conf, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL, comment.char="#")
  }
}

##### Read in CGI analysis results (https://www.cancergenomeinterpreter.org/)
runcgiChunk <- FALSE

if ( params$cgi != "none" ){
  
  cgi.res <- unlist(strsplit(params$cgi, split=',', fixed=TRUE))
  
  cgi.mut.table <- vector("list", length(mafFiles))
  names(cgi.mut.table) <- datasets.list
  
  cgi.drug_pres.table <- vector("list", length(mafFiles))
  names(cgi.drug_pres.table) <- datasets.list
  
  cgi.drug_pres_bio.table <- vector("list", length(mafFiles))
  names(cgi.drug_pres_bio.table) <- datasets.list
  
  for ( i in 1:length(mafFiles) ) {
    
    ##### Read in the results table
    if ( file.exists(paste0(cgi.res[i], "/mutation_analysis.tsv")) ) {
      
      cgi.mut.table[[i]] <- read.table(paste0(cgi.res[i], "/mutation_analysis.tsv"), sep="\t", as.is=FALSE, header=TRUE, row.names=NULL)
      
      ##### Keep only genes annotated as Tier 1 and Tier 2
      cgi.mut.table[[i]] <- cgi.mut.table[[i]][ cgi.mut.table[[i]]$driver_mut_prediction %in% c("TIER 1", "TIER 2"), ]
      runcgiChunk <- TRUE
    }
    
    ##### Read in the results table
    if ( file.exists(paste0(cgi.res[i], "/drug_prescription.tsv")) ) {
      
      cgi.drug_pres.table[[i]] <- read.table(paste0(cgi.res[i], "/drug_prescription.tsv"), sep="\t", as.is=FALSE, header=TRUE, row.names=NULL)
    }
    
    ##### Read in the results table
    if ( file.exists(paste0(cgi.res[i], "/drug_prescription_bioactivities.tsv")) ) {
      
      cgi.drug_pres_bio.table[[i]] <- read.table(paste0(cgi.res[i], "/drug_prescription_bioactivities.tsv"), sep="\t", as.is=FALSE, header=TRUE, row.names=NULL)
    }
  }
}

##### Initiate a list to record sinigficant driver genes for each dataset
signif_genes.datasets <- vector("list", length(mafFiles))
names(signif_genes.datasets) <- datasets.list

signif_genes_table.datasets <- vector("list", length(mafFiles))
names(signif_genes_table.datasets) <- datasets.list

##### Initiate a list to record sinigficant driver genes for each method
methods <- c("dNdScv", "dNdSloc", "ActiveDriverWGS", "OncodriveCLUST")

if ( runOncodrivefmlChunk ) {
  methods <- c(methods, "OncodriveFML")
}

if ( runcgiChunk ) {
  methods <- c(methods, "CGI")
}

signif_genes.methods <- vector("list", length(methods))
names(signif_genes.methods) <- methods
```

```{r exclude_samples, comment = NA, message=FALSE, warning=FALSE}
##### Exclude user-derined samples(s) from the analysis
if ( params$samples_blacklist != "none" ) {
  for ( i in 1:length(mafFiles) ) {
      
    ##### Read in list of samples to be excluded
    exclsamples.df <- read.table(params$samples_blacklist, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL)
    exclsamples <- unique(exclsamples.df[,"Tumor_Sample_Barcode"])
    
    samples2keep <- unlist(unique( mafInfo[[i]]@data[, "Tumor_Sample_Barcode"])[ unique(mafInfo[[i]]@data[, "Tumor_Sample_Barcode"]) %!in% exclsamples ])
    
    ##### Subset the maf object to exclude use-defined sample(s)
    ##### Initially don't save the subset output as maf object, as this will exlude samples with no non-synonymous mutations from the summary
    mafInfo[[i]] <- subsetMaf(maf = mafInfo[[i]], tsb = as.vector(samples2keep), genes = NULL, fields = NULL, query = NULL, mafObj = FALSE, includeSyn = TRUE, dropLevels=TRUE)
    
    ##### Now read the data subset as a maf object
    mafInfo[[i]] <- maftools::read.maf(maf = mafInfo[[i]], vc_nonSyn = unlist(strsplit(params$nonSyn_list, split=',', fixed=TRUE)), removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE)
  }
}
```

```{r exclude_genes, comment = NA, message=FALSE, warning=FALSE}
##### Exclude user-derined gene(s) from the analysis
if ( params$genes_blacklist != "none" ) {
  for ( i in 1:length(mafFiles) ) {
    
    ##### Read in list of genes to be excluded
    exclgenes <- unique(read.table(params$genes_blacklist, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)[,1])
    
    genes2keep <- unique( mafInfo[[i]]@data$Hugo_Symbol)[ unique( mafInfo[[i]]@data$Hugo_Symbol) %!in% exclgenes ]
  
    ##### Subset the maf object to exclude use-defined gene(s)
    ##### Initially don't save the subset output as maf object, as this will exlude samples with no non-synonymous mutations from the summary
    mafInfo[[i]] <- subsetMaf(maf = mafInfo[[i]], tsb = NULL, genes = genes2keep, fields = NULL, query = NULL, mafObj = FALSE, includeSyn = TRUE)
    
    ##### Now read the data subset as a maf object
    mafInfo[[i]] <- maftools::read.maf(maf = mafInfo[[i]], vc_nonSyn = unlist(strsplit(params$nonSyn_list, split=',', fixed=TRUE)), removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE)
  }
} else {
  genes2keep <- mafInfo[[i]]@gene.summary$Hugo_Symbol
}
```

```{r silent_variants, comment = NA, message=FALSE, warning=FALSE}
##### Identify and record samples with no non-synonymous mutations
##### Prepare list to store all samples and samples with > 0 non-synonymous variants
MAF_samples <- vector("list", length(datasets.list))
names(MAF_samples) <- datasets.list
MAF_samples.silent.df <- NULL

##### Loop through MAF files
for ( i in 1:length(mafFiles) ) {
  
  ##### Identify samples with no non-synonymours variants according to corresponding MAF file
  MAF_samples[[i]]$all <- unlist(unique(mafInfo[[i]]@maf.silent[, "Tumor_Sample_Barcode"]))
  MAF_samples[[i]]$nonsyn <- unlist(maftools::getSampleSummary(mafInfo[[i]])[, "Tumor_Sample_Barcode"])
  MAF_samples[[i]]$silent <-  MAF_samples[[i]]$all[ MAF_samples[[i]]$all %!in% MAF_samples[[i]]$nonsyn  ]
  
  ##### Check if there thre are any samples with no non-synonymours variants. If so, add them to data frame
  if ( length(MAF_samples[[i]]$silent) > 0 ) {
    for ( sample in MAF_samples[[i]]$silent ) {
      
      MAF_samples.silent.df <- rbind( MAF_samples.silent.df, cbind( datasets.list[i], sample))
    }
    colnames(MAF_samples.silent.df) <- c("Dataset", "Sample")
  }
}

##### List silent variants classifications
silent_categories <- NULL

for ( i in 1:length(mafFiles) ) {
  silent_categories <- unique( c(silent_categories, mafInfo[[i]]@maf.silent$Variant_Classification) )
}
```

```{r dndscv_format_data, comment = NA, message=FALSE, warning=FALSE }
##### The input data is supposed to be a data.frame with five columns (sampleID, chr, pos, ref [base], mutant [base])
##### Convert the MAF calls object to the format relevant for dndscv
##### NOTE, silent mutations are also included
dndscvInfo <- vector("list", length(mafFiles))
names(dndscvInfo) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  
  dndscvInfo[[i]] <- rbind(mafInfo[[i]]@data[, c("Tumor_Sample_Barcode", "Chromosome", "Start_Position", "Reference_Allele", "Tumor_Seq_Allele2")], mafInfo[[i]]@maf.silent[, c("Tumor_Sample_Barcode", "Chromosome", "Start_Position", "Reference_Allele", "Tumor_Seq_Allele2")])
  names(dndscvInfo[[i]]) <- c("sampleID", "chr", "pos", "ref", "mut")
  
  ##### Make sure that the chromosome numbers start with "chr"if using v38 https://github.com/im3sanger/dndscv/issues/32
  #if ( params$ucsc_genome_assembly == 38 && is.na(match("chr", dndscvInfo[[i]]$chr)) ) {
  #  dndscvInfo[[i]]$chr <- paste0("chr", dndscvInfo[[i]]$chr)
  #}
  
  ##### Make sure that the chromosome numbers does NOT start with "chr" if using v19
  if ( params$ucsc_genome_assembly == 19 && !is.na(match("chr", dndscvInfo[[i]]$chr)) ) {
    dndscvInfo[[i]]$chr <- gsub("chr", "", dndscvInfo[[i]]$chr)
    
    dndscvInfo[[i]]$chr <- as.numeric(dndscvInfo[[i]]$chr)
    
  dndscvInfo[[i]] <- dndscvInfo[[i]][ !is.na(dndscvInfo[[i]]$chr), ]
  
    #if ( is.numeric(dndscvInfo[[i]]$chr) ) {
    #dndscvInfo[[i]]$chr <- gsub("chr", "", dndscvInfo[[i]]$chr)
    #}
  }
}
```

```{r dndscv_driver_analysis, comment = NA, message=FALSE, warning=FALSE }
##### Run dN/dS approach for cancer driver discovery using dNdScv option, which combines local information (synonymous mutations in the gene) and global information (variation of the mutation rate across genes, exploiting epigenomic covariates) to estimate the background mutation rate

##### Get reference database
eval(parse( text=paste0("data(refcds_hg", params$ucsc_genome_assembly, ", package=\"dndscv\")")))

dndsout <- vector("list", length(mafFiles))
names(dndsout) <- datasets.list

ci <- vector("list", length(mafFiles))
names(ci) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  
  ##### Run analysis for selected genes
  if ( params$genes_list != "none" ){
    
    ##### If the genome build is different than hg19 then skip the covariates. This is explained in http://htmlpreview.github.io/?http://github.com/im3sanger/dndscv/blob/master/vignettes/buildref.html and https://github.com/im3sanger/dndscv/issues/30
      
    if ( dNdS_cov ) {
      ##### First, check if all genes are in the RefCDS transcripts object
      RefCDSgenes <- goi[ goi %in% sapply(RefCDS, function(x) x$gene_name) ]
    
      dndsout[[i]] <- dndscv(dndscvInfo[[i]], gene_list = goi, refdb = paste0("hg", as.character(params$ucsc_genome_assembly)), sm = "192r_3w", kc = "cgc81", cv = paste0("hg", as.character(params$ucsc_genome_assembly)), max_muts_per_gene_per_sample = params$max_muts_per_gene, max_coding_muts_per_sample = params$hypermut_sample_cutoff, use_indel_sites = TRUE, min_indels = 5, maxcovs = 20, constrain_wnon_wspl = TRUE, outp = 3)
    
    } else {
      dndsout[[i]] <- dndscv(dndscvInfo[[i]], refdb = params$refdb_38, sm = "192r_3w", kc = "cgc81", cv = NULL, max_muts_per_gene_per_sample = params$max_muts_per_gene, max_coding_muts_per_sample = params$hypermut_sample_cutoff, use_indel_sites = TRUE, min_indels = 5, maxcovs = 20, constrain_wnon_wspl = TRUE, outp = 3)
    }
    
    ##### Calculate confidence intervals for the dN/dS ratios per gene
    if ( params$ratios_ci ) {
      ci[[i]] = geneci(dndsout[[i]])
    }
    
  ##### Run analysis for all genes
  } else {
    
    if ( dNdS_cov ) {
      ##### First, check if all genes are in the RefCDS transcripts object
      RefCDSgenes <- genes2keep[ genes2keep %in% sapply(RefCDS, function(x) x$gene_name) ]
    
      dndsout[[i]] <- dndscv(dndscvInfo[[i]], gene_list = RefCDSgenes, refdb = paste0("hg", as.character(params$ucsc_genome_assembly)), sm = "192r_3w", kc = "cgc81", cv = paste0("hg", as.character(params$ucsc_genome_assembly)), max_muts_per_gene_per_sample = params$max_muts_per_gene, max_coding_muts_per_sample = params$hypermut_sample_cutoff, use_indel_sites = TRUE, min_indels = 5, maxcovs = 20, constrain_wnon_wspl = TRUE, outp = 3)
    
    } else {
      dndsout[[i]] <- dndscv(dndscvInfo[[i]], refdb = params$refdb_38, sm = "192r_3w", kc = "cgc81", cv = NULL, max_muts_per_gene_per_sample = params$max_muts_per_gene, max_coding_muts_per_sample = params$hypermut_sample_cutoff, use_indel_sites = TRUE, min_indels = 5, maxcovs = 20, constrain_wnon_wspl = TRUE, outp = 3)
    }

    ##### Calculate confidence intervals for the dN/dS ratios per gene
    if ( params$ratios_ci ) {
      ci[[i]] = geneci(dndsout[[i]])
    }
  }
}
```

```{r dndscv_summarise, comment = NA, message=FALSE, warning=FALSE}
##### Write dndscv summary into a file
sel_cv <- vector("list", length(mafFiles))
names(sel_cv) <- datasets.list

theta <- vector("list", length(mafFiles))
names(theta) <- datasets.list

hypermut_samples <- vector("list", length(mafFiles))
names(hypermut_samples) <- datasets.list

exclmuts <- vector("list", length(mafFiles))
names(exclmuts) <- datasets.list

globaldnds <- vector("list", length(mafFiles))
names(globaldnds) <- datasets.list

signif_genes.methods$dNdScv <- vector("list", length(datasets.list))
names(signif_genes.methods$dNdScv) <- datasets.list
  
signif_genes.methods$dNdSloc <- vector("list", length(datasets.list))
names(signif_genes.methods$dNdSloc) <- datasets.list
  
for ( i in 1:length(mafFiles) ) {
  
  ##### Calculate theta estimtates
  theta[[i]] <- round(dndsout[[i]]$nbreg$theta, digits = 2)
  
  ##### Get a table of significant genes
  sel_cv[[i]] <- dndsout[[i]]$sel_cv
  signif_genes_table.datasets[[i]]$dNdScv <- sel_cv[[i]][sel_cv[[i]]$qglobal_cv <= params$dnds_q, ]
  signif_genes_table.datasets[[i]]$dNdScv <- signif_genes_table.datasets[[i]]$dNdScv[ signif_genes_table.datasets[[i]]$dNdScv$pglobal_cv < params$dnds_p, ]
  rownames(signif_genes_table.datasets[[i]]$dNdScv) = NULL
  
  ##### Organise the table of significant genes
  ##### Add confidence intervals for the dN/dS ratios per gene
  if ( params$ratios_ci ) {
    
    signif_genes_table.datasets[[i]]$dNdScv <- merge( signif_genes_table.datasets[[i]]$dNdScv, ci[[i]], by.x="gene_name", by.y="gene", all.x = TRUE, all.y = FALSE, sort = FALSE)
    
    ##### Organise the table of significant genes
    if ( dNdS_cov ) {
      signif_genes_table.datasets[[i]]$dNdScv <- signif_genes_table.datasets[[i]]$dNdScv[ , c("gene_name", "pglobal_cv", "qglobal_cv", "n_syn", "n_mis", "n_non", "n_spl", "n_ind", "wmis_cv", "mis_low", "mis_high", "pmis_cv", "wnon_cv", "wspl_cv", "tru_mle", "tru_low", "tru_high", "ptrunc_cv", "pallsubs_cv", "qallsubs_cv", "wind_cv", "pind_cv")]
    } else {
      signif_genes_table.datasets[[i]]$dNdScv <- signif_genes_table.datasets[[i]]$dNdScv[ , c("gene_name", "n_syn", "n_mis", "n_non", "n_spl", "wmis_cv", "mis_low", "mis_high", "pmis_cv", "wnon_cv", "wspl_cv", "tru_mle", "tru_low", "tru_high", "ptrunc_cv", "pallsubs_cv", "qallsubs_cv")]
    }
  } else {
    
    ##### Organise the table of significant genes
    if ( dNdS_cov ) {
      signif_genes_table.datasets[[i]]$dNdScv <- signif_genes_table.datasets[[i]]$dNdScv[ , c("gene_name", "pglobal_cv", "qglobal_cv", "n_syn", "n_mis", "n_non", "n_spl", "n_ind", "wmis_cv", "pmis_cv",  "wnon_cv", "wspl_cv", "ptrunc_cv", "pallsubs_cv", "qallsubs_cv", "wind_cv", "pind_cv")]
    } else {
      signif_genes_table.datasets[[i]]$dNdScv <- signif_genes_table.datasets[[i]]$dNdScv[ , c("gene_name", "pallsubs_cv", "qallsubs_cv", "n_syn", "n_mis", "n_non", "n_spl", "wmis_cv", "pmis_cv",  "wnon_cv", "wspl_cv", "ptrunc_cv")]
    }
  }

  ##### Record excluded (hypermutated) samples
  if (!is.null(dndsout[[i]]$exclsamples)) {
    
    hypermut_samples[[i]] <- as.data.frame(dndsout[[i]]$exclsamples)
    names(hypermut_samples[[i]]) <- "sampleID"
  } else {
    hypermut_samples[[i]] <- data.frame(matrix(ncol = 1, nrow = 0))
    names(hypermut_samples[[i]]) <- "sampleID"
  }
  
  ##### Record excluded mutations (mutations when encountering too many mutations per gene in the same sample)
  if (!is.null(dndsout[[i]]$exclmuts)) {
    exclmuts[[i]] <- dndsout[[i]]$exclmuts
    exclmuts[[i]] <- exclmuts[[i]][, c("gene", "sampleID", "chr", "pos", "ref", "mut", "geneind")]
    } else {
    exclmuts[[i]] <- data.frame(matrix(ncol = 7, nrow = 0))
    names(exclmuts[[i]]) <- c("gene", "sampleID", "chr", "pos", "ref", "mut", "geneind")
  }
  
  ##### Extract global maximum-likelihood estimates (MLEs) for the dN/dS ratios across all genes
  globaldnds[[i]] <- dndsout[[i]]$globaldnds
  
  ##### Extract results from the local neutrality test based on the dNdSloc model
  signif_genes_table.datasets[[i]]$dNdSloc <- dndsout[[i]]$sel_loc[ dndsout[[i]]$sel_loc$qall_loc <= params$dnds_q, ]
  signif_genes_table.datasets[[i]]$dNdSloc <- signif_genes_table.datasets[[i]]$dNdSloc[ signif_genes_table.datasets[[i]]$dNdSloc$pall_loc <= params$dnds_p, ]
  rownames(signif_genes_table.datasets[[i]]$dNdSloc) = NULL
  
  ##### Organise the table of significant genes
  signif_genes_table.datasets[[i]]$dNdSloc <- signif_genes_table.datasets[[i]]$dNdSloc[ , c("gene_name", "pall_loc", "qall_loc", "n_syn", "n_mis", "n_non", "n_spl", "wmis_loc", "pmis_loc", "qmis_loc", "wnon_loc", "wspl_loc")]
    
  ##### Record sinigficant driver genes for each dataset and method
  signif_genes.datasets[[i]] <- list(dNdScv = as.character(signif_genes_table.datasets[[i]]$dNdScv$gene_name), dNdSloc = as.character(signif_genes_table.datasets[[i]]$dNdSloc$gene_name))
  
  signif_genes.methods$dNdScv[[i]] <- as.character(signif_genes_table.datasets[[i]]$dNdScv$gene_name)
  signif_genes.methods$dNdSloc[[i]] <- as.character(signif_genes_table.datasets[[i]]$dNdSloc$gene_name)
}
```

```{r exclude_hypermutators, comment = NA, message=FALSE, warning=FALSE}
##### Exclude hypermutators from MAF object based on user-defined threshold
mafInfo.all <- mafInfo

for ( i in 1:length(mafFiles) ) {
  if ( nrow(hypermut_samples[[i]]) > 0 ) {
    sample2keep <- unique( mafInfo[[i]]@data$Tumor_Sample_Barcode)[ unique( mafInfo[[i]]@data$Tumor_Sample_Barcode) %!in% hypermut_samples[[i]]$sampleID ]
      
    ##### Extract required data from MAF
    mafInfo[[i]] <- subsetMaf(maf = mafInfo[[i]], tsb = sample2keep, genes = NULL, fields = NULL, query = NULL, mafObj = TRUE, includeSyn = TRUE)
    
    hypermut_samples_status <- TRUE
  } else {
    hypermut_samples_status <- FALSE
  }
}
```

```{r ActiveDriverWGS_format_data, comment = NA, message=FALSE, warning=FALSE }
##### The input data is supposed to be a data.frame with six columns (chr, pos1, pos2, ref, alt, and patient)
##### Convert the MAF calls object to the format relevant for ActiveDriverWGS
##### NOTE, silent mutations are also included
ActiveDriverWGSInfo <- vector("list", length(mafFiles))
names(ActiveDriverWGSInfo) <- datasets.list

##### Record genes used for the analysis
ActiveDriverWGS.genes <- NULL

for ( i in 1:length(mafFiles) ) {
  
  ActiveDriverWGSInfo[[i]] <- rbind(mafInfo[[i]]@data[, c("SYMBOL", "Chromosome", "Start_Position", "End_Position", "Reference_Allele", "Tumor_Seq_Allele2", "Tumor_Sample_Barcode")], mafInfo[[i]]@maf.silent[, c("SYMBOL", "Chromosome", "Start_Position", "End_Position", "Reference_Allele", "Tumor_Seq_Allele2", "Tumor_Sample_Barcode")])
  names(ActiveDriverWGSInfo[[i]]) <- c("SYMBOL", "chr", "pos1", "pos2", "ref", "alt", "patient")
  ActiveDriverWGSInfo[[i]]$patient <- as.vector(ActiveDriverWGSInfo[[i]]$patient)
  
  ##### Load UMCCR cancer gene list for ActiveDriverWGS if the "activedriverwgs_all_genes" paramter is not set to TRUE
  ##### (https://github.com/vladsaveliev/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.2019-03-20.tsv)
  if ( !params$activedriverwgs_all_genes ) {
    cancer_genes <- read.table(params$cancer_genes, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="")
    ActiveDriverWGSInfo[[i]] <- ActiveDriverWGSInfo[[i]][ ActiveDriverWGSInfo[[i]]$SYMBOL %in% cancer_genes$symbol, ]
    
    ActiveDriverWGS.genes <- unique(c(ActiveDriverWGS.genes, ActiveDriverWGSInfo[[i]]$SYMBOL))
    
    ##### Run analysis for selected genes
  } else if ( params$genes_list != "none" ){
    ActiveDriverWGSInfo[[i]] <- ActiveDriverWGSInfo[[i]][ ActiveDriverWGSInfo[[i]]$SYMBOL %in% goi, ]
      
    ActiveDriverWGS.genes <- unique(c(ActiveDriverWGS.genes, ActiveDriverWGSInfo[[i]]$SYMBOL))
  }
  
  ##### Remove gene column
  ActiveDriverWGSInfo[[i]] <- ActiveDriverWGSInfo[[i]][ , -c("SYMBOL")]
  
  ##### Make sure that the chromosome numbers start with "chr"
  if ( !is.na(match("chr", ActiveDriverWGSInfo[[i]]$chr)) ) {
    ActiveDriverWGSInfo[[i]]$chr <- paste0("chr", ActiveDriverWGSInfo[[i]]$chr)
  }
  
  ##### Make sure that sex chromosomes are defined as chrX and chrY
  ActiveDriverWGSInfo[[i]]$chr <- gsub("chr23", "chrX", ActiveDriverWGSInfo[[i]]$chr)
  ActiveDriverWGSInfo[[i]]$chr <- gsub("chr24", "chrY", ActiveDriverWGSInfo[[i]]$chr)
  
  ##### Make sure that only autosomal and sex chromosomes are provided
  ActiveDriverWGSInfo[[i]] <- ActiveDriverWGSInfo[[i]][ ActiveDriverWGSInfo[[i]]$chr %in% c(paste0("chr", 1:22), "chrX", "chrY"), ]
  
  ##### Finally make sure that all rows have defined "ref" and "alt" values (none NAs)
  ActiveDriverWGSInfo[[i]] <- ActiveDriverWGSInfo[[i]][complete.cases(ActiveDriverWGSInfo[[i]]), ]
}

##### ActiveDriverWGS also requires specific elements (which will be used for the analysis) that must be in data frame containing the columns with the correct column names (chr, start, end, and id)
##### Get genes annotation and genomic locations
edb <- eval(parse(text = paste0("EnsDb.Hsapiens.v", params$ensembl_version)))
  
##### Get keytypes for gene SYMBOL
keys <- keys(edb, keytype="GENEID")
  
##### Get genes genomic coordiantes
elements <- ensembldb::select(edb, keys=keys, columns=c("SEQNAME", "GENESEQSTART", "GENESEQEND", "GENENAME", "GENEID"), keytype="GENEID")

##### rename column names
names(elements) <- c("chr", "start", "end", "id", "GENEID")

##### Make sure that the chromosome numbers start with "chr"
elements$chr <- paste0("chr", elements$chr)

##### Make sure that only autosomal and sex chromosomes are provided
elements <- elements[ elements$chr %in% c(paste0("chr", 1:22), "chrX", "chrY"), ]

##### Run analysis for selected genes
if ( !is.null(ActiveDriverWGS.genes) ) {
    elements = elements[ elements$id %in% ActiveDriverWGS.genes,]
}
```

```{r ActiveDriverWGS_analysis, comment = NA, message=FALSE, warning=FALSE }
##### ActiveDriverWGS approach for cancer driver discovery (https://htmlpreview.github.io/?https://github.com/reimandlab/ActiveDriverWGSR/blob/master/doc/ActiveDriverWGSR.html#introduction)

##### Create a list to store MAF info for individual datasets
ActiveDriverWGS.res <- vector("list", length(mafFiles))
names(ActiveDriverWGS.res) <- datasets.list

signif_genes.methods$ActiveDriverWGS <- vector("list", length(datasets.list))
names(signif_genes.methods$ActiveDriverWGS) <- datasets.list

##### Create directory for storing recovery files
if ( !file.exists(paste(outDir, "ActiveDriverWGS_recovery", sep="/")) ){
  dir.create(paste(outDir, "ActiveDriverWGS_recovery", sep="/"), recursive=TRUE)
}

for ( i in 1:length(mafFiles) ) {
  
  ##### Suppress automatic output to console
  sink("/dev/null")
  ##### NOTE: the analysis crash when "recovery.dir" parameter (for storing recovery files) is used so currenlty it's set to NULL. Once fixed it can be set to "paste(outDir, "ActiveDriverWGS_recovery", sep="/")"
  ActiveDriverWGS.res[[i]] = ActiveDriverWGS(mutations = ActiveDriverWGSInfo[[i]], elements = elements, sites = NULL, window_size = 50000, filter_hyper_MB = params$hypermut_sample_cutoff/100, recovery.dir = NULL, mc.cores = params$activedriverwgs_cores, ref_genome = paste0("hg", params$ucsc_genome_assembly)) 
  sink() 

  ##### Order the table by element_muts_obs, pp_element, fdr_element and element_enriched
  ActiveDriverWGS.res[[i]] <- ActiveDriverWGS.res[[i]][ order( ActiveDriverWGS.res[[i]]$element_muts_obs, decreasing = TRUE), ]
  ActiveDriverWGS.res[[i]] <- ActiveDriverWGS.res[[i]][ order(ActiveDriverWGS.res[[i]]$pp_element, ActiveDriverWGS.res[[i]]$fdr_element), ]
  ActiveDriverWGS.res[[i]] <- ActiveDriverWGS.res[[i]][ order( ActiveDriverWGS.res[[i]]$element_enriched, decreasing = TRUE), ]
  rownames(ActiveDriverWGS.res[[i]]) = NULL

  ##### Record significant driver genes for each dataset
  signif_genes.datasets[[i]]$ActiveDriverWGS <- unique(c(ActiveDriverWGS.res[[i]]$id[ ActiveDriverWGS.res[[i]]$pp_element <= params$activedriverwgs_p & ActiveDriverWGS.res[[i]]$fdr_element <= params$activedriverwgs_fdr ]))
  signif_genes.datasets[[i]]$ActiveDriverWGS <- signif_genes.datasets[[i]]$ActiveDriverWGS[ signif_genes.datasets[[i]]$ActiveDriverWGS %in% ActiveDriverWGS.res[[i]]$id[ ActiveDriverWGS.res[[i]]$element_enriched ] ]
  
  ##### Remove NAs
  signif_genes.datasets[[i]]$ActiveDriverWGS <- signif_genes.datasets[[i]]$ActiveDriverWGS[ !is.na(signif_genes.datasets[[i]]$ActiveDriverWGS)]
  
  ##### Report significant driver genes
  signif_genes_table.datasets[[i]]$ActiveDriverWGS <- ActiveDriverWGS.res[[i]][ ActiveDriverWGS.res[[i]]$id %in%  signif_genes.datasets[[i]]$ActiveDriverWGS , ]
  rownames(signif_genes_table.datasets[[i]]$ActiveDriverWGS) = NULL
  
  ##### Record significant driver genes for each dataset and method
  signif_genes.methods$ActiveDriverWGS[[i]] <- as.vector(signif_genes_table.datasets[[i]]$ActiveDriverWGS$id)
  
  ##### Organise the table of significant genes
  signif_genes_table.datasets[[i]]$ActiveDriverWGS <- signif_genes_table.datasets[[i]]$ActiveDriverWGS[ , c("id", "pp_element", "fdr_element", "element_muts_obs", "element_muts_exp")]
}

##### Remove directory for storing recovery files once analyses are finished
if ( file.exists(paste(outDir, "ActiveDriverWGS_recovery", sep="/")) ){
  unlink(paste(outDir, "ActiveDriverWGS_recovery", sep="/"), recursive=TRUE)
}
```

```{r oncodriveCLUST_analysis,  include=FALSE }
##### In this chunk the clusters variants are calculated, but the results are reported in the next chunk
##### Import protein info data provided within maftools package
gl <- data.table::fread(input = paste("zcat <", system.file("extdata", "prot_len.txt.gz", package = "maftools")), sep = "\t", stringsAsFactors = FALSE)

##### Create a list to store MAF info for individual datasets
oncodriveClust.res <- vector("list", length(mafFiles))
names(oncodriveClust.res) <- datasets.list

signif_genes.methods$OncodriveCLUST <- vector("list", length(datasets.list))
names(signif_genes.methods$OncodriveCLUST) <- datasets.list

runOncodriveClustChunk <- FALSE

###### Generate separate plot for each dataset
for ( i in 1:length(mafFiles) ) {
  
  oncodriveClust.res[[datasets.list[i]]] <- oncodrive_analysis(mafInfo[[i]], datasets.list[i], gl) 

  if ( !is.null(oncodriveClust.res[[datasets.list[i]]][[1]]) ) {
    
    ##### Order results by genes' increasing FDR and then by decreasing total number of mutations
    oncodriveClust.res[[datasets.list[i]]][[1]] <- oncodriveClust.res[[datasets.list[i]]][[1]][ order(oncodriveClust.res[[datasets.list[i]]][[1]][, "fdr"],  rev(unlist(oncodriveClust.res[[datasets.list[i]]][[1]][, "total"]))) , ]
    
    ##### Record sinigficant driver genes for each dataset and method
    signif_genes.datasets[[i]]$OncodriveCLUST <- as.character(oncodriveClust.res[[datasets.list[i]]][[1]]$Hugo_Symbol[ oncodriveClust.res[[datasets.list[i]]][[1]]$fdr < params$oncodriveclust_fdr ])
    signif_genes.methods$OncodriveCLUST[[i]] <- as.character(oncodriveClust.res[[datasets.list[i]]][[1]]$Hugo_Symbol[ oncodriveClust.res[[datasets.list[i]]][[1]]$fdr < params$oncodriveclust_fdr ])
    
    signif_genes_table.datasets[[i]]$OncodriveCLUST <- oncodriveClust.res[[datasets.list[i]]][[1]][ oncodriveClust.res[[datasets.list[i]]][[1]]$fdr < params$oncodriveclust_fdr, ]
    rownames(signif_genes_table.datasets[[i]]$OncodriveCLUST) = NULL
    
    ##### Check if the field with AA change info is present in given MAF at all
    if ( length(signif_genes_table.datasets[[i]]$OncodriveCLUST) != 0 ) {
      
      runOncodriveClustChunk <- TRUE
      
      ##### Check if the any of the mutated genes demonstrates significant cluster score
      if ( nrow(signif_genes_table.datasets[[i]]$OncodriveCLUST) > 0 ) {
        
        ##### Organise the table of significant genes
        cols <- c("Hugo_Symbol", "clusterScores", "zscore", "pval", "fdr", "Frame_Shift_Del", "Frame_Shift_Ins", "In_Frame_Del", "In_Frame_Ins", "Missense_Mutation", "Nonsense_Mutation", "Splice_Site", "Translation_Start_Site", "total", "MutatedSamples", "AlteredSamples", "clusters", "muts_in_clusters", "protLen", "fract_muts_in_clusters")
        cols <- cols[ cols %in% names(signif_genes_table.datasets[[i]]$OncodriveCLUST)]
        cols <- match(cols, names(signif_genes_table.datasets[[i]]$OncodriveCLUST) )
        signif_genes_table.datasets[[i]]$OncodriveCLUST <- subset(signif_genes_table.datasets[[i]]$OncodriveCLUST, select=cols)
      } else {
        signif_genes.datasets[[i]]$OncodriveCLUST <- NULL
        signif_genes.methods$OncodriveCLUST[[i]] <- NULL
        methods <- methods[ methods %!in% "OncodriveCLUST" ]
      }
    } else {
      signif_genes.datasets[[i]]$OncodriveCLUST <- NULL
      signif_genes.methods$OncodriveCLUST[[i]] <- NULL
      methods <- methods[ methods %!in% "OncodriveCLUST" ]
    }
  } else {
    signif_genes.datasets[[i]]$OncodriveCLUST <- NULL
    signif_genes.methods$OncodriveCLUST[[i]] <- NULL
    methods <- methods[ methods %!in% "OncodriveCLUST" ]
  }
}
```

```{r oncodriveFML_load_results,  include=FALSE, eval=runOncodrivefmlChunk}
##### Create a list to store OncodriveFML info for individual datasets
signif_genes.methods$OncodriveFML <- vector("list", length(datasets.list))
names(signif_genes.methods$OncodriveFML) <- datasets.list

###### Record results for each dataset
for ( i in 1:length(mafFiles) ) {
  
  ##### Move gene name to the first column
  col_idx <- grep("SYMBOL", names(oncodriveFML.res.table[[i]]))
  oncodriveFML.res.table[[i]] <- subset(oncodriveFML.res.table[[i]], select=c(names(oncodriveFML.res.table[[i]])[c(col_idx, c(1:ncol(oncodriveFML.res.table[[i]]))[-col_idx])]))

  ##### Order the table by P_VALUE, MUTS and SAMPLES
  oncodriveFML.res.table[[i]] <- oncodriveFML.res.table[[i]][ order( oncodriveFML.res.table[[i]]$SAMPLES, oncodriveFML.res.table[[i]]$MUTS, decreasing = TRUE), ]
  oncodriveFML.res.table[[i]] <- oncodriveFML.res.table[[i]][ order(oncodriveFML.res.table[[i]]$P_VALUE), ]
  rownames(oncodriveFML.res.table[[i]]) = NULL
  
  ##### Calculate expected p-value
  oncodriveFML.res.table[[i]]$P_VALUE_EXP <- ppoints(length(oncodriveFML.res.table[[i]]$P_VALUE))

  ##### Record sinigficant driver genes for each dataset
  signif_genes.datasets[[i]]$OncodriveFML <- unique(c(as.character(oncodriveFML.res.table[[i]]$SYMBOL)[ oncodriveFML.res.table[[i]]$P_VALUE <= params$oncodrivefml_p  ], as.character(oncodriveFML.res.table[[i]]$SYMBOL)[ oncodriveFML.res.table[[i]]$Q_VALUE <= params$oncodrivefml_q ]))
  
  ##### Remove NAs
  signif_genes.datasets[[i]]$OncodriveFML <- signif_genes.datasets[[i]]$OncodriveFML[ !is.na(signif_genes.datasets[[i]]$OncodriveFML)]
  
  ##### Report significant driver genes
  signif_genes_table.datasets[[i]]$OncodriveFML <- oncodriveFML.res.table[[i]][ oncodriveFML.res.table[[i]]$SYMBOL %in%  signif_genes.datasets[[i]]$OncodriveFML , ]
  rownames(signif_genes_table.datasets[[i]]$OncodriveFML) = NULL
  
  ##### Record sinigficant driver genes for each dataset and method
  signif_genes.methods$OncodriveFML[[i]] <- as.vector(signif_genes_table.datasets[[i]]$OncodriveFML$SYMBOL)
  
  ##### Organise the table of significant genes
  signif_genes_table.datasets[[i]]$OncodriveFML <- signif_genes_table.datasets[[i]]$OncodriveFML[ , c("SYMBOL", "GENE_ID", "P_VALUE", "P_VALUE_EXP", "Q_VALUE", "MUTS", "MUTS_RECURRENCE", "SAMPLES", "P_VALUE_NEG", "Q_VALUE_NEG", "SNP", "MNP", "INDELS")]
}
```

```{r cgi_load_results,  include=FALSE, eval=runcgiChunk}
##### Create a list to store OncodriveFML info for individual datasets
signif_genes.methods$CGI <- vector("list", length(datasets.list))
names(signif_genes.methods$CGI) <- datasets.list

###### Record results for each dataset
for ( i in 1:length(mafFiles) ) {
  
  ##### Move sample name to the first column
  col_idx <- grep("sample", names(cgi.mut.table[[i]]))
  cgi.mut.table[[i]] <- subset(cgi.mut.table[[i]], select=c(names(cgi.mut.table[[i]])[c(col_idx, c(1:ncol(cgi.mut.table[[i]]))[-col_idx])]))
  
  ##### Specify the tumour type of interest
  cancer_type.cgi <- cgi.mut.table[[i]]$cancer[1]
  cgi.mut.table[[i]]$"driver_gene" <- factor(cgi.mut.table[[i]]$"driver_gene", levels = c(levels(cgi.mut.table[[i]]$"driver_gene"), paste0( "driver_gene ", cancer_type.cgi )))
  cgi.mut.table[[i]]$"driver_gene"[ cgi.mut.table[[i]]$"driver_gene" == "tumor_driver"] <- paste0( "driver_gene ", cancer_type.cgi )
  
  ##### Keep columns of interest (as shown in CGI web results)
  cgi.mut.table[[i]] <- cgi.mut.table[[i]][ , c("sample","hugo_symbol","protein","consequence","Pfam_domain","driver_statement","gdna","transcript","exon","mutation_location","driver_gene","gene_role","cadd_phred") ]
  
  ##### Change column names
  names(cgi.mut.table[[i]]) <- gsub("hugo_symbol", "gene", names(cgi.mut.table[[i]]))
  names(cgi.mut.table[[i]]) <- gsub("protein", "protein change", names(cgi.mut.table[[i]]))
  names(cgi.mut.table[[i]]) <- gsub("Pfam_domain", "domain", names(cgi.mut.table[[i]]))
  names(cgi.mut.table[[i]]) <- gsub("driver_statement", "oncogenic classification", names(cgi.mut.table[[i]]))
  names(cgi.mut.table[[i]]) <- gsub("driver_gene", "tumour driver", names(cgi.mut.table[[i]]))
  names(cgi.mut.table[[i]]) <- gsub("cadd_phred", "deleteriuos", names(cgi.mut.table[[i]]))
  names(cgi.mut.table[[i]]) <- gsub("mutation_location", "location", names(cgi.mut.table[[i]]))
  
  ##### Change the table levels order
  cgi.mut.table[[i]] <- cgi.mut.table[[i]][ order( cgi.mut.table[[i]]$"tumour driver", cgi.mut.table[[i]]$"deleteriuos", cgi.mut.table[[i]]$"sample", decreasing = TRUE), ]
  cgi.mut.table[[i]] <- cgi.mut.table[[i]][ order( cgi.mut.table[[i]]$"oncogenic classification", decreasing = FALSE), ]
  
  rownames(cgi.mut.table[[i]]) = NULL
  
  ##### Record sinigficant driver genes for each dataset
  signif_genes.datasets[[i]]$CGI <- unique(c(as.character(cgi.mut.table[[i]]$gene)))
  
  ##### Remove NAs
  signif_genes.datasets[[i]]$CGI <- signif_genes.datasets[[i]]$CGI[ !is.na(signif_genes.datasets[[i]]$CGI)]
  
  ##### Report significant driver genes
  signif_genes_table.datasets[[i]]$CGI <- cgi.mut.table[[i]][ cgi.mut.table[[i]]$gene %in%  signif_genes.datasets[[i]]$CGI , ]
  rownames(signif_genes_table.datasets[[i]]$CGI) = NULL
  
  ##### Record sinigficant driver genes for each dataset and method
  signif_genes.methods$CGI[[i]] <- as.vector(signif_genes_table.datasets[[i]]$CGI$gene)
  
  ##### Organise the PRESCRIPTION table
  ##### Keep only entries with TUMOR_MATCH and ALTERATION_MATCH
  cgi.drug_pres.table[[i]] <- cgi.drug_pres.table[[i]][ cgi.drug_pres.table[[i]]$TUMOR_MATCH == 1, ]
  cgi.drug_pres.table[[i]] <- cgi.drug_pres.table[[i]][ cgi.drug_pres.table[[i]]$ALTERATION_MATCH == "complete", ]
  
  ##### Keep columns of interest (as shown in CGI web results)
  cgi.drug_pres.table[[i]] <- cgi.drug_pres.table[[i]][ , names(cgi.drug_pres.table[[i]]) %!in% c("CANCER_TYPE","ALTERATION_MATCH","TUMOR_MATCH","BIOMARKER_IDX","RESISTANCE_LIST","TESTED_TUMOR") ]
  
  ##### Polish content
  names(cgi.drug_pres.table[[i]]) <- gsub("SAMPLE_ALTERATION", "ALTERATION", names(cgi.drug_pres.table[[i]]))
  cgi.drug_pres.table[[i]]$ALTERATION <- gsub(" MUT ", " ", cgi.drug_pres.table[[i]]$ALTERATION)
  cgi.drug_pres.table[[i]]$ALTERATION <- gsub(" MUT\\* ", " ", cgi.drug_pres.table[[i]]$ALTERATION)

  ##### Change the table levels order
  cgi.drug_pres.table[[i]] <- cgi.drug_pres.table[[i]][ order( cgi.drug_pres.table[[i]]$EVIDENCE, cgi.drug_pres.table[[i]]$SAMPLE, cgi.drug_pres.table[[i]]$EFFECT, decreasing = FALSE), ]
  rownames(cgi.drug_pres.table[[i]]) = NULL
  
  ##### Organise the PRESCRIPTION BIOACTIVITIES table
  ##### Keep only entries with MOA_MATCH and with "highly_potent" binding potency
  cgi.drug_pres_bio.table[[i]] <- cgi.drug_pres_bio.table[[i]][ cgi.drug_pres_bio.table[[i]]$MOA_MATCH == "True", ]
  cgi.drug_pres_bio.table[[i]] <- cgi.drug_pres_bio.table[[i]][ cgi.drug_pres_bio.table[[i]]$PACTIVITY_LABEL == "highly_potent", ]
  
  ##### Keep columns of interest (as shown in CGI web results)
  cgi.drug_pres_bio.table[[i]] <- cgi.drug_pres_bio.table[[i]][ , names(cgi.drug_pres_bio.table[[i]]) %!in% c("CANCER_TYPE","MOA_MATCH") ]
  
  ##### Polish content
  names(cgi.drug_pres_bio.table[[i]]) <- gsub("SAMPLE_ALTERATION", "ALTERATION", names(cgi.drug_pres_bio.table[[i]]))
  cgi.drug_pres_bio.table[[i]]$ALTERATION <- gsub(" MUT ", " ", cgi.drug_pres_bio.table[[i]]$ALTERATION)
  cgi.drug_pres_bio.table[[i]]$ALTERATION <- gsub(" MUT\\* ", " ", cgi.drug_pres_bio.table[[i]]$ALTERATION)
  names(cgi.drug_pres_bio.table[[i]]) <- gsub("MOLECULE_NAME", "COMPOUND", names(cgi.drug_pres_bio.table[[i]]))
  names(cgi.drug_pres_bio.table[[i]]) <- gsub("PACTIVITY_LABEL", "BINDING POTENCY", names(cgi.drug_pres_bio.table[[i]]))
  names(cgi.drug_pres_bio.table[[i]]) <- gsub("PACTIVITY_MEDIAN", "BINDING P-ACTIVITY", names(cgi.drug_pres_bio.table[[i]]))
  names(cgi.drug_pres_bio.table[[i]]) <- gsub("MOLECULE_TYPE", "TYPE", names(cgi.drug_pres_bio.table[[i]]))
  names(cgi.drug_pres_bio.table[[i]]) <- gsub("MOLECULE_STATUS", "STATUS", names(cgi.drug_pres_bio.table[[i]]))
  rownames(cgi.drug_pres_bio.table[[i]]) = NULL
}
```

```{r driver_genes_summary, comment = NA, message=FALSE, warning=FALSE}
##### Compute the intersections between cancer driver genes detected by various methods
signif_genes.upset <- vector("list", length(mafFiles))
names(signif_genes.upset) <- datasets.list

signif_genes.upset.mod <- vector("list", length(mafFiles))
names(signif_genes.upset.mod) <- datasets.list

signif_genes <- vector("list", length(mafFiles))
names(signif_genes) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  
  signif_genes[[i]] <- verify_genes(unlist(signif_genes.datasets[[i]]))
  
  if ( length(signif_genes[[i]]) > 0 ) {
    
    ##### Create empty data frame for the upset() function (0 = not driver gene, 1 = driver gene)
    signif_genes.upset[[i]] <- data.frame(matrix(NA, nrow = length(signif_genes.datasets[[i]]), ncol = length(signif_genes[[i]])))
    names(signif_genes.upset[[i]]) <- signif_genes[[i]]
    rownames(signif_genes.upset[[i]]) <- names(signif_genes.datasets[[i]])
    
    ##### Check which genes were detected by individual method
    for( gene in signif_genes[[i]] ) {
      for ( j in 1:length(signif_genes.datasets[[i]]) ) {
        if ( gene %in% verify_genes(signif_genes.datasets[[i]][[j]]) ) {
          
          signif_genes.upset[[i]][ names(signif_genes.datasets[[i]][j]) , gene] <- 1
        } else {
          signif_genes.upset[[i]][ names(signif_genes.datasets[[i]][j]) , gene] <- 0
        }
      }
    }
    
    ##### Add column with summarised counts for each gene and organise the intersections summary table
    signif_genes.upset.mod[[i]] <- as.data.frame(t(signif_genes.upset[[i]]))
    signif_genes.upset.mod[[i]]$Total <- rowSums( signif_genes.upset.mod[[i]] )
    
    if ( "CGI" %in% names(signif_genes.datasets[[i]]) ) {
      signif_genes.upset.mod[[i]] <- signif_genes.upset.mod[[i]][ order( signif_genes.upset.mod[[i]][, "CGI"], decreasing = TRUE),  ] 
    }
    
    if ( "OncodriveFML" %in% names(signif_genes.datasets[[i]]) ) {
      signif_genes.upset.mod[[i]] <- signif_genes.upset.mod[[i]][ order( signif_genes.upset.mod[[i]][, "OncodriveFML"], decreasing = TRUE),  ] 
    }
    
    if ( "OncodriveCLUST" %in% names(signif_genes.datasets[[i]]) ) {
      signif_genes.upset.mod[[i]] <- signif_genes.upset.mod[[i]][ order( signif_genes.upset.mod[[i]][, "OncodriveCLUST"], decreasing = TRUE),  ] 
    }
    
    if ( "ActiveDriverWGS" %in% names(signif_genes.datasets[[i]]) ) {
      signif_genes.upset.mod[[i]] <- signif_genes.upset.mod[[i]][ order( signif_genes.upset.mod[[i]][, "ActiveDriverWGS"], decreasing = TRUE),  ] 
    }
    
    signif_genes.upset.mod[[i]] <- signif_genes.upset.mod[[i]][ order( signif_genes.upset.mod[[i]][, "Total"], signif_genes.upset.mod[[i]][, "dNdScv"], signif_genes.upset.mod[[i]][, "dNdSloc"], decreasing = TRUE),  ] 
    
    for ( j in 1:length(signif_genes.datasets[[i]]) ) {
    
      signif_genes.upset.mod[[i]][ signif_genes.upset.mod[[i]][, j] == 1, j ] <- "Yes"
      signif_genes.upset.mod[[i]][ signif_genes.upset.mod[[i]][, j] == 0, j ] <- "No"
    }
  }
}
```

```{r gene_annot, comment = NA, message=FALSE, warning=FALSE}
##### Create a list to store genes annotations for each dataset
signif_genes.annot <- vector("list", length(mafFiles))
names(signif_genes.annot) <- datasets.list

##### Loop through each dataset and annotate detected cancer driver genes
for ( i in 1:length(mafFiles) ) {
  
  if ( length(signif_genes[[i]]) > 0 ) {
    data.df <- as.data.frame(signif_genes[[i]])
    colnames(data.df) <- "GENENAME"
  
    ##### Get genes annotation and genomic locations
    edb <- eval(parse(text = paste0("EnsDb.Hsapiens.v", params$ensembl_version)))
    
    ##### Get keytypes for gene SYMBOL
    keys <- keys(edb, keytype="GENENAME")
    
    ##### Get genes genomic coordiantes
    gene_info <- ensembldb::select(edb, keys=keys, columns=c("SEQNAME", "GENESEQSTART", "GENESEQEND","GENENAME"), keytype="GENENAME")
    
    ##### Remove rows with duplicated gene symbols (Y_RNAs, SNORs, LINC0s etc)
    gene_info = gene_info[!duplicated(gene_info$GENENAME),]

    ##### Limit genes annotation to driver genes
    gene_info <-  gene_info[ gene_info$GENENAME %in% data.df$GENENAME,  ]
    
    ##### Change column names
    names(gene_info) <- gsub("SEQNAME", "Chromosome", names(gene_info))
    names(gene_info) <- gsub("GENESEQSTART", "chromStart", names(gene_info))
    names(gene_info) <- gsub("GENESEQEND", "chromEnd", names(gene_info))
    names(gene_info) <- gsub("GENENAME", "Gene", names(gene_info))
    
    ##### Add "chr" to chromosome numbers
    gene_info$Chromosome <- paste0("chr", gene_info$Chromosome)
    signif_genes.annot[[i]] <- gene_info
    
    ##### Re-order genes
    rownames(signif_genes.annot[[i]]) <- signif_genes.annot[[i]]$Gene
    signif_genes.annot[[i]] <- signif_genes.annot[[i]][ signif_genes[[i]], ]
    signif_genes.annot[[i]] <- signif_genes.annot[[i]][ !is.na(signif_genes.annot[[i]]$Gene), ]
  }
}

##### Clean the space
rm(data.df, edb, keys)
```


## Datasets  {.tabset}

This report summarises and visualises driver analyses results for the following dataset(s):

```{r datasets, comment = NA}
##### Present patient cohorts to be summarised
datasets.df <- as.data.frame( cbind(datasets.list, unlist(strsplit(params$maf_files, split=',', fixed=TRUE))) )
names(datasets.df) <- c("Dataset", "MAF file")

DT::datatable( data = datasets.df, filter = "none", extensions = 'Buttons', options = list(pageLength = length(mafFiles), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy')) ) %>%
        DT::formatStyle( columns = names(datasets.df), 'text-align' = 'center' )
```

### Overall summary

Table(s) with basic information about each dataset based on data in corresponding MAF file(s).

```{r overll_summary, comment = NA, message=FALSE, warning=FALSE}
##### Present a MAF file summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable( data = mafInfo.all[[i]]@summary, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "none", extensions = 'Buttons', options = list(pageLength = nrow(mafInfo.all[[i]]@summary), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis')), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(mafInfo.all[[i]]@summary), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### Samples summary {.tabset}

#### Samples with non-synonymous variant(s)

Table(s) summarising samples in individual datasets. Each table contains per-sample information (rows) about *number of different types of mutations* (columns), as well as the *total number of mutations* reported in corresponding MAF file. <span style="color:#ff0000">NOTE</span>, only **samples with detected non-synonymous variant(s)** are reported in the table below.

```{r sample_summary, comment = NA, warning=FALSE}
##### Present a sample table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable( data = maftools::getSampleSummary(mafInfo.all[[i]]), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(maftools::getSampleSummary(mafInfo.all[[i]])), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( !is.null(MAF_samples.silent.df) ) { c("***") }`

`r if ( !is.null(MAF_samples.silent.df) ) { c("#### Samples with no non-synonymous variants") }`

`r if ( !is.null(MAF_samples.silent.df) ) { c("The table below lists sample(s) in which **no non-synonymous variants** were detected and hence will not be included in the summary tables/plots.") }`

```{r sample_no_nonsynonymous, comment = NA, warning=FALSE}
##### report samples with no non-synonymous variants according to corresponding MAF file
if ( !is.null(MAF_samples.silent.df) ) {
  DT::datatable( data = MAF_samples.silent.df, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong("Samples with no non-synonymours variants detected")), filter = "top", extensions = 'Buttons', options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy')) ) %>%
        DT::formatStyle( columns = names(MAF_samples.silent.df), 'text-align' = 'center' )
}

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( params$samples_blacklist != "none" ) { c("***") }`

`r if ( params$samples_blacklist != "none" ) { c("#### Excluded samples") }`

`r if ( params$samples_blacklist != "none" ) { c("List of samples excluded from the analysis.") }`

```{r excluded_samples_table, comment = NA, message=FALSE, warning=FALSE}
##### Present a samples table in the html report
if ( params$samples_blacklist != "none" ) {
    
  DT::datatable(data = exclsamples.df, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;'), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 1), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(exclsamples.df), 'text-align' = 'center' )
}
```

`r if ( hypermut_samples_status ) { c("***") }`

`r if ( hypermut_samples_status ) { c("#### Hypermutator samples") }`

`r if ( hypermut_samples_status ) { c(paste0("Table(s) listing sample(s) with >",  params$hypermut_sample_cutoff, " coding mutations. These have been removed from the analyses to protect against loss of sensitivity from ultra-hypermutators.")) }`

```{r hypermutator_samples, comment = NA, message=FALSE, warning=FALSE, eval=hypermut_samples_status}
##### Present results summary table in the html report
if ( length(unlist(hypermut_samples)) > 0 ) {
  
  ##### Create a list for htmlwidgets
  widges.list <- htmltools::tagList()
  
  for ( i in 1:length(mafFiles) ) {
      
    widges.list[[i]] <- DT::datatable( data = hypermut_samples[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(hypermut_samples[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 1), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
          DT::formatStyle( columns = names(hypermut_samples[[i]]), 'text-align' = 'center' )
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( params$clinical_info != "none" ) { c("***") }`

`r if ( params$clinical_info != "none" ) { c("### Samples annotation") }`

`r if ( params$clinical_info != "none" ) { c("Sample annotations for individual dataset(s).") }`

```{r samples_annot_table, comment = NA, message=FALSE, warning=FALSE}
##### Present a samples table in the html report
if ( params$clinical_info != "none" ) {
  
  ##### Create a list for htmlwidgets
  widges.list <- htmltools::tagList()

  for ( i in 1:length(mafFiles) ) {
    widges.list[[i]] <- DT::datatable( data = mafInfo[[i]]@clinical.data, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(clinicalInfo[[i]]), 'text-align' = 'center' )
  }
  
  ##### Print a list of htmlwidgets
  widges.list
}
```

***

### Genes summary {.tabset}

#### Mutated genes

Table(s) summarising mutated genes in individual datasets. Each table contains per-gene information (rows) about *number of different types of mutations* (columns), as well as the *total number of mutations* reported in corresponding MAF file. The last two columns contain the *number of samples with mutations/alterations* in the corresponding gene.

```{r gene_summary, warning=FALSE}
##### Present a gene table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable(data = maftools::getGeneSummary(mafInfo.all[[i]]), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(maftools::getGeneSummary(mafInfo.all[[i]])), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list
```

`r if ( params$genes_blacklist != "none" ) { c("***") }`

`r if ( params$genes_blacklist != "none" ) { c("#### Excluded genes") }`

`r if ( params$genes_blacklist != "none" ) { c("List of genes excluded from the analysis.") }`

```{r excluded_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Present a gene table in the html report
if ( params$genes_blacklist != "none" ) {
    
  DT::datatable(data = data.frame(Gene = exclgenes), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;'), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
    DT::formatStyle( columns = "Gene", 'text-align' = 'center' )
}
```

***

## Driver genes detection

### dN/dS {.tabset}

Selection analyses and cancer driver discovery using [dNdScv](https://github.com/im3sanger/dndscv){target="_blank"} R package. It provides *maximum-likelihood dN/dS* methods designed to quantify selection in cancer and somatic evolution ([Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"}). The package contains functions two different models (**dNdScv** and **dNdSloc**) to quantify dN/dS ratios for missense, nonsense and essential splice mutations, at the level of individual genes, groups of genes or at whole-genome level. The [dNdScv](https://github.com/im3sanger/dndscv){target="_blank"} package was designed to detect cancer driver genes (i.e. genes under positive selection in cancer) on datasets ranging from a few samples to thousands of samples, in whole-exome/genome or targeted sequencing studies.

***

<details>
<summary>dNdScv model</summary>

Combines local information (synonymous mutations in the gene) and global information (variation of the mutation rate across genes, exploiting epigenomic covariates) to estimate the background mutation rate. It is a preferred model in most situations.

</details>

<details>
<summary>dNdSloc model</summary>

Based on local neutrality test, in which the number of synonymous mutations in a gene is used to infer the local mutation rate ([Wong *et al*., 2014](https://www.ncbi.nlm.nih.gov/pubmed/24316979){target="_blank"}), without exploiting additional information from other genes. This test is typically only powered in very large datasets.

</details>

<details>
<summary>Which model to use?</summary>

***dNdScv*** is a preferred model in most situations. However, low estimates of theta (, the overdispersion parameter), particularly  < 1, may reflect problems with the suitability of the dNdScv model for the dataset. In these cases, it is reasonable to consider the traditional *dN/dS* (***dNdSloc***) model.

The estimated **** value(s) for dataset(s) `r names(unlist(theta))` are: **`r unlist(theta)`**, respectively.

</details>

<details>
<summary>Input parameters</summary>
<font size="2">

* Genome assembly version: **`r paste0("hg", params$ucsc_genome_assembly)`**
* Maximum mutations per gene in same sample: **`r params$max_muts_per_gene`**
* Number of coding mutations to define ultra-hypermutator samples: **`r params$hypermut_sample_cutoff`**
* P-value threshold for reporting cancer driver genes: **`r params$dnds_p`**
* Q-value threshold for reporting cancer driver genes: **`r params$dnds_q`**

**Ultra-hypermutator samples** (with > `r params$hypermut_sample_cutoff` coding mutations) are removed and **mutations with > `r params$max_muts_per_gene` mutations per gene** in the same sample are subsampled to protect against loss of sensitivity from ultra-hypermutators and from clustered artefacts.

</font> 
</details>

***

#### Plots {.tabset}

##### dNdScv

*X-axis* indicates the *number of variants* observed in individual genes and *y-axis* illustrates *global p-values* in -log10 scale. The *size* of the points is proportional to -log10 *p-values* based on all substitutions detected in individual genes. 
`r if ( dNdS_cov ) { c("The *colour* scale reflects *p-values* computed for indels, with purple and yellow indicating low and high *p-values*, respectively.") } else { c("The *colour* of the points is proportional to -log10 *p-values* based on substitutions without indels.") }`

```{r dndscv_plot, comment = NA, message=FALSE, warning=FALSE}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( nrow(signif_genes_table.datasets[[i]]$dNdScv) > 0 ) {
      
    ##### Avoid p-values of 0 by assigning 1*10^-16 to extremely low p-values
    if ( dNdS_cov ) {
      p_global <- signif_genes_table.datasets[[i]]$dNdScv$pglobal_cv
      p_ind <- signif_genes_table.datasets[[i]]$dNdScv$pind_cv
      p_ind[ p_ind == 0 ] <- 1*10^-16
    } else {
      p_global <- signif_genes_table.datasets[[i]]$dNdScv$pallsubs_cv
      p_ind <- 1
    }
    
    p_global[ p_global == 0 ] <- 1*10^-16
    p_subs <- signif_genes_table.datasets[[i]]$dNdScv$pallsubs_cv
    p_subs[ p_subs == 0 ] <- 1*10^-16
    
    ##### Sum up all mutations
    mutations_no <- rowSums(signif_genes_table.datasets[[i]]$dNdScv[ , names(signif_genes_table.datasets[[i]]$dNdScv) %in% c("n_syn", "n_mis", "n_non", "n_spl", "n_ind") ])
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(signif_genes_table.datasets[[i]]$dNdScv$gene_name, -log(p_global,10), mutations_no, -log(p_subs,10), -log(p_ind,10) )
    colnames(data.df) <- c("gene", "p_global", "mutations_no", "p_subs", "p_ind")
    
    ##### Calculate x and y axis rangeby adding 10% of the original range
    x_range <- c(0, max(data.df$mutations_no) + max(data.df$mutations_no)*0.1)
    y_range <- c(0, max(data.df$p_global) + max(data.df$p_global)*0.1)
    
    ##### Generate scatter-plot
    if ( dNdS_cov ) {
      widges.list[[i]] <- plot_ly(data.df, x = ~mutations_no, y = data.df$p_global, color = data.df$p_ind, size = data.df$p_subs, text = ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
        add_text(textfont = list(size = 10), textposition = "top") %>%
        layout(title = datasets.list[i], xaxis = list(title = "Number of mutations", range = x_range), yaxis = list(title = "-log10( p-value )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = FALSE, legend = list(orientation = "v", y = 0.9))
    } else {
      widges.list[[i]] <- plot_ly(data.df, x = ~mutations_no, y = data.df$p_global, color = data.df$p_subs, size = data.df$p_subs, text = ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
        add_text(textfont = list(size = 10), textposition = "top") %>%
        layout(title = datasets.list[i], xaxis = list(title = "Number of mutations", range = x_range), yaxis = list(title = "-log10( p-value )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = FALSE, legend = list(orientation = "v", y = 0.9))      
    }
    
    ##### Save the plot as html (PLOTLY)
    saveWidgetFix(as_widget(widges.list[[i]]), paste0(outDir, "/driver_analysis_dndscv_plot_", datasets.list[i], ".html"), selfcontained = TRUE)
    
  } else {
      cat(paste0("None of the mutated genes demonstrated significant global q-value in dataset ", datasets.list[i], "\n\n"))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

##### dNdSloc

*X-axis* indicates the *number of variants* observed in individual genes and *y-axis* illustrates *p-values* (in -log10 scale) based on all substitutions. The *size* of the points is proportional to -log10 *p-values* based exclusively on missense substitutions detected in individual genes.

```{r dndsloc_plot, comment = NA, message=FALSE, warning=FALSE}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( nrow(signif_genes_table.datasets[[i]]$dNdSloc) > 0 ) {
    
    ##### Avoid p-values of 0 by assigning 1*10^-16 to extremely low q-values
    p_all <- signif_genes_table.datasets[[i]]$dNdSloc$pall_loc
    p_all[ p_all == 0 ] <- 1*10^-16
    p_mis <- signif_genes_table.datasets[[i]]$dNdSloc$pmis_loc
    p_mis[ p_mis == 0 ] <- 1*10^-16
    
    ##### Sum up all mutations
    mutations_no <- rowSums(signif_genes_table.datasets[[i]]$dNdSloc[ , names(signif_genes_table.datasets[[i]]$dNdSloc) %in% c("n_syn", "n_mis", "n_non", "n_spl") ])
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(signif_genes_table.datasets[[i]]$dNdSloc$gene_name, -log(p_all,10), mutations_no, -log(p_mis,10) )
    colnames(data.df) <- c("gene", "p_all", "mutations_no", "p_mis")
    
    ##### Calculate x and y axis rangeby adding 10% of the original range
    x_range <- c(0, max(data.df$mutations_no) + max(data.df$mutations_no)*0.1)
    y_range <- c(0, max(data.df$p_all) + max(data.df$p_all)*0.1)
    
    ##### Generate scatter-plot
    widges.list[[i]] <- plot_ly(data.df, x = ~mutations_no, y = data.df$p_all, size = data.df$q_mis, text= ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
      add_text(textfont = list(size = 10), textposition = "top") %>%
      layout(title = datasets.list[i], xaxis = list(title = "Number of mutations", range = x_range), yaxis = list(title = "-log10( p-value )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE )
    
    ##### Save the plot as html (PLOTLY)
    saveWidgetFix(as_widget(widges.list[[i]]), paste0(outDir, "/driver_analysis_dndsloc_plot_", datasets.list[i], ".html"), selfcontained = TRUE)
  
  } else {
    cat(paste0("NOTE: none of the mutated genes demonstrated significant p-value/q-value in dataset ", datasets.list[i], "!\n\n"))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

#### Cancer driver genes {.tabset}

##### dNdScv

*P-values* for substitutions are obtained by *likelihood-ratio tests* as described in [Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"} and *q-values* are obtained by *Benjamini-Hodgbergs multiple testing correction*. The table(s) also include information on the number of substitutions of each class observed in each gene, as well as *maximum-likelihood estimates* (*MLEs*) of the *dN/dS ratios* for each gene, for **missense** (*wmis*), **nonsense** (*wnon*), essential **splice site** mutations (*wspl*) and **indels** (*wind*). The *global q-values* integrating all mutation types are available in the ***qglobal_cv*** and *qallsubs_cv* columns for analyses with and without indels, respectively.

```{r dndscv_results_summary, comment = NA, message=FALSE, warning=FALSE}
##### Present dndscv results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( params$ratios_ci) {
    
    if ( dNdS_cov ) {
      widges.list[[i]] <- DT::datatable( data = signif_genes_table.datasets[[i]]$dNdScv, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_table.datasets[[i]]$dNdScv), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
          DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$dNdScv), 'text-align' = 'center' ) %>%
    formatRound(columns = c("wmis_cv","wnon_cv", "wspl_cv", "wind_cv", "mis_mle", "tru_mle", "mis_low", "tru_low", "mis_high", "tru_high"), 1) %>%
    formatRound(columns = c("pglobal_cv", "qglobal_cv", "pmis_cv", "ptrunc_cv", "pallsubs_cv", "pind_cv", "qallsubs_cv", "pglobal_cv", "qglobal_cv"), 6)
    } else {
      widges.list[[i]] <- DT::datatable( data = signif_genes_table.datasets[[i]]$dNdScv, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_table.datasets[[i]]$dNdScv), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
          DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$dNdScv), 'text-align' = 'center' ) %>%
    formatRound(columns = c("wmis_cv","wnon_cv", "wspl_cv", "tru_mle", "mis_low", "tru_low", "mis_high", "tru_high"), 1) %>%
    formatRound(columns = c("pallsubs_cv", "qallsubs_cv", "pmis_cv", "ptrunc_cv"), 6)
    }
    
  } else {
    if ( dNdS_cov ) {
      widges.list[[i]] <- DT::datatable( data = signif_genes_table.datasets[[i]]$dNdScv, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_table.datasets[[i]]$dNdScv), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
            DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$dNdScv), 'text-align' = 'center' ) %>%
      formatRound(columns = c("wmis_cv", "wnon_cv", "wspl_cv", "wind_cv"), 1) %>%
      formatRound(columns = c("pglobal_cv", "qglobal_cv", "pmis_cv", "ptrunc_cv", "pallsubs_cv", "qallsubs_cv", "pind_cv"), 6)
    } else {
      widges.list[[i]] <- DT::datatable( data = signif_genes_table.datasets[[i]]$dNdScv, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_table.datasets[[i]]$dNdScv), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
          DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$dNdScv), 'text-align' = 'center' ) %>%
      formatRound(columns = c("wmis_cv", "wnon_cv", "wspl_cv"), 1) %>%
      formatRound(columns = c("pallsubs_cv", "qallsubs_cv", "pmis_cv", "ptrunc_cv"), 6)
    }
  }
}

##### Print a list of htmlwidgets
widges.list
```

<details>
<summary>Table legend</summary>
<font size="2">

* **syn** - synonymous mutations
* **mis** - missense mutations
* **non** - nonsense mutations
* **spl** - splice site mutations
* **trunc** - all truncating mutations together (including nonsense and splice site mutations)
* **ind** - indels
* **allsubs** - all mutation types without indels
* **global** - all mutation types including indels

</font> 
</details>

***

##### dNdSloc

*P-values* are obtained from per-gene neutrality tests performed using *traditional dN/dS model*, in which the local mutation rate for a gene is estimated exclusively from the synonymous mutations observed in individual genes ([Wong *et al*., 2014](https://www.ncbi.nlm.nih.gov/pubmed/24316979){target="_blank"}). *Q-values* are obtained by *Benjamini-Hodgbergs multiple testing correction*. The table(s) also include information on the number of substitutions of each class observed in each gene, as well as *maximum-likelihood estimates* (*MLEs*) of the *dN/dS ratios* for each gene, for **missense** (*wmis*), **nonsense** (*wnon*) and essential **splice site** mutations (*wspl*). The *q-values* integrating all mutation types are available in the ***qall_loc*** column.

```{r dndsloc_results_summary, comment = NA, message=FALSE, warning=FALSE}
##### Present dndscv results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = signif_genes_table.datasets[[i]]$dNdSloc, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_table.datasets[[i]]$dNdSloc), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$dNdSloc), 'text-align' = 'center' ) %>%
  formatRound(columns = c("wmis_loc", "wnon_loc", "wspl_loc"), 1) %>%
  formatRound(columns = c("pall_loc", "qall_loc", "pmis_loc", "qmis_loc"), 6)
}

##### Print a list of htmlwidgets
widges.list
```

<details>
<summary>Table legend</summary>
<font size="2">

* **syn** - synonymous mutations
* **mis** - missense mutations
* **non** - nonsense mutations
* **spl** - splice site mutations
* **all** - all mutation types

</font> 
</details>

***

#### Global dN/dS estimates

Table(s) presenting global *maximum-likelihood estimates* (*MLEs*) for the *dN/dS ratios* across all genes. dN/dS ratios with associated confidence intervals are calculated for **missense** (*wmis*), **nonsense** (*wnon*) and essential **splice site** substitutions (*wspl*) separately, as well as for **all non-synonymous** substitutions (*wall*) and for **all truncating** substitutions together (*wtru*), which include nonsense and essential splice site mutations.

<details>
<summary>What global dN/dS ratios indicate?</summary>

Global dN/dS ratios in somatic evolution of cancer, and seemingly of healthy somatic tissues, appear to show a near-universal pattern of **dN/dS ~1**, with exome-wide dN/dS ratios typically slightly higher than 1 ([Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"}). The global **dN/dS < 1** is typically caused by contamination of the catalogue of somatic mutations with germline SNPs. An exception are melanoma tumours, which show a bias towards slight underestimation of dN/dS due to the signature of ultraviolet-induced mutations extending beyond the trinucleotide model. The global **dN/dS << 1** reflects a problem of SNP contamination or an inadequate substitution model, and so the evaluation of global dN/dS values can help identify problems in certain datasets.

</details>

```{r global_dnds_estimates, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = globaldnds[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(globaldnds[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(globaldnds[[i]]), 'text-align' = 'center' ) %>%
    formatRound(columns = c("mle", "cilow", "cihigh"), 1) 
}

##### Print a list of htmlwidgets
widges.list
```

<details>
<summary>Table legend</summary>
<font size="2">

* **wmis** - global dN/dS ratios for missense mutations
* **wnon** - global dN/dS ratios for nonsense mutations
* **wspl** - global dN/dS ratios for splice site mutations
* **wtru** - global dN/dS ratios for all truncating mutations together (including nonsense and splice site mutations)
* **wall** - global dN/dS ratios for all non-synonymous mutation types

</font> 
</details>

`r if ( nrow(hypermut_samples[[i]]) > 0 ) { c("***") }`

`r if ( nrow(hypermut_samples[[i]]) > 0 ) { c("#### Hypermutators") }`

`r if ( nrow(hypermut_samples[[i]]) > 0 ) { c(paste0("Table(s) listing **ultra-hypermutator** samples with > ", params$hypermut_sample_cutoff, " mutations per gene in coding mutations. These have been removed from the analysis since hypermutator samples often reduce power to detect selection.")) }`

```{r hypermutators, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = hypermut_samples[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(exclmuts[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(hypermut_samples[[i]]), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

#### Subsampled mutations

Table(s) listing coding mutations within genes with > `r params$max_muts_per_gene` mutations per gene in same sample. These have been removed from the analysis to protect against loss of sensitivity from clustered artefacts.

```{r subsampled_mutations, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = exclmuts[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(exclmuts[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(exclmuts[[i]]), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### ActiveDriverWGS {.tabset}

Selection analyses and cancer driver discovery using [ActiveDriverWGS](https://github.com/reimandlab/ActiveDriverWGSR){target="_blank"} R package. It provides *maximum-likelihood dN/dS* methods designed to quantify selection in cancer and somatic evolution ([Zhu et al., 2020](https://pubmed.ncbi.nlm.nih.gov/31954095){target="_blank"}). [ActiveDriverWGS](https://github.com/reimandlab/ActiveDriverWGSR){target="_blank"} is a recurrence-based method which builds on the idea that driver mutations are subject to positive selection and should appear more frequently than expected by chance alone. This method analyzes the mutational burden of SNVs and short indels (less than 50bps) in functionally defined genomic elements.

***

`r if ( !is.null(ActiveDriverWGS.genes) ) { paste0("<details>") }`
`r if ( !is.null(ActiveDriverWGS.genes) ) { paste0("<summary>Analysed genes</summary>") }`
`r if ( !is.null(ActiveDriverWGS.genes) ) { paste0("<font size=\"2\">") }`

`r if ( !is.null(ActiveDriverWGS.genes) ) { ActiveDriverWGS.genes }`

`r if ( !is.null(ActiveDriverWGS.genes) ) { paste0("</font>") }`
`r if ( !is.null(ActiveDriverWGS.genes) ) { paste0("</details>") }`

<details>
<summary>Input parameters</summary>
<font size="2">

* Genome assembly version: **`r paste0("hg", params$ucsc_genome_assembly)`**
* Number of mutations per megabase define ultra-hypermutator samples: **`r params$hypermut_sample_cutoff/100`**
* P-value threshold for reporting cancer driver genes: **`r params$activedriverwgs_p`**
* False discovery rate (FDR) threshold for reporting cancer driver genes: **`r params$activedriverwgs_fdr`**

**Ultra-hypermutator samples** (with > `r params$hypermut_sample_cutoff/100` mutations) are excluded as hyper-mutated samples carry many passenger mutations and dilute the signal of true drivers.

</font> 
</details>

***

#### Plots

*X-axis* indicates the *number of variants* observed in individual genes and *y-axis* illustrates *global p-values* in -log10 scale. The *size* of the points is proportional to -log10 *p-values* based on all substitutions detected in individual genes. The *colour* scale reflects -log10 *False discovery rate* (FDR), with purple and yellow indicating low and high values, respectively.

```{r ActiveDriverWGS_plot, comment = NA, message=FALSE, warning=FALSE}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( nrow(signif_genes_table.datasets[[i]]$ActiveDriverWGS) > 0 ) {
      
    ##### Avoid p-values of 0 by assigning 1*10^-16 to extremely low p-values
    pp_element <- signif_genes_table.datasets[[i]]$ActiveDriverWGS$pp_element
    pp_element[ pp_element == 0 ] <- 1*10^-16
    fdr_element <- signif_genes_table.datasets[[i]]$ActiveDriverWGS$fdr_element
    fdr_element[ fdr_element == 0 ] <- 1*10^-16
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(signif_genes_table.datasets[[i]]$ActiveDriverWGS$id, -log(pp_element,10), signif_genes_table.datasets[[i]]$ActiveDriverWGS$element_muts_obs, -log(fdr_element,10) )
    colnames(data.df) <- c("gene", "pp_element", "element_muts_obs", "fdr_element")
    
    ##### Calculate x and y axis rangeby adding 10% of the original range
    x_range <- c(0, max(data.df$element_muts_obs) + max(data.df$element_muts_obs)*0.1)
    y_range <- c(0, max(data.df$pp_element) + max(data.df$pp_element)*0.1)
    
    ##### Generate scatter-plot
    widges.list[[i]] <- plot_ly(data.df, x = ~element_muts_obs, y = ~pp_element, color = data.df$fdr_element, size = ~pp_element, text = ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
      add_text(textfont = list(size = 10), textposition = "top") %>%
      layout(title = datasets.list[i], xaxis = list(title = "Number of mutations", range = x_range), yaxis = list(title = "-log10( p-value )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = FALSE, legend = list(orientation = "v", y = 0.9))
    
    ##### Save the plot as html (PLOTLY)
    saveWidgetFix(as_widget(widges.list[[i]]), paste0(outDir, "/driver_analysis_ActiveDriverWGS_plot_", datasets.list[i], ".html"), selfcontained = TRUE)
    
  } else {
      cat(paste0("None of the mutated genes demonstrated significant p-value in dataset ", datasets.list[i], "\n\n"))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

#### Cancer driver genes

Table(s) presenting per-dataset [ActiveDriverWGS](https://github.com/reimandlab/ActiveDriverWGSR){target="_blank"} results, including *p-values*, *false discovery rate (FDR)*, *number of mutations in individual samples*, as well as the *expected number of mutations in individual samples*.

```{r ActiveDriverWGS_results_summary, comment = NA, message=FALSE, warning=FALSE}
##### Present dndscv results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    widges.list[[i]] <- DT::datatable( data = signif_genes_table.datasets[[i]]$ActiveDriverWGS, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_table.datasets[[i]]$ActiveDriverWGS), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$ActiveDriverWGS), 'text-align' = 'center' ) %>%
      formatRound(columns = c("pp_element", "fdr_element"), 6)
}

##### Print a list of htmlwidgets
widges.list
```

<details>
<summary>Table legend</summary>
<font size="2">

* **pp_element** - the *p-value* associated with enrichment of mutations in the element
* **fdr_element** - *FDR* corrected *p-value* associated with the element
* **element_muts_obs** - number of patients with mutations in the element
* **element_muts_exp** - expected number of patients with mutations in the element

</font> 
</details>

***

### OncodriveClust {.tabset}

Cancer driver genes detection based on positional clustering using [OncodriveClust](http://bg.upf.edu/group/projects/oncodrive-clust.php){target="_blank"} algorithm is based on the fact that most of the variants in cancer causing genes are enriched at few specific loci (hot-spots). According to this concept mutations in these regions potentially change the function of these proteins in a manner that provides an adaptive advantage to cancer cells and consequently are positively selected during clonal evolution of tumours. This property can thus be used to nominate novel candidate driver genes, as described in the paper [OncodriveClust](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"} by [Tamborero *et al*, 2013](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"}.

<span style="color:#ff0000">NOTE</span>: **Only non-synonymous variants** are used for this analysis.

***

<details>
<summary>Variants consequence definitions</summary>
<font size="2">

* **Non-synonymous variants** are defined as variants with the following consequences: *`r paste(params$nonSyn_list, collapse = ", ")`*.
* **Silent variants** are defined as variants with the following consequences: *`r paste(silent_categories, collapse = ", ")`*.

</font> 
</details>

<details>
<summary>Input parameters</summary>
<font size="2">

* False discovery rate (FDR) threshold for reporting cancer driver genes: **`r params$oncodriveclust_fdr`**

</font> 
</details>

***

[OncodriveClust](https://bioconductor.org/packages/release/bioc/vignettes/maftools/inst/doc/maftools.html#92_detecting_cancer_driver_genes_based_on_positional_clustering){target="_blank"} results are **`r if ( runOncodriveClustChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

#### Plot

The *size* of the points on the scatter-plot(s) is proportional to the *number of clusters* found in individual genes. *X-axis* indicates the *number of variants* observed in these clusters and *y-axis* illustrates *false discovery rate* (FDR) in -log10 scale. The *colour* scale reflects *cluster scores*, with yellow and purple indicating high and low values, respectively. Cluster score of 1 means that a single hotspot hosts all observed variants.

```{r oncodriveCLUST_plot, comment = NA, message=FALSE, warning=FALSE, eval = runOncodriveClustChunk}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the field with AA change info is present in given MAF at all
  if ( length(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) != 0 ) {
    
    #### Check if the any of the mutated genes demonstrates significant cluster score
    if ( nrow(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) > 0 ) {
      
      ##### Avoid q-values of 0 by assigning 1*10^-16 to extremely low q-values
      oncodriveClust.res.table <- signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST
      fdr <- oncodriveClust.res.table$fdr
      fdr[ fdr == 0 ] <- 1*10^-16
      
      ##### Prepare data frame for plotting with plotly
      data.df <- data.frame(oncodriveClust.res.table$Hugo_Symbol, -log(fdr,10), oncodriveClust.res.table$muts_in_clusters, oncodriveClust.res.table$clusterScores, oncodriveClust.res.table$clusters )
      colnames(data.df) <- c("gene", "fdr", "mutations_no", "clusterScores", "clusters")
      
      ##### Calculate x and y axis rangeby adding 10% of the original range
      x_range <- c(0, max(data.df$mutations_no) + max(data.df$mutations_no)*0.1)
      y_range <- c(0, max(data.df$fdr) + max(data.df$fdr)*0.1)
      
      ##### Generate scatter-plot
      widges.list[[i]] <- plot_ly(data.df, x = ~mutations_no, y = data.df$fdr, color = data.df$clusterScores, size = data.df$clusters, text= ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
        add_text(textfont = list(size = 10), textposition = "top") %>%
        layout(title = datasets.list[i], xaxis = list(title = "Number of mutations in clusters", range = x_range), yaxis = list(title = "-log10( FDR )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = FALSE, legend = list(orientation = "v", y = 0.9))
      
      ##### Save the plot as html (PLOTLY)
      saveWidgetFix(as_widget(widges.list[[i]]), paste0(outDir, "/driver_analysis_oncodriveCLUST_plot_", datasets.list[i], ".html"), selfcontained = TRUE)
    
    } else {
      cat(paste("None of the mutated genes demonstrated significant cluster score in dataset", datasets.list[i], "\n\n", sep=" "))
      methods <- methods[ methods %!in% "OncodriveCLUST" ]
    }
  } else {
      cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

#### Cancer driver genes

Table(s) presenting per-dataset [OncodriveClust](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"} results, including *cluster scores*, *p-values*, *false discovery rate (FDR)*, *number of mutations in clusters*, as well as the *fraction of mutations in clusters*. Cluster score of 1 means that a single hotspot hosts all observed variants.

```{r oncodriveCLUST_table, comment=NA, warning=FALSE, eval = runOncodriveClustChunk}
##### Generate tables with oncodriveCLUST results
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the field with AA change info is present in given MAF at all
  if ( length(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) != 0 ) {
    
    #### Check if the any of the mutated genes demonstrates significant cluster score
    if ( nrow(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) > 0 ) {
      
      widges.list[[i]] <- DT::datatable(data = signif_genes_table.datasets[[i]]$OncodriveCLUST, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$OncodriveCLUST), 'text-align' = 'center' ) %>%
    formatRound(columns = c("clusterScores", "zscore", "fract_muts_in_clusters"), 1) %>%
    formatRound(columns = c("pval", "fdr"), 6)
      
    } else {
      cat(paste("None of the mutated genes demonstrated significant cluster score in dataset", datasets.list[i], "\n\n", sep=" "))
      runOncodriveClustChunk <- FALSE
    }
  } else {
    cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveFML {.tabset}

[OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} is a method designed to analyse the pattern of somatic mutations across tumours in both **coding and non-coding genomic regions** to identify signals of positive selection, and therefore, their involvement in tumorigenesis. The identification of protein coding genes, promoters, untranslated regions, intronic splice regions, and lncRNAs-containing driver mutations in several malignancies using [OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} is described by [Mularoni et al., 2016](https://www.ncbi.nlm.nih.gov/pubmed/27311963){target="_blank"}.

[OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} results are **`r if ( runOncodrivefmlChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

***

<details>
<summary>OncodriveFML settings</summary>
<font size="2">

`r if ( !is.null(oncodrivefml.conf) ) { c(gsub("],", "]: ", paste0(unlist(oncodrivefml.conf), collapse = ", "), perl = TRUE)) } else { c("OncodriveFML configuration file is not available.") }`

</font> 
</details>

<details>
<summary>Input parameters</summary>
<font size="2">

* P-value threshold for reporting cancer driver genes: **`r params$oncodrivefml_p`**
* Q-value threshold for reporting cancer driver genes: **`r params$oncodrivefml_q`**

</font> 
</details>

***

#### Plot {.tabset}

##### Interactive

[Q-Q plot](https://en.wikipedia.org/wiki/Q%E2%80%93Q_plot){target="_blank"} with *y-axis* presenting -log10 of the *computed p-values* and *x-axis* the -log10 of the *expected p-values* for cancer driver genes (`r paste(paste0("p-value < ", params$oncodrivefml_p), paste0("q-value < ", params$oncodrivefml_q), sep = ", ")`). The *size* of the points is proportional to *number of mutations* found in the dataset for individual genes. The *colour* scale reflects -log10 *q-values*, with black indicating genomic elements for which the number of mutated samples does not reach the minimum required to perform multiple test correction.

```{r oncodriveFML_plot_interactive_signif, comment = NA, message=FALSE, warning=FALSE, eval=runOncodrivefmlChunk}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( nrow(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML) > 0 ) {
    
    ##### Avoid q-values of 0 by assigning 1*10^-16 to extremely low q-values
    q_obs <- signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML$Q_VALUE
    q_obs[ q_obs == 0 ] <- 1*10^-16
    p_obs <- signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML$P_VALUE
    p_obs[ p_obs == 0 ] <- 1*10^-16
    p_exp <- signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML$P_VALUE_EXP
    p_exp[ p_exp == 0 ] <- 1*10^-16
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML$SYMBOL, -log10(q_obs), -log10(p_obs), -log10(p_exp), signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML$MUTS )
    colnames(data.df) <- c("gene", "q", "p_obs", "p_exp", "muts_no")
    
    ##### Calculate x and y axis rangeby adding 10% of the original range
    x_range <- c(min(data.df$p_exp) - min(data.df$p_exp)*0.1, max(data.df$p_exp) + max(data.df$p_exp)*0.1)
    y_range <- c(min(data.df$p_obs) - min(data.df$p_obs)*0.1, max(data.df$p_obs) + max(data.df$p_obs)*0.1)
    
    ##### Generate scatter-plot
    ##### Check if any of the significant genes have determined q-value
    if ( !all(is.na(data.df$q)) ) {
      
      widges.list[[i]] <- plot_ly(data.df, x = data.df$p_exp, y = data.df$p_obs, color = data.df$q, size = data.df$muts_no, text = ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
        add_text(textfont = list(size = 10), textposition = "top") %>%
        add_lines(y = c(seq(min(data.df$p_obs), min(c(max(data.df$p_obs), max(data.df$p_exp))), length.out=nrow(data.df))), x = c(seq(min(data.df$p_obs), min(c(max(data.df$p_obs), max(data.df$p_exp))), length.out=nrow(data.df))), line = list(color = "grey", dash = "dash"), showlegend = FALSE, data = NULL, inherit = FALSE) %>%
        layout(title = datasets.list[i], xaxis = list(title = "-log10( expected p-values )", range = x_range), yaxis = list(title = "-log10( observed p-values )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = FALSE, legend = list(orientation = "v", y = 0.9))
      
    } else {
      widges.list[[i]] <- plot_ly(data.df, x = data.df$p_exp, y = data.df$p_obs, size = data.df$muts_no, text = ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
        add_text(textfont = list(size = 10), textposition = "top") %>%
        add_lines(y = c(seq(min(data.df$p_obs), min(c(max(data.df$p_obs), max(data.df$p_exp))), length.out=nrow(data.df))), x = c(seq(min(data.df$p_obs), min(c(max(data.df$p_obs), max(data.df$p_exp))), length.out=nrow(data.df))), line = list(color = "grey", dash = "dash"), showlegend = FALSE, data = NULL, inherit = FALSE) %>%
        layout(title = datasets.list[i], xaxis = list(title = "-log10( expected p-values )", range = x_range), yaxis = list(title = "-log10( observed p-values )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE)
    }
  
  } else {
      cat(paste("None of the mutated genes demonstrated significant p- or q-value in dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

##### Static

[Q-Q plot](https://en.wikipedia.org/wiki/Q%E2%80%93Q_plot){target="_blank"} with *y-axis* presenting -log10 of the *computed p-values* and *x-axis* the -log10 of the *expected p-values*. The genomic elements that have a lighter colour are the ones for which the number of mutated samples does not reach the minimum required to perform multiple test correction. All genomic regions above the red line are annotated and represent those with *Q-value* below *0.1*. The ones between the <span style="color:#329457">green</span> line and the <span style="color:#ff0000">red</span> line are the ones with a *Q-value* between *0.25* and *0.1*.

<span style="color:#ff0000">NOTE</span>, in case of very long list of detected driver genes only 50 with the most significant *computed p-values* are indicated on the Q-Q plot (check table in the *Cancer driver genes* tab to see the full list).

```{r oncodriveFML_plot_static, comment = NA, message=FALSE, warning=FALSE, results="asis", eval=runOncodrivefmlChunk}
for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the OncodriveFML results plot (HTML) exists
  if ( file.exists(paste0(oncodriveFML.res[i], ".png")) ) {
    
    ##### Read in the oncodriveFML PNG files
    cat(paste("\n\n <b>", datasets.list[i], "</b> \n\n", sep=" "))
    cat("![](",paste(paste0(oncodriveFML.res[i], ".png")),")")
    cat("<br/><br/><br/>")

    ##### Copy the OncodriveFML results plot (HTML and PNG) to the report folder
    file.copy(paste0(oncodriveFML.res[i], ".png"), paste0(outDir, "/driver_analysis_oncodriveFML_plot_", datasets.list[i], ".png"), overwrite = TRUE, copy.mode = TRUE, copy.date = FALSE)
    file.copy(paste0(oncodriveFML.res[i], ".html"), paste0(outDir, "/driver_analysis_oncodriveFML_plot_", datasets.list[i], ".html"), overwrite = TRUE, copy.mode = TRUE, copy.date = FALSE)
    
  } else {
    cat(paste("OncodriveFML results plot \"", paste0(oncodriveFML.res[i], ".png"), "\" is not present for dataset", datasets.list[i], "\n\n", sep=" "))
  }
}
```

***

#### Cancer driver genes

Table(s) presenting per-dataset [OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} results, including *p-values*, *q-values*, as well as the *number of mutations* that are *SNPs*, multi nucleotide polymorphisms (*MNPs*) and insertions or deletions (*INDELS*).

```{r oncodriveFML_table, comment=NA, warning=FALSE, eval=runOncodrivefmlChunk}
##### Generate tables with oncodriveFML results
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the OncodriveFML results plot (HTML) exists
  if ( nrow(signif_genes_table.datasets[[i]]$OncodriveFML) > 0 ) {
    
    widges.list[[i]] <- DT::datatable(data = signif_genes_table.datasets[[i]]$OncodriveFML, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$OncodriveFML), 'text-align' = 'center' ) %>%
  formatRound(columns = c("P_VALUE", "P_VALUE_EXP", "Q_VALUE", "P_VALUE_NEG", "Q_VALUE_NEG"), 6)
  } else {
    cat(paste("OncodriveFML results table \"", paste0(oncodriveFML.res[i], ".tsv"), "\" is not present for dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

<details>
<summary>Table legend</summary>
<font size="2">

* **MUTS** - number of mutations found in the dataset for that gene
* **MUTS_RECURRENCE** - number of mutations that do not occur in the same position
* **SAMPLES** - number of mutated samples in the gene
* **P_VALUE** - times that the observed value is higher than or equal to the expected value, divided by the number of randomisations
* **P_VALUE_EXP** - expected *P_VALUE*
* **Q_VALUE** - *P_VALUE* corrected using the *Benjamini-Hochberg* correction (for samples with at least 2 samples)
* **P_VALUE_NEG** - times that the observed value is lower than or equal to the expected value, divided by the number of randomisations
* **Q_VALUE_NEG** - *P_VALUE_NEG* corrected using the *Benjamini-Hochberg* correction (for samples with at least 2 samples)

</font> 
</details>

***

### CGI {.tabset}

[Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org){target="_blank"} (CGI) is a method able to flag validated oncogenic alterations and predict cancer drivers among mutations of unknown significance (see paper by [Tamborero et al., 2018](https://www.ncbi.nlm.nih.gov/pubmed/29592813)). Additionally, it flags genomic biomarkers of drug response with different levels of clinical relevance.

[CGI](https://www.cancergenomeinterpreter.org){target="_blank"} results are **`r if ( runcgiChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

#### Plot

Scatter-plot with *y-axis* presenting [CADD scores](https://asia.ensembl.org/info/genome/variation/prediction/protein_function.html){target="_blank"} and *x-axis* the alteraions freuqnecy of individual genes across samples. The *colour* indicates the consequence of corresponding alterations.

```{r CGI_plot, comment = NA, message=FALSE, warning=FALSE, eval=runcgiChunk}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( nrow(signif_genes_table.datasets[[datasets.list[i]]]$CGI) > 0 ) {
    
    samples <- signif_genes_table.datasets[[datasets.list[i]]]$CGI$sample
    freq <- table(as.vector(signif_genes_table.datasets[[datasets.list[i]]]$CGI$gene))
    freq <- freq[ as.vector(signif_genes_table.datasets[[datasets.list[i]]]$CGI$gene) ] 
    deleterious <- signif_genes_table.datasets[[datasets.list[i]]]$CGI$deleteriuos
    names(deleterious) <- signif_genes_table.datasets[[datasets.list[i]]]$CGI$gene
    consequence <- as.vector(signif_genes_table.datasets[[datasets.list[i]]]$CGI$consequence)
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(samples, freq, deleterious, consequence )
    colnames(data.df) <- c("Sample", "Gene","Frequency", "Deleterious", "Consequence")
    
    ##### Generate scatter-plot
    widges.list[[i]] <- plot_ly(data.df, x = ~Frequency, y = ~Deleterious, text = paste0("Gene: ", data.df$Gene,  "\nSample: ", data.df$Sample), color = ~Consequence, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 600) %>%
        add_annotations(x = ~Frequency, y = ~Deleterious, text = ~Gene, showarrow = FALSE, font = list(color = "grey", size = 9)) %>%
        layout(title = datasets.list[i], yaxis = list(title = "CADD score (deleteriousness)"), xaxis = list(title = "Frequency"), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = TRUE, legend = list(orientation = "v", y = 0.9))
    
  } else {
      cat(paste("None of the mutated genes were annotated as cancer driver genes in dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

#### Cancer driver genes

Table(s) presenting per-dataset [CGI](https://www.cancergenomeinterpreter.org){target="_blank"} annotations of validated oncogenic alterations and cancer driver genes.

```{r CGI_table, comment=NA, warning=FALSE, eval=runcgiChunk}
##### Generate tables with CGI results
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the CGI results plot (HTML) exists
  if ( nrow(signif_genes_table.datasets[[i]]$CGI) > 0 ) {
    
    ##### Define colours for CADD scores
    brks <- quantile(signif_genes_table.datasets[[i]]$CGI$deleteriuos, probs = seq(.05, .95, .05), na.rm = TRUE)
    clrs <- round(seq(255, 40, length.out = length(brks) + 1), 0) %>%
        {paste0("rgb(255,", ., ",", ., ")")}
  
    ##### Attach links to Gene cards
    CGI.table <- signif_genes_table.datasets[[i]]$CGI
    CGI.table$gene <- paste0("<a href='https://www.genecards.org/cgi-bin/carddisp.pl?gene=", CGI.table$gene, "' target='_blank'>", CGI.table$gene, "</a>")
    
    widges.list[[i]] <- DT::datatable(data = CGI.table, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 0), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(CGI.table), 'text-align' = 'center' ) %>%
      DT::formatStyle(columns = "deleteriuos", 
                      backgroundColor = DT::styleInterval(brks, clrs)) %>%
      DT::formatStyle( columns = "oncogenic classification", color = "green")
    
  } else {
    cat(paste("CGI results table \"", paste0(cgi.res[i], "/mutation_analysis.tsv"), "\" is not present for dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

<details>
<summary>Table legend</summary>
<font size="2">

* **oncogenic classifiaction** - oncogenic potential of the mutation
* **location** - location of the mutation in realtion to the last exon of the gene
* **tumour driver** - the gene has been identified as a driver of cancer
* **deleterious** -  [CADD](https://asia.ensembl.org/info/genome/variation/prediction/protein_function.html){target="_blank"} deleteriouslness score

</font> 
</details>

***

#### Prescriptions {.tabset}

##### Biomarkers

Table(s) presenting per-dataset [CGI](https://www.cancergenomeinterpreter.org){target="_blank"}-annotated alterations described as biomarkers for the selected tumor type `r if ( runcgiChunk ) { paste0("(", cancer_type.cgi, ").") } else { c(".") }`

```{r CGI_table_Biomarkers, comment=NA, warning=FALSE, eval=runcgiChunk}
##### Generate tables with CGI results
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the CGI results plot (HTML) exists
  if ( nrow(cgi.drug_pres.table[[i]]) > 0 ) {

    widges.list[[i]] <- DT::datatable(data = cgi.drug_pres.table[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 0), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(cgi.drug_pres.table[[i]]), 'text-align' = 'center' ) %>%
      DT::formatStyle( columns = "EFFECT", 
                      backgroundColor = DT::styleEqual(c("Responsive", "No Responsive", "Resistant"), c("lightgreen", "red", "red"))) %>%
      DT::formatStyle( columns = "EVIDENCE", color = DT::styleEqual(c("Early trials", "Pre-clinical"), c("green", "blue"))) %>%
      DT::formatStyle( columns = "ALTERATION", color = "green")

  } else {
    cat(paste("CGI results table \"", paste0(cgi.res[i], "/drug_prescription.tsv"), "\" is not present for dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

<details>
<summary>Table legend</summary>
<font size="2">

* **ALTERATION** - alterations observed in genes described to affect the response to a drug
* **DRUG** - drugs influenced by the biomarker
* **EFFECT** - how the presence of the biomarker affects the response to the drug
* **RESISTANCE_TYPE** -  co-occurring alteraion that confers to the same drug
* **EVIDENCE** -  the level of evidence that supports the described biomarker

</font> 
</details>

***

##### Bioactivities

Table(s) presenting per-dataset [CGI](https://www.cancergenomeinterpreter.org){target="_blank"}-annotated gene-compound interactions.

```{r CGI_table_Bioactivities, comment=NA, warning=FALSE, eval=runcgiChunk}
##### Generate tables with CGI results
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the CGI results plot (HTML) exists
  if ( nrow(cgi.drug_pres_bio.table[[i]]) > 0 ) {

    ##### Attach links to ChEMBL
    cgi.drug_pres_bio.table[[i]]$MOLECULE_NAME <- paste0("<a href='https://www.ebi.ac.uk/chembl/compound_report_card/", cgi.drug_pres_bio.table[[i]]$MOLECULE_NAME, "' target='_blank'>", cgi.drug_pres_bio.table[[i]]$MOLECULE_NAME, "</a>")
  
    widges.list[[i]] <- DT::datatable(data = cgi.drug_pres_bio.table[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 0), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(cgi.drug_pres_bio.table[[i]]), 'text-align' = 'center' ) %>%
      DT::formatStyle( columns = "ALTERATION", color = "green") %>%
      DT::formatRound(columns = c("BINDING P-ACTIVITY"), 2)

  } else {
    cat(paste("CGI results table \"", paste0(cgi.res[i], "/drug_prescription_bioactivities.tsv"), "\" is not present for dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

<details>
<summary>Table legend</summary>
<font size="2">

* **COMPOUND** - compound interacting with the gene bearing driver alterations
* **BINDING POTENCY** - potency of binding between the compound and the altered gene label
* **MOA** - compound mechanism of action
* **BINDING P-ACTIVITY** -  median binding p-activity value
* **TYPE** -  compound molecule type
* **TYPE** -  compound clinical status of approval

</font> 
</details>

***

## Mutation maps {.tabset .tabset-fade}

Lollipop plot(s) showing mutation spots on protein structure for driver genes detected by the following methods: **`r paste(methods, collapse = ", ")`**. Many oncogenes have a preferential sites which are mutated more often than any other locus. These spots are considered to be mutational hot-spots and lollipop plots can be used to display them along with rest of the mutations. <span style="color:#ff0000">NOTE</span>, that lollipop plot(s) are generated for MAF files containing field with amino acid changes details. The longest transcript is used if multiple transcripts are available.

```{r pchange_field_check, comment = NA, message=FALSE, warning=FALSE}
##### Check if the protein change field is present in any of the MAFs
pchangeStatus <- FALSE

for ( i in 1:length(mafFiles) ) {
  pchange = c('HGVSp_Short', 'Protein_Change', 'AAChange')
        
  ##### Define the column with protein change info
  pchange = pchange[pchange %in% colnames(mafInfo[[i]]@data)]
  
  ##### Check if the protein change field is not empty
  if ( any(!is.na(as.data.frame(mafInfo[[i]]@data)[ , pchange  ]))  ) {
    pchangeStatus <- TRUE
    
    ##### Create directory for pdf files
    mutationMapsDir <- paste0(normalizePath(outDir), "/", "MAF_mutation_maps")
    
    if ( !file.exists(mutationMapsDir) ){
      dir.create(mutationMapsDir, recursive=TRUE)
    }
  }
}
```

```{r prot_structre, comment = NA, message=FALSE, warning=FALSE, eval=pchangeStatus}
##### Get list of proteins for which structure is available within maftools
gff = system.file('extdata', 'protein_domains.RDs', package = 'maftools')
gff = readRDS(file = gff)
```

### dNdScv {.tabset}

```{r lollipop_plots_dNdScv, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Generate lollipop plot for each dataset for top mutated genes
if ( pchangeStatus ) {
  
  output_plot <- list()
  genes <- unique(verify_genes(unlist(signif_genes.methods$dNdScv)))
  
  for( i in 1:length(genes) ){
    cat("\n#### ", genes[i], "\n")
    if ( nrow(gff[HGNC %in% genes[i]]) != 0 ) {
      try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = genes[i]), silent = TRUE)
      cat("\n\n***\n")
    } else {
      cat(paste("The protein structure for protein encoded by", unlist(signif_genes.methods$dNdScv)[i], "is not available\n\n", sep=" "))
      cat("\n***\n")
    }
  }
  
  ##### Clean the space
  rm(list = ls(pattern='^output*'))

} else {
  cat("\n***\n")
  cat("\nThis section was skipped since the field with **amino acid changes details** in provided MAF(s) is **NOT AVAILABLE**!\n")
  cat("\n***\n")
}
```

### dNdSloc {.tabset}

```{r lollipop_plots_dNdSloc, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Generate lollipop plot for each dataset for top mutated genes
if ( pchangeStatus ) {
  
  output_plot <- list()
  genes <- unique(verify_genes(unlist(signif_genes.methods$dNdSloc)))
  
  for( i in 1:length(genes) ){
    cat("\n#### ", verify_genes(genes)[i], "\n")
    if ( nrow(gff[HGNC %in% genes[i]]) != 0 ) {
      try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = genes[i]), silent = TRUE)
      cat("\n\n***\n")
    } else {
      cat(paste("The protein structure for protein encoded by", unlist(signif_genes.methods$dNdSloc)[i], "is not available\n\n", sep=" "))
      cat("\n***\n")
    }
  }
  
  ##### Clean the space
  rm(list = ls(pattern='^output*'))

} else {
  cat("\n***\n")
  cat("\nThis section was skipped since the field with **amino acid changes details** in provided MAF(s) is **NOT AVAILABLE**!\n")
  cat("\n***\n")
}
```

***

### ActiveDriverWGS {.tabset}

```{r lollipop_plots_ActiveDriverWGS, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Generate lollipop plot for each dataset for top mutated genes
if ( pchangeStatus ) {
  
  output_plot <- list()
  genes <- unique(verify_genes(unlist(signif_genes.methods$ActiveDriverWGS)))
  
  for( i in 1:length(genes) ){
    cat("\n#### ", genes[i], "\n")
    if ( nrow(gff[HGNC %in% genes[i]]) != 0 ) {
      try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = genes[i]), silent = TRUE)
      cat("\n\n***\n")
    } else {
      cat(paste("The protein structure for protein encoded by", unlist(signif_genes.methods$ActiveDriverWGS)[i], "is not available\n\n", sep=" "))
      cat("\n***\n")
    }
  }
  
  ##### Clean the space
  rm(list = ls(pattern='^output*'))

} else {
  cat("\n***\n")
  cat("\nThis section was skipped since the field with **amino acid changes details** in provided MAF(s) is **NOT AVAILABLE**!\n")
  cat("\n***\n")
}
```

***

`r if ( runOncodriveClustChunk ) { c("### OncodriveCLUST {.tabset}") } else { c(" ") }`

```{r lollipop_plots_OncodriveCLUST, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, results="asis", eval = runOncodriveClustChunk}
##### Generate lollipop plot for each dataset for top mutated genes
if ( pchangeStatus ) {
  
  output_plot <- list()
  genes <- unique(verify_genes(unlist(signif_genes.methods$OncodriveCLUST)))
  
  for( i in 1:length(genes) ){
    cat("\n#### ", genes[i], "\n")
    if ( nrow(gff[HGNC %in% genes[i]]) != 0 ) {
      try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = genes[i]), silent = TRUE)
      cat("\n\n***\n")
    } else {
      cat(paste("The protein structure for protein encoded by", unlist(signif_genes.methods$OncodriveCLUST)[i], "is not available\n\n", sep=" "))
      cat("\n***\n")
    }
  }
  
  ##### Clean the space
  rm(list = ls(pattern='^output*'))

} else {
  cat("\n***\n")
  cat("\nThis section was skipped since the field with **amino acid changes details** in provided MAF(s) is **NOT AVAILABLE**!\n")
  cat("\n***\n")
}
```

`r if ( runOncodrivefmlChunk ) { c("### OncodriveFML {.tabset}") } else { c(" ") }`

```{r lollipop_plots_OncodriveFML, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, results="asis", eval = runOncodrivefmlChunk}
##### Generate lollipop plot for each dataset for top mutated genes
if ( pchangeStatus ) {
  
  output_plot <- list()
  genes <- unique(verify_genes(unlist(signif_genes.methods$OncodriveFML)))
  
  for( i in 1:length(genes) ){
    cat("\n#### ", genes[i], "\n")
    if ( nrow(gff[HGNC %in% genes[i]]) != 0 ) {
      try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = genes[i]), silent = TRUE)
      cat("\n\n***\n")
    } else {
      cat(paste("The protein structure for protein encoded by", unlist(signif_genes.methods$OncodriveFML)[i], "is not available\n\n", sep=" "))
      cat("\n***\n")
    }
  }
  
  ##### Clean the space
  rm(list = ls(pattern='^output*'))

} else {
  cat("\n***\n")
  cat("\nThis section was skipped since the field with **amino acid changes details** in provided MAF(s) is **NOT AVAILABLE**!\n")
  cat("\n***\n")
}
```

`r if ( runcgiChunk ) { c("### CGI {.tabset}") } else { c(" ") }`

```{r lollipop_plots_CGI, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, results="asis", eval = runcgiChunk}
##### Generate lollipop plot for each dataset for top mutated genes
if ( pchangeStatus ) {
  
  output_plot <- list()
  genes <- unique(verify_genes(unlist(signif_genes.methods$CGI)))
  
  for( i in 1:length(genes) ){
    cat("\n#### ", genes[i], "\n")
    if ( nrow(gff[HGNC %in% genes[i]]) != 0 ) {
      try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = genes[i]), silent = TRUE)
      cat("\n\n***\n")
    } else {
      cat(paste("The protein structure for protein encoded by", unlist(signif_genes.methods$CGI)[i], "is not available\n\n", sep=" "))
      cat("\n***\n")
    }
  }
  
  ##### Clean the space
  rm(list = ls(pattern='^output*'))

} else {
  cat("\n***\n")
  cat("\nThis section was skipped since the field with **amino acid changes details** in provided MAF(s) is **NOT AVAILABLE**!\n")
  cat("\n***\n")
}
```

## Mutations annotation {.tabset}

Table(s) with detailed annotation of **coding mutations** (detected by the following methods: **`r paste(methods, collapse = ", ")`**) in affected samples.

<span style="color:#ff0000">NOTE</span>: mutations detected in non-coding genomic regions, e.g. those shortlisted by *OncodriveFML*, are not listed in the table(s) below.

### dNdScv

```{r mutations_annotation_dNdScv, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$dNdScv[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### dNdSloc

```{r mutations_annotation_dNdSloc, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$dNdSloc[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### ActiveDriverWGS

```{r mutations_annotation_ActiveDriverWGS, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$ActiveDriverWGS[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( runOncodriveClustChunk ) { c("***") } else { c(" ") }`

`r if ( runOncodriveClustChunk ) { c("### OncodriveCLUST") } else { c(" ") }`

```{r mutations_annotation_OncodriveCLUST, comment = NA, message=FALSE, warning=FALSE, eval = runOncodriveClustChunk}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) != 0 ) {
    
    annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$OncodriveCLUST[[i]], ]
  
    ##### Move gene name to the first column
    col_idx <- grep("gene", names(annotmuts))
    annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
    
    widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
  
  } else {
    cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( runOncodrivefmlChunk ) { c("***") } else { c(" ") }`

`r if ( runOncodrivefmlChunk ) { c("### OncodriveFML") } else { c(" ") }`

```{r mutations_annotation_OncodriveFML, comment = NA, message=FALSE, warning=FALSE, eval=runOncodrivefmlChunk}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$OncodriveFML[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( runcgiChunk ) { c("***") } else { c(" ") }`

`r if ( runcgiChunk ) { c("### CGI") } else { c(" ") }`

```{r mutations_annotation_CGI, comment = NA, message=FALSE, warning=FALSE, eval=runcgiChunk}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$CGI[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

## Mutation details {.tabset .tabset-fade}

Tables with detailed variant's information in affected samples, as as provided in corresponding MAF file(s), for cancer driver genes detected by the following methods: **`r paste(methods, collapse = ", ")`**.

<details>
<summary>Variants consequence definitions</summary>
<font size="2">

* **Non-synonymous variants** are defined as variants with the following consequences: *`r paste(params$nonSyn_list, collapse = ", ")`*.
* **Silent variants** are defined as variants with the following consequences: *`r paste(silent_categories, collapse = ", ")`*.

</font> 
</details>

### dNdScv {.tabset .tabset-fade}

#### Non-synonymous

```{r details_mut_dNdScv_nonsynon, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$dNdScv[[i]], type = "nonsynonymous")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

#### Silent

```{r details_mut_dNdScv_silent, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$dNdScv[[i]], type = "silent")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### dNdSloc {.tabset .tabset-fade}

#### Non-synonymous

```{r details_mut_dNdSloc_nonsynon, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$dNdSloc[[i]], type = "nonsynonymous")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

#### Silent

```{r details_mut_dNdSloc_silent, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$dNdSloc[[i]], type = "silent")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### ActiveDriverWGS {.tabset .tabset-fade}

#### Non-synonymous

```{r details_mut_ActiveDriverWGS_nonsynon, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$ActiveDriverWGS[[i]], type = "nonsynonymous")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

#### Silent

```{r details_mut_ActiveDriverWGS_silent, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$ActiveDriverWGS[[i]], type = "silent")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( runOncodriveClustChunk ) { c("***") } else { c(" ") }`

`r if ( runOncodriveClustChunk ) { c("### OncodriveCLUST {.tabset .tabset-fade}") } else { c(" ") }`

`r if ( runOncodriveClustChunk ) { c("#### Non-synonymous") } else { c(" ") }`

```{r details_mut_OncodriveCLUST_nonsynon, comment = NA, message=FALSE, warning=FALSE, eval = runOncodriveClustChunk}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) != 0 ) {
    widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$OncodriveCLUST[[i]], type = "nonsynonymous")
  } else {
    cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( runOncodriveClustChunk ) { c("***") } else { c(" ") }`

`r if ( runOncodriveClustChunk ) { c("#### Silent") } else { c(" ") }`

```{r details_mut_OncodriveCLUST_silent, comment = NA, message=FALSE, warning=FALSE, eval = runOncodriveClustChunk}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) != 0 ) {
    widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$OncodriveCLUST[[i]], type = "silent")
  } else {
    cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( runOncodrivefmlChunk ) { c("***") } else { c(" ") }`

`r if ( runOncodrivefmlChunk ) { c("### OncodriveFML {.tabset .tabset-fade}") } else { c(" ") }`

`r if ( runOncodrivefmlChunk ) { c("#### Non-synonymous") } else { c(" ") }`

```{r details_mut_OncodriveFML_nonsynon, comment = NA, message=FALSE, warning=FALSE, eval = runOncodrivefmlChunk}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$OncodriveFML[[i]], type = "nonsynonymous")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( runOncodrivefmlChunk ) { c("***") } else { c(" ") }`

`r if ( runOncodrivefmlChunk ) { c("#### Silent") } else { c(" ") }`

```{r details_mut_OncodriveFML_silent, comment = NA, message=FALSE, warning=FALSE, eval = runOncodrivefmlChunk}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$OncodriveFML[[i]], type = "silent")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( runcgiChunk ) { c("***") } else { c(" ") }`

`r if ( runcgiChunk ) { c("### CGI {.tabset .tabset-fade}") } else { c(" ") }`

`r if ( runcgiChunk ) { c("#### Non-synonymous") } else { c(" ") }`

```{r details_mut_CGI_nonsynon, comment = NA, message=FALSE, warning=FALSE, eval = runcgiChunk}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$CGI[[i]], type = "nonsynonymous")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( runcgiChunk ) { c("***") } else { c(" ") }`

`r if ( runcgiChunk ) { c("#### Silent") } else { c(" ") }`

```{r details_mut_CGI_silent, comment = NA, message=FALSE, warning=FALSE, eval = runcgiChunk}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$CGI[[i]], type = "silent")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

## Summary {.tabset}

### Per-gene summary table

Table presenting cancer driver genes (rows) detected by the following methods (*columns*): **`r paste(methods, collapse = ", ")`**.

```{r driver_genes_summary_table, comment = NA, message=FALSE, warning=FALSE}
##### Presnet the intersections between cancer driver genes detected by various methods
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  if ( length(signif_genes[[i]]) > 0 ) {
    
    ##### Attach links to Gene cards
    rownames(signif_genes.upset.mod[[i]]) <- paste0("<a href='https://www.genecards.org/cgi-bin/carddisp.pl?gene=", rownames(signif_genes.upset.mod[[i]]), "' target='_blank'>", rownames(signif_genes.upset.mod[[i]]), "</a>")
  
    ##### Generate a table
    widges.list[[i]] <- DT::datatable( data = signif_genes.upset.mod[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", rownames = TRUE, extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 1), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = colnames(signif_genes.upset.mod[[i]]), `font-size` = '12px', 'text-align' = 'center' ) %>%
      
      ##### Colour cells according to evidence level and trust rating
      DT::formatStyle(columns = colnames(signif_genes.upset.mod[[i]])[-c(length(signif_genes.upset.mod[[i]]))], 
                      backgroundColor = DT::styleEqual(c("No", "Yes"), c("transparent", "black")), color = DT::styleEqual(c("No", "Yes"), c("black", "white")))
    
  } else {
    cat(paste("None cancer driver gene have been detected by either method in dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### Circos plot

Circos plot showing human chromosome (human genome reference build hg`r params$ucsc_genome_assembly`) ideogram with the cancer driver genes detected by the following methods (*columns*): **`r paste(methods, collapse = ", ")`**.

```{r circos_prep, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Prepare circos plot with cancer driver genes detected by various methods
signif_genes.excl <- vector("list", length(mafFiles))
names(signif_genes.excl) <- datasets.list

signif_genes.standard <- vector("list", length(mafFiles))
names(signif_genes.standard) <- datasets.list

signif_genes.excess <- vector("list", length(mafFiles))
names(signif_genes.excess) <- datasets.list

signif_genes.plotted <- vector("list", length(mafFiles))
names(signif_genes.plotted) <- datasets.list

signif_genes.incl <- vector("list", length(mafFiles))
names(signif_genes.incl) <- datasets.list

signif_genes.all<- vector("list", length(mafFiles))
names(signif_genes.all) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes[[i]]) > 0 ) {
    eval(parse( text=paste0("data(UCSC.HG", params$ucsc_genome_assembly, ".Human.CytoBandIdeogram)")))
    cyto.info <- eval(parse( text=paste0("UCSC.HG", params$ucsc_genome_assembly, ".Human.CytoBandIdeogram")))
    
    ##### Check if all driver genes are located in standard chromosomes
    signif_genes.excl[[i]] <- signif_genes.annot[[i]][ signif_genes.annot[[i]]$Chromosome %!in% cyto.info$Chromosome,  ]
    signif_genes.standard[[i]] <- signif_genes.annot[[i]][ signif_genes.annot[[i]]$Chromosome %in% cyto.info$Chromosome,  ]
    
    ##### There is a limit of number of gene labels on the circos plot so select only so of the detected driver genes to meet these limits in case there are more driver genes than allowed on the plot
    ##### Define number of allowed genes in each chromosome
    signif_genes.chr <- c(paste0("chr", rep(1:22)), "chrX", "chrY")
    signif_genes.chr_max <- c(16,16,13,12,12,11,10,9,9,8,9,8,7,7,6,6,5,5,3,4,3,3,10,3)
    
    ##### Loop through each chromosome
    for (j in 1:24) {
      if ( nrow(signif_genes.standard[[i]][ signif_genes.standard[[i]]$Chromosome == signif_genes.chr[j] , ]) > signif_genes.chr_max[j] ) {
        
        ##### Record driver genes that will NOT be plotted
        signif_genes.excess[[i]] <- paste0(signif_genes.excess[[i]], "<br><b>", signif_genes.chr[j], "</b>: ", paste0( signif_genes.standard[[i]]$Gene[ signif_genes.standard[[i]]$Chromosome == signif_genes.chr[j] ][(signif_genes.chr_max[j]+1):nrow(signif_genes.standard[[i]][ signif_genes.standard[[i]]$Chromosome == signif_genes.chr[j] , ])], collapse = ", "))
        
        ##### Record driver genes that will be plotted
        signif_genes.plotted[[i]] <- paste0(signif_genes.plotted[[i]], "<br><b>", signif_genes.chr[j], "</b>: ", paste0( signif_genes.standard[[i]]$Gene[ signif_genes.standard[[i]]$Chromosome == signif_genes.chr[j] ][1:signif_genes.chr_max[j]], collapse = ", "))
        signif_genes.incl[[i]] <- rbind(signif_genes.incl[[i]], signif_genes.standard[[i]][ signif_genes.standard[[i]]$Chromosome == signif_genes.chr[j] , ][1:signif_genes.chr_max[j],])
        
      } else if ( length(signif_genes.standard[[i]][ signif_genes.standard[[i]]$Chromosome == signif_genes.chr[j] , ]$Gene) > 0 ) {
        ##### Record driver genes that will be plotted
        signif_genes.plotted[[i]] <- paste0(signif_genes.plotted[[i]], "<br><b>", signif_genes.chr[j], "</b>: ", paste0( signif_genes.standard[[i]]$Gene[ signif_genes.standard[[i]]$Chromosome == signif_genes.chr[j] ], collapse = ", "))
        signif_genes.incl[[i]] <- rbind(signif_genes.incl[[i]], signif_genes.standard[[i]][ signif_genes.standard[[i]]$Chromosome == signif_genes.chr[j] , ])
      }
      
      ##### Record all driver genes
      if ( length(signif_genes.standard[[i]][ signif_genes.standard[[i]]$Chromosome == signif_genes.chr[j] , ]$Gene) > 0 ) {
        signif_genes.all[[i]] <- paste0(signif_genes.all[[i]], "<br><b>", signif_genes.chr[j], "</b> : ", paste0( signif_genes.standard[[i]]$Gene[ signif_genes.standard[[i]]$Chromosome == signif_genes.chr[j] ], collapse = ", "))
      }
    }
        
    if ( nrow(signif_genes.incl[[i]]) > 100 ) {
      tracks.inside <- 8
      pointsize <- 22
    } else if ( nrow(signif_genes.incl[[i]]) > 50 ) {
      tracks.inside <- 6
      pointsize <- 20
    } else {
      tracks.inside <- 4
      pointsize <- 18
    }
    
    RCircos.Set.Core.Components( cyto.info=cyto.info, chr.exclude=NULL, tracks.inside=tracks.inside, tracks.outside=0)
    
    ##### Save circos into a pdf file
    pdf(file = paste(outDir, "/driver_analysis_circos_", datasets.list[i], ".pdf", sep = ""), height = 14, width = 14, pointsize = 18) 
    
    RCircos.Set.Plot.Area()  
    RCircos.Chromosome.Ideogram.Plot()
    RCircos.Gene.Connector.Plot(genomic.data = signif_genes.incl[[i]], track.num = 1,  side="in") 
    RCircos.Gene.Name.Plot(gene.data = signif_genes.incl[[i]], name.col = 4, track.num = 2, side = "in")
    dev.off()
  }
}
```

```{r circos_plot, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Present circos plot with cancer driver genes detected by various methods
for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes[[i]]) > 0 ) {
    
    cat(paste("\n\n <b>", datasets.list[i], "</b> \n\n", sep=" "))
    
    ##### Genes that are plotted
    cat("<details>")
    cat("<summary>Driver genes in circos plot</summary>")
    cat("<font size=\"2\">")
    cat(signif_genes.plotted[[i]])
    cat("</font>")
    cat("</details>")
    
    ##### All driver genes
    cat("<br><details>")
    cat("<summary>All driver genes</summary>")
    cat("<font size=\"2\">")
    cat(signif_genes.all[[i]])
    cat("</font>")
    cat("</details>")
    
    ##### Genes that are NOT plotted
    if ( !is.null(signif_genes.excess[[i]]) ) {
      cat("<br><span style=\"color:#ff0000\">NOTE</span>: driver genes that did not fit in the circos plot are listed below")
      cat("<details>")
      cat("<summary>Unlabeled driver genes</summary>")
      cat("<font size=\"2\">")
      cat(signif_genes.excess[[i]])
      cat("</font>")
      cat("</details>")
    }
    
    ##### Report driver genes with missing genomic annotation
    if ( nrow(signif_genes.excl[[i]]) > 0 ) {
      cat("\nThe genomic location(s) for the following detected cancer driver gene(s) are not defined and thus are not presented on the circos plot: ", paste(signif_genes.excl[[i]]$Gene, collapse = ", "), " \n\n", sep=" ")
    }
    
    ##### Export pdf to png
    circos.image <- image_read_pdf(paste(outDir, "/driver_analysis_circos_", datasets.list[i], ".pdf", sep = ""), pages = NULL, density = 300)
    image_write(circos.image, path = paste(outDir, "/driver_analysis_circos_", datasets.list[i], ".png", sep = ""), format = "png")

    ##### Read in the PNG files
    cat("![](",paste(outDir, "/driver_analysis_circos_", datasets.list[i], ".png", sep = ""),")")
    
  } else {
    cat(paste("None cancer driver gene have been detected by either method in dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### Per-method summary plot

Plot(s) illustrating the intersections of driver analysis results between the following methods: **`r paste(methods, collapse = ", ")`**.

```{r driver_genes_summary_plot, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Present the intersections between cancer driver genes detected by various methods
for ( i in 1:length(mafFiles) ) {
  
  if ( length(signif_genes[[i]]) > 0 ) {
    
    cat(paste("\n\n <b>", datasets.list[i], "</b> \n\n", sep=" "))
    
    png( file = paste(outDir, "/driver_analysis_upset_", datasets.list[i], ".png", sep = ""), width = 1800, height = 800, units = "px", res = 200 )
    
    upset.image <- capture.output(upset(as.data.frame(t(signif_genes.upset[[i]])), sets = colnames(t(signif_genes.upset[[i]])), sets.bar.color = "#56B4E9", order.by = "freq", empty.intersections = "on", sets.x.label = "Total genes no.", mb.ratio = c(0.5, 0.5)))
    invisible(dev.off())

    ##### Read in the PNG files
    cat("![](",paste(outDir, "/driver_analysis_upset_", datasets.list[i], ".png", sep = ""),")")
    cat("<br/><br/><br/>")

  } else {
    cat(paste("None cancer driver gene have been detected by either method in dataset", datasets.list[i], "\n\n", sep=" "))
  }
}
```

***

## Addendum

<details>
<summary>Parameters</summary>
<font size="2">

```{r params_info, comment = NA}
for ( i in 1:length(params) ) {

  cat(paste("Parameter: ", names(params)[i], "\nValue: ", paste(unlist(params[i]), collapse = ","), "\n\n", sep=""))
}
```

</font>
</details>

<details>
<summary>Session info</summary>
<font size="2">

```{r sessioninfo, comment = NA}
devtools::session_info()
```

</font>
</details>
