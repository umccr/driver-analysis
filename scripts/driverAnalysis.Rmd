---
title: "Driver analyses summary"
author: "UMCCR"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: readable
    css: driverAnalysis.css
    toc: true
    toc_float: true
    code_folding: hide
  rmdformats::material:
    highlight: kate
params:
  maf_dir: 
  maf_files: 
  datasets: 
  samples_id_cols: 
  dnds_q: 0.1
  oncodriveclust_fdr: 0.5
  ratios_ci: FALSE
  hypermut_sample_cutoff: 250
  max_muts_per_gene: 2
  genes_list: 'none'
  genes_blacklist: 'none'
  samples_blacklist: 'none'
  nonSyn_list: 'Frame_Shift_Del,Frame_Shift_Ins,Splice_Site,Translation_Start_Site,Nonsense_Mutation,Nonstop_Mutation,In_Frame_Del,In_Frame_Ins,Missense_Mutation'
  oncodrivefml: '/Users/jmarzec/data/Cohort_analyses/mutation/projects/Hartwig_PC/Hartwig_PDAC_oncodrivefml_analysis/Hartwig_PDAC-oncodrivefml,/Users/jmarzec/data/Cohort_analyses/mutation/projects/Hartwig_PC/Hartwig_PNET_oncodrivefml_analysis/Hartwig_PNET-oncodrivefml'
  oncodrivefml_p: 0.01
  oncodrivefml_q: 0.1
  oncodrivefml_conf: 'none'
  clinical_info: 'none'
  remove_duplicated_variants: TRUE
  hide_code_btn: TRUE
  out_folder: 'Driver_analysis_report'
  ucsc_genome_assembly: 19
  ensembl_version: 75
---

Selection analyses and cancer driver discovery results for dataset(s) **`r gsub(",", ", ", params$datasets) `** using the following methods:

* **[dNdScv](https://github.com/im3sanger/dndscv){target="_blank"}** (see paper by [Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"} for details)
* **[OncodriveClust](https://bioconductor.org/packages/release/bioc/vignettes/maftools/inst/doc/maftools.html#92_detecting_cancer_driver_genes_based_on_positional_clustering){target="_blank"}** (see paper by [Tamborero *et al*, 2013](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"} for details)
* **[OncodriveFML](https://bitbucket.org/bbglab/oncodrivefml.git){target="_blank"}** (see paper by [Mularoni et al., 2016](https://www.ncbi.nlm.nih.gov/pubmed/27311963){target="_blank"} for details)
* **[Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/rest_api){target="_blank"}** (CGI) (see paper by [Tamborero et al., 2018](https://www.ncbi.nlm.nih.gov/pubmed/29592813){target="_blank"} for details, ...work in progress)

```{r code_display, echo = FALSE}
##### Include or exclude the "Code" buttom allowing to "show"/"hide" code chunks from the report
if ( params$hide_code_btn ) {
  writeLines(".btn { display: none ;", con = "driverAnalysis.css")
} else {
  writeLines(" ", con = "driverAnalysis.css")
}
```
 
```{r define_functions, comment=NA, message=FALSE, warning=FALSE}
##### Define functions

##### Create 'not in' operator
"%!in%" <- function(x,table) match(x,table, nomatch = 0) == 0

##### Verify gene names. Some driver analysis methods, like dNdScv, output specific gene variants (e.g. CDKN2A.p14arf and CDKN2A.p16INK4a) rather than genes. This function removes anything followed by '.'
verify_genes <- function(genes) {
  
  genes.verified = unique(str_replace(string = genes, pattern = "\\..*", replacement = ""))
  return( genes.verified )
}

##### Perfrom oncodrive analysis. Clusters variants based on their position to detect disease causing genes
oncodrive_analysis <- function(mafInfo, dataset, gl) {
  
  ##### Check if the amino acid changes information is available in MAF provided files. The script expects column called "HGVSp_Short", which is produced with vcf2maf (https://github.com/mskcc/vcf2maf) when converting VCFs to MAFs (https://github.com/cBioPortal/cbioportal/issues/2996) and describes a mutation's amino acid change. The "aa_mutation" field used for annotation in ICGC samples is also acceptable. NOTE: other possibilities are: "Protein_Change", "AAChange""
  pchange = c('HGVSp_Short', 'Protein_Change', 'AAChange')
      
  ##### Define the column with protein change info
  pchange = pchange[pchange %in% colnames(mafInfo@data)]
  
  ##### Check if the protein change field is not empty
  if ( any(!is.na(as.data.frame(mafInfo@data)[ , pchange  ]))  ) {
        
    ##### Check whether it's possible to run oncodrive analysis for given dataset by calculating cluster scores
    nonsyn.scores <- parse_prot(mafInfo, AACol = pchange, gl = gl, m = 5, calBg = FALSE, nBg = 100)
      
    if ( !is.null(nonsyn.scores) ) {
        
      ##### Cluster variants based on their position to detect disease causing genes
      sig = oncodrive(maf = mafInfo, AACol = pchange, minMut = 5, pvalMethod = 'zscore')
      
      oncodrive.plot <- plotOncodrive(res = sig, fdrCutOff = 0.05, useFraction = FALSE)
    }
  } else {
    sig <- NULL
    oncodrive.plot <- NULL
  }
  return(list(sig, oncodrive.plot))
}

##### Functon to calcluate cluster score (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). It's required in order check whether it's possible to run oncodrive analysis for given dataset
parse_prot <- function(dat, AACol, gl, m, calBg = FALSE, nBg){

  mafInfo <- dat
  dat <- mafInfo@data
  
  if(is.null(AACol)){
    pchange = c('HGVSp_Short', 'Protein_Change', 'AAChange')
    if(pchange[pchange %in% colnames(dat)] > 0){
      pchange = suppressWarnings(pchange[pchange %in% colnames(dat)][1])
      message(paste0("Assuming protein change information are stored under column ", pchange,". Use argument AACol to override if necessary."))
      colnames(dat)[which(colnames(dat) == pchange)] = 'AAChange'
    }else{
      message('Available fields:')
      print(colnames(dat))
      stop('AAChange field not found in MAF. Use argument AACol to manually specifiy field name containing protein changes.')
    }
  }else{
    colnames(dat)[which(colnames(dat) == AACol)] = 'AAChange'
  }

  all.prot.dat = dat[,.(Hugo_Symbol, Variant_Classification, AAChange)]
  all.prot.dat = all.prot.dat[Variant_Classification != 'Splice_Site']
  #parse AAchanges to get postion
  prot.spl = strsplit(x = as.character(all.prot.dat$AAChange), split = '.', fixed = TRUE)
  prot.conv = sapply(sapply(prot.spl, function(x) x[length(x)]), '[', 1)

  all.prot.dat[,conv := prot.conv]
  all.prot.dat = all.prot.dat[!conv == 'NULL']

  #If conversions are in HGVSp_long (default HGVSp) format, we will remove strings Ter followed by anything (e.g; p.Asn1986GlnfsTer13)
  pos = gsub(pattern = 'Ter.*', replacement = '',x = all.prot.dat$conv)

  #Following parsing takes care of most of HGVSp_short and HGVSp_long format
  pos = gsub(pattern = '[[:alpha:]]', replacement = '', x = pos)
  pos = gsub(pattern = '\\*$', replacement = '', x = pos) #Remove * if nonsense mutation ends with *
  pos = gsub(pattern = '^\\*', replacement = '', x = pos) #Remove * if nonsense mutation starts with *
  pos = gsub(pattern = '\\*.*', replacement = '', x = pos) #Remove * followed by position e.g, p.C229Lfs*18

  pos = suppressWarnings( as.numeric(sapply(strsplit(x = pos, split = '_', fixed = TRUE), '[', 1)) )
  all.prot.dat[,pos := pos]

  all.prot.dat = all.prot.dat[!is.na(pos)] #Remove NA's

  gene.sum = mafInfo@gene.summary
  gene.sum = merge(x = gene.sum, y = gl, by = 'Hugo_Symbol', all.x = TRUE)
  gene.sum = gene.sum[!is.na(aa.length)]

  num_mut_colIndex = which(colnames(gene.sum) == 'total')
  aalen_colIndex = which(colnames(gene.sum) == 'aa.length')

  #Get background threshold
  gene.sum$th = apply(gene.sum, 1, function(x) get_threshold(gene_muts = as.numeric(x[num_mut_colIndex]), gene_length = as.numeric(x[aalen_colIndex])))
  #use only genes with atleast 2 (or m ) mutations.
  gene.sum = gene.sum[total >= m]

  if(calBg){
    if(nrow(gene.sum) < nBg){
      #message("Not enough genes to build background. Using predefined values. (Mean = 0.279; SD = 0.13)")
      return(NULL)
    } else{
      syn.res = c()
      pb <- txtProgressBar(min = 0, max = nrow(gene.sum), style = 3) #progress bar

      for(i in 1:nrow(gene.sum)){
        prot.dat = all.prot.dat[Hugo_Symbol %in% gene.sum[i, Hugo_Symbol]]
        syn.res = rbind(syn.res, cluster_prot(prot.dat = prot.dat, gene = gene.sum[i, Hugo_Symbol], th = gene.sum[i, th], protLen = gene.sum[i,aa.length]))
        setTxtProgressBar(pb, i)
      }
      return(syn.res)
    }
  } else{
    nonsyn.res = c()
    #pb <- txtProgressBar(min = 0, max = nrow(gene.sum), style = 3) #progress bar

    for(i in 1:nrow(gene.sum)){
      hs = gene.sum[i, Hugo_Symbol]
      #print(hs)
      prot.dat = all.prot.dat[Hugo_Symbol %in% hs]
      nonsyn.res = rbind(nonsyn.res, cluster_prot(prot.dat = prot.dat, gene = hs, th = gene.sum[Hugo_Symbol %in% hs, th], protLen = gene.sum[Hugo_Symbol %in% hs, aa.length]))
      #setTxtProgressBar(pb, i)
    }
    return(nonsyn.res)
  }
}

###### Estimate threshhold based on binaomial distribution (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). Required for parse_prot function
get_threshold <- function(gene_muts, gene_length){
  th = which(unlist(lapply(X = 2:gene_muts, FUN = function(x) dbinom(x = x, size = gene_muts, prob = 1/gene_length) )) < 0.01)[1]
  return(th+1)
}

###### Clustering function (from https://rdrr.io/github/PoisonAlien/maftools/src/R/clusterScore.R). Required for parse_prot function
cluster_prot <- function(prot.dat, gene, th, protLen){

  mergeDist = 5 #hard coded inter event distance.
  #prot.dat = all.prot.dat[Hugo_Symbol == gene]

  #Summarise counts per position
  pos.counts = prot.dat[,.N,pos]
  pos.counts = pos.counts[order(pos)]

  #classify position as meaningful if its greater than background threshhold.
  pos.counts$cluster = ifelse(test = pos.counts$N >= th, yes = 'meaningful', no = 'nonMeaningful')

  #Just choose meaningful positions
  clust.tbl = pos.counts[cluster %in% 'meaningful']
  nonclust.tbl = pos.counts[cluster %in% 'nonMeaningful']

  if(nrow(clust.tbl) == 0){
    #message(paste('No meaningful positions found for', gene, sep=' '))
    return(NULL)
  }

  clust.tbl$distance = c(0,diff(clust.tbl$pos)) #calculate inter event distance.

  #If more than one meaningful positions are found within a 5 aa distance, join them to form a cluster.
  if(nrow(clust.tbl) > 1){

    #initialize variables.
    cstart = end = clust.tbl[1,pos]
    n = clust.tbl[1,N]
    cdf = c()
    cluster = 1

    #Go through entire table and update variables.
    for(i in 2:nrow(clust.tbl)){
      pos = clust.tbl[i,pos]

      d = clust.tbl[i,distance]

      if(d < mergeDist){
        end = pos
        n = n + clust.tbl[i,N]
      }else{
        tempdf = data.frame(cluster = paste('cluster', cluster, sep='_'), start = cstart, end = end ,N = n)
        cdf = rbind(cdf, tempdf)
        cstart = end = pos
        n = clust.tbl[i,N]
        cluster = cluster + 1
      }
    }
    cdf = rbind(cdf, data.frame(cluster = paste('cluster', cluster, sep='_'), start = cstart, end = end ,N = n))
  } else {
    cdf = data.frame(cluster = 'cluster_1', start = clust.tbl$pos, end = clust.tbl$pos ,N = clust.tbl$N)
  }

  #merge adjacent variants to clusters.
  for(i in 1:nrow(cdf)){
    tempcdf = cdf[i,]
    nonclust.tbl$startDist = nonclust.tbl$pos - tempcdf$start
    nonclust.tbl$endDist = nonclust.tbl$pos - tempcdf$end

    merge.adj.to.start = nonclust.tbl[startDist >= -5 & startDist <= 0]
    if(nrow(merge.adj.to.start) > 0){
      tempcdf$start = merge.adj.to.start[which(merge.adj.to.start$startDist == min(merge.adj.to.start$startDist)),pos]
      tempcdf$N = tempcdf$N + sum(merge.adj.to.start$N)
    }

    merge.adj.to.end = nonclust.tbl[endDist <= 5 & endDist >= 0]
    if(nrow(merge.adj.to.end) > 0){
      tempcdf$end = merge.adj.to.end[which(merge.adj.to.end$endDist == max(merge.adj.to.end$endDist)),pos]
      tempcdf$N = tempcdf$N + sum(merge.adj.to.end$N)
    }
    cdf[i,] = tempcdf
  }
  cdf$Hugo_Symbol = gene

  #Calcluate cluster score.

  total.muts = nrow(prot.dat) #total variants for this gene.
  clusterScores = c()

  for(i in 1:nrow(cdf)){
    temp.prot.dat = prot.dat[pos >= as.numeric(cdf$start[i]) & pos <= as.numeric(cdf$end[i])]
    temp.prot.dat.summary = temp.prot.dat[,.N, pos]
    temp.prot.dat.summary[,fraction:= N/total.muts]

    peak = temp.prot.dat.summary[N == max(N), pos]

    posVector = as.numeric(temp.prot.dat.summary[,pos])
    fractionMutVector = unlist(lapply(posVector, FUN = function(x) temp.prot.dat.summary[pos == x, fraction]))
    distanceVector = suppressWarnings(abs(posVector - peak))

    clusterScores = c(clusterScores,  sum( fractionMutVector / (sqrt(2)^ distanceVector)))

  }

  cdf$clusterScore = clusterScores

  gene.clust.res = data.frame(Hugo_Symbol = gene, clusters = nrow(cdf), muts_in_clusters = sum(cdf$N), clusterScores = sum(cdf$clusterScore), protLen = protLen)
  return(gene.clust.res)
}

###### Generate dataTable for each dataset with all mutation information for selected gene(s), as provided in MAF files. User can filter variants to include only non-synonymous (defualt), silent or all variants
mut.details.datasets <- function(mafInfo, datasets, genes, type = "nonsynonymous") {
  
  ##### Vector with datasets with no mutations reported in selected genes
  datasets.noMut <- NULL
  
  ##### Create a list for htmlwidgets
  widges.list <- htmltools::tagList()
  
  for ( i in 1:length(datasets) ) {
    
    ##### Include all variants
    if ( type == "all" ) {
      
        mut.details.genes <- mafInfo[[datasets[i]]]@data[ mafInfo[[datasets[i]]]@data[, Hugo_Symbol] %in% genes, ]
        mut.details.genes <- rbind(mut.details.genes, mafInfo[[datasets[i]]]@maf.silent[ mafInfo[[datasets[i]]]@maf.silent[, Hugo_Symbol] %in% genes, ] )
        
    ##### Include silent variants
    } else if ( type == "silent" ) {
      
        mut.details.genes <- mafInfo[[datasets[i]]]@maf.silent[ mafInfo[[datasets[i]]]@maf.silent[, Hugo_Symbol] %in% genes, ]
    
    ##### Include only non-synonymous variants
    } else {
      
        mut.details.genes <- mafInfo[[datasets[i]]]@data[ mafInfo[[datasets[i]]]@data[, Hugo_Symbol] %in% genes, ]
    }
    
    if ( nrow(mut.details.genes) != 0 ) {
      
      ##### Sort table by gene symbol and then by sample ID
      mut.details.genes <- mut.details.genes[ order(mut.details.genes$Hugo_Symbol, mut.details.genes$Tumor_Sample_Barcode), ]
      
      #### Move column with Hugo_Symbol to the first place and Tumor_Sample_Barcode to the second
      col_idx <- grep("Tumor_Sample_Barcode", names(mut.details.genes))
      mut.details.genes <- as.data.frame(mut.details.genes)[, c(col_idx, (1:ncol(mut.details.genes))[-col_idx]) ]
      
      col_idx <- grep("Hugo_Symbol", names(mut.details.genes))
      mut.details.genes <- as.data.frame(mut.details.genes)[, c(col_idx, (1:ncol(mut.details.genes))[-col_idx]) ]
      
      widges.list[[i]] <- DT::datatable( data = mut.details.genes, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(mut.details.genes), 'text-align' = 'center' )
      
    } else {
      datasets.noMut <- c(datasets.noMut, datasets[i])
    }
  }
  
  ##### Report datasets with no mutations reported in selected genes
  if ( length(datasets.noMut) != 0 ) {
    if ( type == "nonsynonymous" ) {
      cat(paste("Note, none of queried gene(s) have non-synonymous variants reported in the following dataset(s):", paste(datasets.noMut, collapse = ", "), "\n\n", sep=" "))
    } else if ( type == "silent" ) {
      cat(paste("Note, none of queried gene(s) have silent variants reported in the following dataset(s):", paste(datasets.noMut, collapse = ", "), "\n\n", sep=" "))
    }
  }
  
  ##### Print a list of htmlwidgets
  widges.list
}

###### Generate lollipop plot for each dataset for selected gene
lollipops.datasets <- function(mafInfo, datasets, gene) {
  
  ##### Create a list to store MAF info for individual datasets
  for ( dataset in datasets ) {
    
    mut = subsetMaf(maf = mafInfo[[dataset]], includeSyn = FALSE, genes = gene, mafObj = FALSE, query = "Variant_Type != 'CNV'")
    
    ##### Check if the gene has any mutations in correspoding dataset
    if ( nrow(mut) != 0 ) {
      
      ##### Drawing lollipop for the top 10 genes in each dataset
      ##### Check if the amino acid changes information is available in MAF provided files. The script expects column called "HGVSp_Short", which is produced with vcf2maf (https://github.com/mskcc/vcf2maf) when converting VCFs to MAFs (https://github.com/cBioPortal/cbioportal/issues/2996) and describes a mutation's amino acid change. The "aa_mutation" field used for annotation in ICGC samples is also acceptable. NOTE: other possibilities are: "Protein_Change", "AAChange""
      pchange = c('HGVSp_Short', 'Protein_Change', 'AAChange')
      
      ##### Define the column with protein change info
      pchange = pchange[pchange %in% colnames(mut)]
      
      ##### Check if the protein change field is not empty
      if ( any(!is.na(as.data.frame(mut)[ , pchange  ]))  ) {
        
        cat(paste("\n\n <b>", dataset, "</b> \n\n", sep=" "))
        
        ##### Check if non-synonymous variats are detected
        if ( gene %in% mut$Hugo_Symbol ) {
        
          ##### Make it plot to a dummy graphics device file (e.g. /dev/null) to avoid plotting to the console
          pdf(file=paste0(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".pdf"), width = 8, height = 5)
          lollipopPlot.image <- capture.output(maftools::lollipopPlot(maf = mafInfo[[dataset]], gene = gene, AACol = pchange, printCount = FALSE, showDomainLabel = FALSE, repel = FALSE, labelPos = "all" , showMutationRate = TRUE, cBioPortal = TRUE))
          invisible(dev.off())
          
          ##### Export pdf to png
          lollipopPlot.image <- image_read_pdf(paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".pdf", sep = ""), pages = NULL, density = 300)
          image_write(lollipopPlot.image, path = paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".png", sep = ""), format = "png")
          
          ##### Read in the PNG files
          cat("![](",paste(paste0(mutationMapsDir, "/", paste(dataset, gene, sep="_")), ".png", sep = ""),")")
          cat("<br/><br/><br/>")
          
          ##### Remove redundant pdf plot
          file.remove(paste(mutationMapsDir, "/", paste(dataset, gene, sep="_"), ".pdf", sep = ""))
          while (!is.null(dev.list()))  invisible(dev.off())
        } else {
          cat(paste("**", gene, " have no non-synonymous variants detected in ", dataset, "dataset**.\n\n", sep=" "))
          cat("\n***\n")
        }
        
      ##### ...otherwise leave a message
      } else {
        
        ##### Check if the genes has any synonymous vatiants
        if ( length(pchange[pchange %in% colnames(mafInfo[[dataset]]@maf.silent)]) > 0 && gene %in% mafInfo[[dataset]]@maf.silent$Hugo_Symbol && any(!is.na(as.data.frame(mafInfo[[dataset]]@maf.silent)[ , pchange  ])) ) {
        
          cat(paste("This section was skipped for dataset", dataset, "since only synonymous variants were detected in", gene, "gene.\n\n", sep=" "))
      
        } else {
          cat(paste("This section was skipped for dataset", dataset, "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
        }
      }
        
    } else {
      cat(paste("\n\n <b>", dataset, "</b> \n\n", sep=" "))
      cat(paste("Gene <i>", gene, "</i> has no mutations reported in dataset", dataset, "\n\n", sep=" "))
    }
  }
}

##### A wrapper to saveWidget which compensates for arguable BUG in saveWidget which requires `file` to be in current working directory (see post https://github.com/ramnathv/htmlwidgets/issues/299 )
saveWidgetFix <- function ( widget, file, ...) {
  wd<-getwd()
  on.exit(setwd(wd))
  outDir<-dirname(file)
  file<-basename(file)
  setwd(outDir);
  htmlwidgets::saveWidget(widget,file=file,...)
}
```

```{r load_libraries, warning=FALSE}
suppressMessages(library(knitr))
suppressMessages(library(maftools))
suppressMessages(library(IRanges))
suppressMessages(library(dndscv))
suppressMessages(library(ggplot2))
suppressMessages(library(DT))
suppressMessages(library(UpSetR))
suppressMessages(library(stringr))
suppressMessages(library(magick))
suppressMessages(library(RCircos))
suppressMessages(library(package=paste0("EnsDb.Hsapiens.v", params$ensembl_version), character.only = TRUE))
```

```{r load_data, message=FALSE, warning=FALSE, results='hide'}
##### Split the string of MAF files and put them into a vector
mafFiles <- unlist(strsplit(params$maf_files, split=',', fixed=TRUE))
mafFiles <- paste(params$maf_dir, mafFiles, sep="/")

##### Split the string of datasets names and put them into a vector
datasets.list <- unlist(strsplit(params$datasets, split=',', fixed=TRUE))

##### Read MAF files and put associated info into a list
##### Create a list to store MAF info for individual datasets
mafInfo <- vector("list", length(mafFiles))
names(mafInfo) <- datasets.list

##### Check if file with clinical information is provided
clinicalInfo <- vector("list", length(mafFiles))
names(clinicalInfo) <- datasets.list

if ( params$clinical_info != "none" ){
  
  clinicalFiles <- unlist(strsplit(params$clinical_info, split=',', fixed=TRUE))
  
  for ( i in 1:length(mafFiles) ) {
    clinicalInfo[[i]] <- read.table(clinicalFiles[[i]], sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote = "")
  }
} else {
  for ( i in 1:length(mafFiles) ) {
    clinicalInfo[[i]] <- NA
  }
} 

##### NOTE: maftools by default summarises only non-synonymous variants with high/moderate variant consequences and ignores silent variants (https://github.com/PoisonAlien/maftools/issues/63), which are stored in "maf.silent" slot of the class MAF object (mafInfo[[i]]@maf.silent)
for ( i in 1:length(mafFiles) ) {
  
  ##### Add clinical information if provided
  if ( !is.na(clinicalInfo[[i]]) ){
    mafInfo[[i]] <- maftools::read.maf(maf = mafFiles[i], vc_nonSyn = unlist(strsplit(params$nonSyn_list, split=',', fixed=TRUE)), removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE, clinicalData = clinicalInfo[[i]])
  } else {
    mafInfo[[i]] <- maftools::read.maf(maf = mafFiles[i], vc_nonSyn = unlist(strsplit(params$nonSyn_list, split=',', fixed=TRUE)), removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE, clinicalData = NULL)
  }
}

##### Read in list of genes of interest of specified
if ( params$genes_list != "none" ){
  goi <- unique(read.table(params$genes_list, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)[,1])
}

##### Create directory for output files
outDir <- paste(params$maf_dir, params$out_folder, "results", sep = "/")
if ( !file.exists(params$out_folder) ){
  dir.create(outDir, recursive=TRUE)
}

##### Read in OncodriveFML analysis results (https://oncodrivefml.readthedocs.io/en/latest/output.html)
runOncodrivefmlChunk <- FALSE

if ( params$oncodrivefml != "none" ){
  
  oncodriveFML.res <- unlist(strsplit(params$oncodrivefml, split=',', fixed=TRUE))
  
  oncodriveFML.res.table <- vector("list", length(mafFiles))
  names(oncodriveFML.res.table) <- datasets.list
  
  for ( i in 1:length(mafFiles) ) {
    
    ##### Read in the results table
    if ( file.exists(paste0(oncodriveFML.res[i], ".tsv")) ) {
      
      oncodriveFML.res.table[[i]] <- read.table(paste0(oncodriveFML.res[i], ".tsv"), sep="\t", as.is=FALSE, header=TRUE, row.names=NULL)
      
    } else {
      ##### Create empty data frame
      oncodriveFML.res.table[[i]] <- data.frame(matrix(NA, nrow = 0, ncol = 12))
      names(oncodriveFML.res.table[[i]]) <- c("SYMBOL", "GENE_ID", "P_VALUE", "P_VALUE_EXP", "Q_VALUE", "MUTS", "MUTS_RECURRENCE", "SAMPLES", "P_VALUE_NEG", "Q_VALUE_NEG", "SNP", "MNP", "INDELS")
    }
  }
  runOncodrivefmlChunk <- TRUE
}

##### Read in OncodriveFML configuration file (https://oncodrivefml.readthedocs.io/en/latest/output.html)
oncodrivefml.conf <- NULL

if ( params$oncodrivefml_conf != "none" ){
  
  ##### Read in the results table
  if ( file.exists(paste0(oncodriveFML.res[i], ".tsv")) ) {
    oncodrivefml.conf <- read.table(params$oncodrivefml_conf, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL, comment.char="")
  }
}

##### Initiate a list to record sinigficant driver genes for each dataset
signif_genes.datasets <- vector("list", length(mafFiles))
names(signif_genes.datasets) <- datasets.list

signif_genes_table.datasets <- vector("list", length(mafFiles))
names(signif_genes_table.datasets) <- datasets.list

##### Initiate a list to record sinigficant driver genes for each method
if ( runOncodrivefmlChunk ) {
  
  methods <- c("dNdScv", "dNdSloc", "OncodriveCLUST", "OncodriveFML")
} else {
  methods <- c("dNdScv", "dNdSloc", "OncodriveCLUST")
}

signif_genes.methods <- vector("list", length(methods))
names(signif_genes.methods) <- methods
```

```{r exclude_samples, comment = NA, message=FALSE, warning=FALSE}
##### Exclude user-derined samples(s) from the analysis
if ( params$samples_blacklist != "none" ) {
  for ( i in 1:length(mafFiles) ) {
      
    ##### Read in list of samples to be excluded
    exclsamples.df <- read.table(params$samples_blacklist, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL)
    exclsamples <- unique(exclsamples.df[,"Tumor_Sample_Barcode"])
    
    samples2keep <- unlist(unique( mafInfo[[i]]@maf.silent[, "Tumor_Sample_Barcode"]))[ unlist(unique(mafInfo[[i]]@maf.silent[, "Tumor_Sample_Barcode"])) %!in% exclsamples ]
    
    ##### Subset the maf object to exclude use-defined sample(s)
    ##### Initially don't save the subset output as maf object, as this will exlude samples with no non-synonymous mutations from the summary
    mafInfo[[i]] <- subsetMaf(maf = mafInfo[[i]], tsb = as.vector(samples2keep), genes = NULL, fields = NULL, query = NULL, mafObj = FALSE, includeSyn = TRUE, dropLevels=TRUE)
    
    ##### Now read the data subset as a maf object
    mafInfo[[i]] <- maftools::read.maf(maf = mafInfo[[i]], vc_nonSyn = unlist(strsplit(params$nonSyn_list, split=',', fixed=TRUE)), removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE)
  }
}
```

```{r exclude_genes, comment = NA, message=FALSE, warning=FALSE}
##### Exclude user-derined gene(s) from the analysis
if ( params$genes_blacklist != "none" ) {
  for ( i in 1:length(mafFiles) ) {
    
    ##### Read in list of genes to be excluded
    exclgenes <- unique(read.table(params$genes_blacklist, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)[,1])
    
    genes2keep <- unique( mafInfo[[i]]@data$Hugo_Symbol)[ unique( mafInfo[[i]]@data$Hugo_Symbol) %!in% exclgenes ]
  
    ##### Subset the maf object to exclude use-defined gene(s)
    ##### Initially don't save the subset output as maf object, as this will exlude samples with no non-synonymous mutations from the summary
    mafInfo[[i]] <- subsetMaf(maf = mafInfo[[i]], tsb = NULL, genes = genes2keep, fields = NULL, query = NULL, mafObj = FALSE, includeSyn = TRUE)
    
    ##### Now read the data subset as a maf object
    mafInfo[[i]] <- maftools::read.maf(maf = mafInfo[[i]], vc_nonSyn = unlist(strsplit(params$nonSyn_list, split=',', fixed=TRUE)), removeDuplicatedVariants = params$remove_duplicated_variants, verbose = FALSE)
  }
} else {
  genes2keep <- mafInfo[[i]]@gene.summary$Hugo_Symbol
}
```

```{r silent_variants, comment = NA, message=FALSE, warning=FALSE}
##### Identify and record samples with no non-synonymous mutations
##### Prepare list to store all samples and samples with > 0 non-synonymous variants
MAF_samples <- vector("list", length(datasets.list))
names(MAF_samples) <- datasets.list
MAF_samples.silent.df <- NULL

##### Loop through MAF files
for ( i in 1:length(mafFiles) ) {
  
  ##### Identify samples with no non-synonymours variants according to corresponding MAF file
  MAF_samples[[i]]$all <- unlist(unique(mafInfo[[i]]@maf.silent[, "Tumor_Sample_Barcode"]))
  MAF_samples[[i]]$nonsyn <- unlist(maftools::getSampleSummary(mafInfo[[i]])[, "Tumor_Sample_Barcode"])
  MAF_samples[[i]]$silent <-  MAF_samples[[i]]$all[ MAF_samples[[i]]$all %!in% MAF_samples[[i]]$nonsyn  ]
  
  ##### Check if there thre are any samples with no non-synonymours variants. If so, add them to data frame
  if ( length(MAF_samples[[i]]$silent) > 0 ) {
    for ( sample in MAF_samples[[i]]$silent ) {
      
      MAF_samples.silent.df <- rbind( MAF_samples.silent.df, cbind( datasets.list[i], sample))
    }
    colnames(MAF_samples.silent.df) <- c("Dataset", "Sample")
  }
}

##### List silent variants classifications
silent_categories <- NULL

for ( i in 1:length(mafFiles) ) {
  silent_categories <- unique( c(silent_categories, mafInfo[[i]]@maf.silent$Variant_Classification) )
}
```

```{r dndscv_format_data, comment = NA, message=FALSE, warning=FALSE }
##### The input data is supposed to be a data.frame with five columns (sampleID, chr, pos, ref [base], mutant [base])
##### Convert the MAF calss objest to the format relevant for dndscv
dndscvInfo <- vector("list", length(mafFiles))
names(dndscvInfo) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  
  dndscvInfo[[i]] <- rbind(mafInfo[[i]]@data[, c("Tumor_Sample_Barcode", "Chromosome", "Start_Position", "Reference_Allele", "Tumor_Seq_Allele2")], mafInfo[[i]]@maf.silent[, c("Tumor_Sample_Barcode", "Chromosome", "Start_Position", "Reference_Allele", "Tumor_Seq_Allele2")])
  names(dndscvInfo[[i]]) <- c("sampleID", "chr", "pos", "ref", "mut")
}
```

```{r dndscv_driver_analysis, comment = NA, message=FALSE, warning=FALSE }
##### Run dN/dS approach for cancer driver discovery using dNdScv option, which combines local information (synonymous mutations in the gene) and global information (variation of the mutation rate across genes, exploiting epigenomic covariates) to estimate the background mutation rate

##### Get reference database
eval(parse( text=paste0("data(refcds_hg", params$ucsc_genome_assembly, ", package=\"dndscv\")")))

dndsout <- vector("list", length(mafFiles))
names(dndsout) <- datasets.list

ci <- vector("list", length(mafFiles))
names(ci) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  
  ##### Run analysis for selected genes
  if ( params$genes_list != "none" ){
    
    ##### First, check if all genes are in the RefCDS transcripts object
    RefCDSgenes <- goi[ goi %in% sapply(RefCDS, function(x) x$gene_name) ]
    
    dndsout[[i]] <- dndscv(dndscvInfo[[i]], gene_list = goi, refdb = paste0("hg", as.character(params$ucsc_genome_assembly)), sm = "192r_3w", kc = "cgc81", cv = paste0("hg", as.character(params$ucsc_genome_assembly)), max_muts_per_gene_per_sample = params$max_muts_per_gene, max_coding_muts_per_sample = params$hypermut_sample_cutoff, use_indel_sites = TRUE, min_indels = 5, maxcovs = 20, constrain_wnon_wspl = TRUE, outp = 3)
    
    ##### Calculate confidence intervals for the dN/dS ratios per gene
    if ( params$ratios_ci ) {
      ci[[i]] = geneci(dndsout[[i]])
    }
    
  ##### Run analysis for all genes
  } else {
    
    ##### First, check if all genes are in the RefCDS transcripts object
    RefCDSgenes <- genes2keep[ genes2keep %in% sapply(RefCDS, function(x) x$gene_name) ]
    
    dndsout[[i]] <- dndscv(dndscvInfo[[i]], gene_list = RefCDSgenes, refdb = paste0("hg", as.character(params$ucsc_genome_assembly)), sm = "192r_3w", kc = "cgc81", cv = paste0("hg", as.character(params$ucsc_genome_assembly)), max_muts_per_gene_per_sample = params$max_muts_per_gene, max_coding_muts_per_sample = params$hypermut_sample_cutoff, use_indel_sites = TRUE, min_indels = 5, maxcovs = 20, constrain_wnon_wspl = TRUE, outp = 3)

    ##### Calculate confidence intervals for the dN/dS ratios per gene
    if ( params$ratios_ci ) {
      ci[[i]] = geneci(dndsout[[i]])
    }
  }
}
```

```{r dndscv_summarise, comment = NA, message=FALSE, warning=FALSE}
##### Write dndscv summary into a file
sel_cv <- vector("list", length(mafFiles))
names(sel_cv) <- datasets.list

theta <- vector("list", length(mafFiles))
names(theta) <- datasets.list

exclsamples <- vector("list", length(mafFiles))
names(exclsamples) <- datasets.list

exclmuts <- vector("list", length(mafFiles))
names(exclmuts) <- datasets.list

globaldnds <- vector("list", length(mafFiles))
names(globaldnds) <- datasets.list

signif_genes.methods$dNdScv <- vector("list", length(datasets.list))
names(signif_genes.methods$dNdScv) <- datasets.list
  
signif_genes.methods$dNdSloc <- vector("list", length(datasets.list))
names(signif_genes.methods$dNdSloc) <- datasets.list
  
for ( i in 1:length(mafFiles) ) {
  
  ##### Calculate theta estimtates
  theta[[i]] <- round(dndsout[[i]]$nbreg$theta, digits = 2)
  
  ##### Get a table of significant genes
  sel_cv[[i]] <- dndsout[[i]]$sel_cv
  signif_genes_table.datasets[[i]]$dNdScv <- sel_cv[[i]][sel_cv[[i]]$qglobal_cv < params$dnds_q, ]
  rownames(signif_genes_table.datasets[[i]]$dNdScv) = NULL
  
  ##### Organise the table of significant genes
  ##### Add confidence intervals for the dN/dS ratios per gene
  if ( params$ratios_ci ) {
    
    signif_genes_table.datasets[[i]]$dNdScv <- merge( signif_genes_table.datasets[[i]]$dNdScv, ci[[i]], by.x="gene_name", by.y="gene", all.x = TRUE, all.y = FALSE, sort = FALSE)
    
    ##### Organise the table of significant genes
    signif_genes_table.datasets[[i]]$dNdScv <- signif_genes_table.datasets[[i]]$dNdScv[ , c("gene_name", "pglobal_cv", "qglobal_cv", "n_syn", "n_mis", "n_non", "n_spl", "n_ind", "wmis_cv", "mis_low", "mis_high", "pmis_cv", "wnon_cv", "wspl_cv", "tru_mle", "tru_low", "tru_high", "ptrunc_cv", "pallsubs_cv", "qallsubs_cv", "wind_cv", "pind_cv")]
    
  } else {
    
    ##### Organise the table of significant genes
    signif_genes_table.datasets[[i]]$dNdScv <- signif_genes_table.datasets[[i]]$dNdScv[ , c("gene_name", "pglobal_cv", "qglobal_cv", "n_syn", "n_mis", "n_non", "n_spl", "n_ind", "wmis_cv", "pmis_cv",  "wnon_cv", "wspl_cv", "ptrunc_cv", "pallsubs_cv", "qallsubs_cv", "wind_cv", "pind_cv")]
  }

  ##### Record excluded (hypermutated) samples
  if (!is.null(dndsout[[i]]$exclsamples)) {
    
    exclsamples[[i]] <- as.data.frame(dndsout[[i]]$exclsamples)
    names(exclsamples[[i]]) <- "sampleID"
  } else {
    exclsamples[[i]] <- data.frame(matrix(ncol = 1, nrow = 0))
    names(exclsamples[[i]]) <- "sampleID"
  }
  
  ##### Record excluded mutations (mutations when encountering too many mutations per gene in the same sample)
  if (!is.null(dndsout[[i]]$exclmuts)) {
    exclmuts[[i]] <- dndsout[[i]]$exclmuts
    exclmuts[[i]] <- exclmuts[[i]][, c("gene", "sampleID", "chr", "pos", "ref", "mut", "geneind")]
    } else {
    exclmuts[[i]] <- data.frame(matrix(ncol = 9, nrow = 0))
    names(exclmuts[[i]]) <- c("gene", "sampleID", "chr", "pos", "ref", "mut", "geneind")
  }
  
  ##### Extract global maximum-likelihood estimates (MLEs) for the dN/dS ratios across all genes
  globaldnds[[i]] <- dndsout[[i]]$globaldnds
  
  ##### Extract results from the local neutrality test based on the dNdSloc model
  signif_genes_table.datasets[[i]]$dNdSloc <- dndsout[[i]]$sel_loc[ dndsout[[i]]$sel_loc$qall_loc < params$dnds_q, ]
  rownames(signif_genes_table.datasets[[i]]$dNdSloc) = NULL
  
  ##### Organise the table of significant genes
  signif_genes_table.datasets[[i]]$dNdSloc <- signif_genes_table.datasets[[i]]$dNdSloc[ , c("gene_name", "pall_loc", "qall_loc", "n_syn", "n_mis", "n_non", "n_spl", "wmis_loc", "pmis_loc", "qmis_loc", "wnon_loc", "wspl_loc")]
    
  ##### Record sinigficant driver genes for each dataset and method
  signif_genes.datasets[[i]] <- list(dNdScv = as.character(signif_genes_table.datasets[[i]]$dNdScv$gene_name), dNdSloc = as.character(signif_genes_table.datasets[[i]]$dNdSloc$gene_name))
  
  signif_genes.methods$dNdScv[[i]] <- as.character(signif_genes_table.datasets[[i]]$dNdScv$gene_name)
  signif_genes.methods$dNdSloc[[i]] <- as.character(signif_genes_table.datasets[[i]]$dNdSloc$gene_name)
}
```

```{r exclude_hypermutators, comment = NA, message=FALSE, warning=FALSE}
##### Exclude hypermutators from MAF object based on user-derined threshold
mafInfo.all <- mafInfo

for ( i in 1:length(mafFiles) ) {
  if ( nrow(exclsamples[[i]]) > 0 ) {
    sample2keep <- unique( mafInfo[[i]]@data$Tumor_Sample_Barcode)[ unique( mafInfo[[i]]@data$Tumor_Sample_Barcode) %!in% exclsamples[[i]]$sampleID ]
      
    ##### Extract required data from MAF
    mafInfo[[i]] <- subsetMaf(maf = mafInfo[[i]], tsb = sample2keep, genes = NULL, fields = NULL, query = NULL, mafObj = TRUE, includeSyn = TRUE)
  }
}
```

```{r oncodriveCLUST_analysis,  include=FALSE }
##### In this chunk the clusters variants are calculated, but the results are reported in the next chunk
##### Import protein info data provided within maftools package
gl <- data.table::fread(input = paste("zcat <", system.file("extdata", "prot_len.txt.gz", package = "maftools")), sep = "\t", stringsAsFactors = FALSE)

##### Create a list to store MAF info for individual datasets
oncodriveClust.res <- vector("list", length(mafFiles))
names(oncodriveClust.res) <- datasets.list

signif_genes.methods$OncodriveCLUST <- vector("list", length(datasets.list))
names(signif_genes.methods$OncodriveCLUST) <- datasets.list
  
###### Generate separate plot for each dataset
for ( i in 1:length(mafFiles) ) {
  
  oncodriveClust.res[[datasets.list[i]]] <- oncodrive_analysis(mafInfo[[i]], datasets.list[i], gl) 

  if ( !is.null(oncodriveClust.res[[datasets.list[i]]][[1]]) && !is.null(oncodriveClust.res[[datasets.list[i]]][[2]]) ) {
    ##### Order results by genes' increasing FDR and then by decreasing total number of mutations
    oncodriveClust.res[[datasets.list[i]]][[1]] <- oncodriveClust.res[[datasets.list[i]]][[1]][ order(oncodriveClust.res[[datasets.list[i]]][[1]][, "fdr"],  rev(unlist(oncodriveClust.res[[datasets.list[i]]][[1]][, "total"]))) , ]
    
    ##### Record sinigficant driver genes for each dataset and method
    signif_genes.datasets[[i]]$OncodriveCLUST <- as.character(oncodriveClust.res[[datasets.list[i]]][[1]]$Hugo_Symbol[ oncodriveClust.res[[datasets.list[i]]][[1]]$fdr < params$oncodriveclust_fdr ])
    signif_genes.methods$OncodriveCLUST[[i]] <- as.character(oncodriveClust.res[[datasets.list[i]]][[1]]$Hugo_Symbol[ oncodriveClust.res[[datasets.list[i]]][[1]]$fdr < params$oncodriveclust_fdr ])
    
    signif_genes_table.datasets[[i]]$OncodriveCLUST <- oncodriveClust.res[[datasets.list[i]]][[1]][ oncodriveClust.res[[datasets.list[i]]][[1]]$fdr < params$oncodriveclust_fdr, ]
    rownames(signif_genes_table.datasets[[i]]$OncodriveCLUST) = NULL
    
    ##### Organise the table of significant genes
    signif_genes_table.datasets[[i]]$OncodriveCLUST <- signif_genes_table.datasets[[i]]$OncodriveCLUST[ , c("Hugo_Symbol", "clusterScores", "zscore", "pval", "fdr", "Frame_Shift_Del", "Frame_Shift_Ins", "In_Frame_Del", "In_Frame_Ins", "Missense_Mutation", "Nonsense_Mutation", "Splice_Site", "Translation_Start_Site", "total", "MutatedSamples", "AlteredSamples", "clusters", "muts_in_clusters", "protLen", "fract_muts_in_clusters")]
    
  } else {
    signif_genes.datasets[[i]]$OncodriveCLUST <- character()
    signif_genes.methods$OncodriveCLUST[[i]] <- character()
  }
}
```

```{r oncodriveFML_load_results,  include=FALSE, eval=runOncodrivefmlChunk}
##### Create a list to store OncodriveFML info for individual datasets
signif_genes.methods$OncodriveFML <- vector("list", length(datasets.list))
names(signif_genes.methods$OncodriveFML) <- datasets.list

###### Record results for each dataset
for ( i in 1:length(mafFiles) ) {
  
  ##### Move gene name to the first column
  col_idx <- grep("SYMBOL", names(oncodriveFML.res.table[[i]]))
  oncodriveFML.res.table[[i]] <- subset(oncodriveFML.res.table[[i]], select=c(names(oncodriveFML.res.table[[i]])[c(col_idx, c(1:ncol(oncodriveFML.res.table[[i]]))[-col_idx])]))

  ##### Order the table by P_VALUE, MUTS and SAMPLES
  oncodriveFML.res.table[[i]] <- oncodriveFML.res.table[[i]][ order( oncodriveFML.res.table[[i]]$SAMPLES, oncodriveFML.res.table[[i]]$MUTS, decreasing = TRUE), ]
  oncodriveFML.res.table[[i]] <- oncodriveFML.res.table[[i]][ order(oncodriveFML.res.table[[i]]$P_VALUE), ]
  rownames(oncodriveFML.res.table[[i]]) = NULL
  
  ##### Calculate expected p-value
  oncodriveFML.res.table[[i]]$P_VALUE_EXP <- ppoints(length(oncodriveFML.res.table[[i]]$P_VALUE))

  ##### Record sinigficant driver genes for each dataset
  signif_genes.datasets[[i]]$OncodriveFML <- unique(c(as.character(oncodriveFML.res.table[[i]]$SYMBOL)[ oncodriveFML.res.table[[i]]$P_VALUE < params$oncodrivefml_p  ], as.character(oncodriveFML.res.table[[i]]$SYMBOL)[ oncodriveFML.res.table[[i]]$Q_VALUE < params$oncodrivefml_q ]))
  
  ##### Remove NAs
  signif_genes.datasets[[i]]$OncodriveFML <- signif_genes.datasets[[i]]$OncodriveFML[ !is.na(signif_genes.datasets[[i]]$OncodriveFML)]
  
  ##### Report significant driver genes
  signif_genes_table.datasets[[i]]$OncodriveFML <- oncodriveFML.res.table[[i]][ oncodriveFML.res.table[[i]]$SYMBOL %in%  signif_genes.datasets[[i]]$OncodriveFML , ]
  rownames(signif_genes_table.datasets[[i]]$OncodriveFML) = NULL
  
  ##### Record sinigficant driver genes for each dataset and method
  signif_genes.methods$OncodriveFML[[i]] <- as.vector(signif_genes_table.datasets[[i]]$OncodriveFML$SYMBOL)
  
  ##### Organise the table of significant genes
  signif_genes_table.datasets[[i]]$OncodriveFML <- signif_genes_table.datasets[[i]]$OncodriveFML[ , c("SYMBOL", "GENE_ID", "P_VALUE", "P_VALUE_EXP", "Q_VALUE", "MUTS", "MUTS_RECURRENCE", "SAMPLES", "P_VALUE_NEG", "Q_VALUE_NEG", "SNP", "MNP", "INDELS")]
}
```

```{r driver_genes_summary, comment = NA, message=FALSE, warning=FALSE}
##### Compute the intersections between cancer driver genes detected by various methods
signif_genes.upset <- vector("list", length(mafFiles))
names(signif_genes.upset) <- datasets.list

signif_genes.upset.mod <- vector("list", length(mafFiles))
names(signif_genes.upset.mod) <- datasets.list

signif_genes <- vector("list", length(mafFiles))
names(signif_genes) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  
  signif_genes[[i]] <- verify_genes(unlist(signif_genes.datasets[[i]]))
  
  if ( length(signif_genes[[i]]) > 0 ) {
    
    ##### Create empty data frame for the upset() function (0 = not driver gene, 1 = driver gene)
    signif_genes.upset[[i]] <- data.frame(matrix(NA, nrow = length(signif_genes.datasets[[i]]), ncol = length(signif_genes[[i]])))
    names(signif_genes.upset[[i]]) <- signif_genes[[i]]
    rownames(signif_genes.upset[[i]]) <- names(signif_genes.datasets[[i]])
    
    ##### Check which genes were detected by individual method
    for( gene in signif_genes[[i]] ) {
      for ( j in 1:length(signif_genes.datasets[[i]]) ) {
        if ( gene %in% verify_genes(signif_genes.datasets[[i]][[j]]) ) {
          
          signif_genes.upset[[i]][ names(signif_genes.datasets[[i]][j]) , gene] <- 1
        } else {
          signif_genes.upset[[i]][ names(signif_genes.datasets[[i]][j]) , gene] <- 0
        }
      }
    }
    
    ##### Add column with summarised counts for each gene and organise the intersections summary table
    signif_genes.upset.mod[[i]] <- as.data.frame(t(signif_genes.upset[[i]]))
    signif_genes.upset.mod[[i]]$Total <- rowSums( signif_genes.upset.mod[[i]] )
    signif_genes.upset.mod[[i]] <- signif_genes.upset.mod[[i]][ order( signif_genes.upset.mod[[i]][, "Total"], signif_genes.upset.mod[[i]][, "dNdScv"], signif_genes.upset.mod[[i]][, "dNdSloc"], signif_genes.upset.mod[[i]][, "OncodriveCLUST"], decreasing = TRUE),  ] 
    
    for ( j in 1:length(signif_genes.datasets[[i]])) {
    
      signif_genes.upset.mod[[i]][ signif_genes.upset.mod[[i]][, j] == 1, j ] <- "Yes"
      signif_genes.upset.mod[[i]][ signif_genes.upset.mod[[i]][, j] == 0, j ] <- "No"
    }
  }
}
```

```{r gene_annot, comment = NA, message=FALSE, warning=FALSE}
##### Create a list to store genes annotations for each dataset
signif_genes.annot <- vector("list", length(mafFiles))
names(signif_genes.annot) <- datasets.list

##### Loop through each dataset and annotate detected cancer driver genes
for ( i in 1:length(mafFiles) ) {
  
  if ( length(signif_genes[[i]]) > 0 ) {
    data.df <- as.data.frame(signif_genes[[i]])
    colnames(data.df) <- "GENENAME"
  
    ##### Get genes annotation and genomic locations
    edb <- eval(parse(text = paste0("EnsDb.Hsapiens.v", params$ensembl_version)))
    
    ##### Get keytypes for gene SYMBOL
    keys <- keys(edb, keytype="GENENAME")
    
    ##### Get genes genomic coordiantes
    gene_info <- ensembldb::select(edb, keys=keys, columns=c("SEQNAME", "GENESEQSTART", "GENESEQEND","GENENAME"), keytype="GENENAME")
    
    ##### Remove rows with duplicated gene symbols (Y_RNAs, SNORs, LINC0s etc)
    gene_info = gene_info[!duplicated(gene_info$GENENAME),]

    ##### Limit genes annotation to driver genes
    gene_info <-  gene_info[ gene_info$GENENAME %in% data.df$GENENAME,  ]
    
    ##### Change column names
    names(gene_info) <- gsub("SEQNAME", "Chromosome", names(gene_info))
    names(gene_info) <- gsub("GENESEQSTART", "chromStart", names(gene_info))
    names(gene_info) <- gsub("GENESEQEND", "chromEnd", names(gene_info))
    names(gene_info) <- gsub("GENENAME", "Gene", names(gene_info))
    
    ##### Add "chr" to chromosome numbers
    gene_info$Chromosome <- paste0("chr", gene_info$Chromosome)
    signif_genes.annot[[i]] <- gene_info
  }
}

##### Clean the space
rm(data.df, edb, keys)
```


## Datasets  {.tabset}

This report summarises and visualises driver analyses results for the following dataset(s):

```{r datasets, comment = NA}
##### Present patient cohorts to be summarised
datasets.df <- as.data.frame( cbind(datasets.list, unlist(strsplit(params$maf_files, split=',', fixed=TRUE))) )
names(datasets.df) <- c("Dataset", "MAF file")

DT::datatable( data = datasets.df, filter = "none", extensions = 'Buttons', options = list(pageLength = length(mafFiles), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy')) ) %>%
        DT::formatStyle( columns = names(datasets.df), 'text-align' = 'center' )
```

### Overall summary

Table(s) with basic information about each dataset based on data in corresponding MAF file(s).

```{r overll_summary, comment = NA, message=FALSE, warning=FALSE}
##### Present a MAF file summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable( data = mafInfo.all[[i]]@summary, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "none", extensions = 'Buttons', options = list(pageLength = nrow(mafInfo.all[[i]]@summary), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis')) ) %>%
        DT::formatStyle( columns = names(mafInfo.all[[i]]@summary), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### Samples summary {.tabset}

#### Samples with non-synonymous variant(s)

Table(s) summarising samples in individual datasets. Each table contains per-sample information (rows) about *number of different types of mutations* (columns), as well as the *total number of mutations* reported in corresponding MAF file. <span style="color:#ff0000">NOTE</span>, only **samples with detected non-synonymous variant(s)** are reported in the table below.

```{r sample_summary, comment = NA, warning=FALSE}
##### Present a sample table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable( data = maftools::getSampleSummary(mafInfo.all[[i]]), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(maftools::getSampleSummary(mafInfo.all[[i]])), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()
```

`r if ( !is.null(MAF_samples.silent.df) ) { c("***") }`

`r if ( !is.null(MAF_samples.silent.df) ) { c("##### Samples with no non-synonymous variants") }`

`r if ( !is.null(MAF_samples.silent.df) ) { c("The table below lists sample(s) in which **no non-synonymous variants** were detected and hence will not be included in the summary tables/plots.") }`

```{r sample_no_nonsynonymous, comment = NA, warning=FALSE}
##### report samples with no non-synonymous variants according to corresponding MAF file
if ( !is.null(MAF_samples.silent.df) ) {
  DT::datatable( data = MAF_samples.silent.df, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong("Samples with no non-synonymours variants detected")), filter = "top", extensions = 'Buttons', options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy')) ) %>%
        DT::formatStyle( columns = names(MAF_samples.silent.df), 'text-align' = 'center' )
}

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( params$samples_blacklist != "none" ) { c("***") }`

`r if ( params$samples_blacklist != "none" ) { c("##### Excluded samples") }`

`r if ( params$samples_blacklist != "none" ) { c("List of samples excluded from the analysis.") }`

```{r excluded_samples_table, comment = NA, message=FALSE, warning=FALSE}
##### Present a samples table in the html report
if ( params$samples_blacklist != "none" ) {
    
  DT::datatable(data = exclsamples.df, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;'), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 1), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(exclsamples.df), 'text-align' = 'center' )
}
```

`r if ( length(unlist(exclsamples)) > 0 ) { c("***") }`

`r if ( length(unlist(exclsamples)) > 0 ) { c("#### Hypermutator samples") }`

`r if ( length(unlist(exclsamples)) > 0 ) { c(paste0("Table(s) listing sample(s) with >",  params$hypermut_sample_cutoff, " coding mutations. These have been removed from the analyses to protect against loss of sensitivity from ultra-hypermutators.")) }`

```{r hypermutator_samples, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = exclsamples[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(exclsamples[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 1), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(exclsamples[[i]]), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

`r if ( params$clinical_info != "none" ) { c("***") }`

`r if ( params$clinical_info != "none" ) { c("### Samples annotation") }`

`r if ( params$clinical_info != "none" ) { c("Sample annotations for individual dataset(s).") }`

```{r samples_annot_table, comment = NA, message=FALSE, warning=FALSE}
##### Present a samples table in the html report
if ( params$clinical_info != "none" ) {
  
  ##### Create a list for htmlwidgets
  widges.list <- htmltools::tagList()

  for ( i in 1:length(mafFiles) ) {
    widges.list[[i]] <- DT::datatable( data = mafInfo[[i]]@clinical.data, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(clinicalInfo[[i]]), 'text-align' = 'center' )
  }
  
  ##### Print a list of htmlwidgets
  widges.list
}
```

***

### Genes summary {.tabset}

#### Mutated genes

Table(s) summarising mutated genes in individual datasets. Each table contains per-gene information (rows) about *number of different types of mutations* (columns), as well as the *total number of mutations* reported in corresponding MAF file. The last two columns contain the *number of samples with mutations/alterations* in the corresponding gene.

```{r gene_summary, warning=FALSE}
##### Present a gene table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- DT::datatable(data = maftools::getGeneSummary(mafInfo.all[[i]]), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(maftools::getGeneSummary(mafInfo.all[[i]])), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list
```

`r if ( params$genes_blacklist != "none" ) { c("***") }`

`r if ( params$genes_blacklist != "none" ) { c("##### Excluded genes") }`

`r if ( params$genes_blacklist != "none" ) { c("List of genes excluded from the analysis.") }`

```{r excluded_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Present a gene table in the html report
if ( params$genes_blacklist != "none" ) {
    
  DT::datatable(data = data.frame(Gene = exclgenes), caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;'), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
    DT::formatStyle( columns = "Gene", 'text-align' = 'center' )
}
```

***

## Driver genes detection

### dN/dS {.tabset}

Selection analyses and cancer driver discovery using [dNdScv](https://github.com/im3sanger/dndscv){target="_blank"} R package. It provides *maximum-likelihood dN/dS* methods designed to quantify selection in cancer and somatic evolution ([Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"}). The package contains functions two different models (**dNdScv** and **dNdSloc**) to quantify dN/dS ratios for missense, nonsense and essential splice mutations, at the level of individual genes, groups of genes or at whole-genome level. The [dNdScv](https://github.com/im3sanger/dndscv){target="_blank"} package was designed to detect cancer driver genes (i.e. genes under positive selection in cancer) on datasets ranging from a few samples to thousands of samples, in whole-exome/genome or targeted sequencing studies.

<span style="color:#ff0000">NOTE</span>: **Only non-synonymous variants** are used for this analysis.

<details>
<summary>Variants consequence definitions</summary>
<font size="2">

* **Non-synonymous variants** are defined as variants with the following consequences: *`r paste(params$nonSyn_list, collapse = ", ")`*.
* **Silent variants** are defined as variants with the following consequences: *`r paste(silent_categories, collapse = ", ")`*.

</font> 
</details>

<details>
<summary>dNdScv model</summary>

Combines local information (synonymous mutations in the gene) and global information (variation of the mutation rate across genes, exploiting epigenomic covariates) to estimate the background mutation rate. It is a preferred model in most situations.

</details>

<details>
<summary>dNdSloc model</summary>

Based on local neutrality test, in which the number of synonymous mutations in a gene is used to infer the local mutation rate ([Wong *et al*., 2014](https://www.ncbi.nlm.nih.gov/pubmed/24316979){target="_blank"}), without exploiting additional information from other genes. This test is typically only powered in very large datasets.

</details>

<details>
<summary>Which model to use?</summary>

***dNdScv*** is a preferred model in most situations. However, low estimates of theta (θ, the overdispersion parameter), particularly θ < 1, may reflect problems with the suitability of the dNdScv model for the dataset. In these cases, it is reasonable to consider the traditional *dN/dS* (***dNdSloc***) model.

The estimated **θ** value(s) for dataset(s) `r names(unlist(theta))` are: **`r unlist(theta)`**, respectively.

</details>

<details>
<summary>Input parameters</summary>
<font size="2">

* Genome assembly version: **`r paste0("hg", params$ucsc_genome_assembly)`**
* Maximum mutations per gene in same sample: **`r params$max_muts_per_gene`**
* Mutations per gene to define ultra-hypermutator samples: **`r params$hypermut_sample_cutoff`**
* Q-value threshold for reporting significant genes: **`r params$dnds_q`**

**Ultra-hypermutator samples** (with > `r params$hypermut_sample_cutoff` coding mutations) are removed and **mutations with > `r params$max_muts_per_gene` mutations per gene** in the same sample are subsampled to protect against loss of sensitivity from ultra-hypermutators and from clustered artefacts.

<span style="color:#ff0000">NOTE</span>: by default, it is assumed that mutation data is mapped to the **GRCh37/hg19**. The *buildref* function (described [here](http://htmlpreview.github.io/?http://github.com/im3sanger/dndscv/blob/master/vignettes/buildref.html){target="_blank"}) can be used to generate the necessary reference file to run [dNdScv](https://github.com/im3sanger/dndscv){target="_blank"} on others assembly.

</font> 
</details>

***

#### Plots {.tabset}

##### dNdScv

*X-axis* indicates the *number of variants* observed in individual genes and *y-axis* illustrates *global q-values* in -log10 scale. The *size* of the points is proportional to -log10 *p-values* based on all non-synonymous substitutions detected in individual genes. The *colour* scale reflects *p-values* computed for indels, with purple and yellow indicating low and high *p-values*, respectively.

```{r dndscv_plot, comment = NA, message=FALSE, warning=FALSE}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( nrow(signif_genes_table.datasets[[i]]$dNdScv) > 0 ) {
      
    ##### Avoid q-values of 0 by assigning 1*10^-16 to extremely low q-values
    q_global <- signif_genes_table.datasets[[i]]$dNdScv$qglobal_cv
    q_global[ q_global == 0 ] <- 1*10^-16
    p_subs <- signif_genes_table.datasets[[i]]$dNdScv$pallsubs_cv
    p_subs[ p_subs == 0 ] <- 1*10^-16
    p_ind <- signif_genes_table.datasets[[i]]$dNdScv$pind_cv
    p_ind[ p_ind == 0 ] <- 1*10^-16
    
    ##### Sum up all mutations
    mutations_no <- rowSums(signif_genes_table.datasets[[i]]$dNdScv[ , names(signif_genes_table.datasets[[i]]$dNdScv) %in% c("n_syn", "n_mis", "n_non", "n_spl", "n_ind") ])
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(signif_genes_table.datasets[[i]]$dNdScv$gene_name, -log(q_global,10), mutations_no, -log(p_subs,10), -log(p_ind,10) )
    colnames(data.df) <- c("gene", "q_global", "mutations_no", "p_subs", "p_ind")
    
    ##### Calculate x and y axis rangeby adding 10% of the original range
    x_range <- c(0, max(data.df$mutations_no) + max(data.df$mutations_no)*0.1)
    y_range <- c(0, max(data.df$q_global) + max(data.df$q_global)*0.1)
    
    ##### Generate scatter-plot
    widges.list[[i]] <- plot_ly(data.df, x = ~mutations_no, y = data.df$q_global, color = data.df$p_ind, size = data.df$p_subs, text = ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
      add_text(textfont = list(size = 10), textposition = "top") %>%
      layout(title = datasets.list[i], xaxis = list(title = "Number of mutations", range = x_range), yaxis = list(title = "-log10( q-value )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = FALSE, legend = list(orientation = "v", y = 0.9))
    
    ##### Save the plot as html (PLOTLY)
    saveWidgetFix(as_widget(widges.list[[i]]), paste0(outDir, "/driver_analysis_dndscv_plot_", datasets.list[i], ".html"), selfcontained = TRUE)
    
  } else {
      cat(paste0("None of the mutated genes demonstrated significant global q-value in dataset ", datasets.list[i], "\n\n"))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

##### dNdSloc

*X-axis* indicates the *number of variants* observed in individual genes and *y-axis* illustrates *q-values* (in -log10 scale) based on all non-synonymous substitutions. The *size* of the points is proportional to -log10 *q-values* based exclusively on missense substitutions detected in individual genes.

```{r dndsloc_plot, comment = NA, message=FALSE, warning=FALSE}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( nrow(signif_genes_table.datasets[[i]]$dNdSloc) > 0 ) {
    
    ##### Avoid q-values of 0 by assigning 1*10^-16 to extremely low q-values
    q_all <- signif_genes_table.datasets[[i]]$dNdSloc$qall_loc
    q_all[ q_all == 0 ] <- 1*10^-16
    q_mis <- signif_genes_table.datasets[[i]]$dNdSloc$qmis_loc
    q_mis[ q_mis == 0 ] <- 1*10^-16
    
    ##### Sum up all mutations
    mutations_no <- rowSums(signif_genes_table.datasets[[i]]$dNdSloc[ , names(signif_genes_table.datasets[[i]]$dNdSloc) %in% c("n_syn", "n_mis", "n_non", "n_spl") ])
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(signif_genes_table.datasets[[i]]$dNdSloc$gene_name, -log(q_all,10), mutations_no, -log(q_mis,10) )
    colnames(data.df) <- c("gene", "q_all", "mutations_no", "q_mis")
    
    ##### Calculate x and y axis rangeby adding 10% of the original range
    x_range <- c(0, max(data.df$mutations_no) + max(data.df$mutations_no)*0.1)
    y_range <- c(0, max(data.df$q_all) + max(data.df$q_all)*0.1)
    
    ##### Generate scatter-plot
    widges.list[[i]] <- plot_ly(data.df, x = ~mutations_no, y = data.df$q_all, size = data.df$q_mis, text= ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
      add_text(textfont = list(size = 10), textposition = "top") %>%
      layout(title = datasets.list[i], xaxis = list(title = "Number of mutations", range = x_range), yaxis = list(title = "-log10( q-value )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE )
    
    ##### Save the plot as html (PLOTLY)
    saveWidgetFix(as_widget(widges.list[[i]]), paste0(outDir, "/driver_analysis_dndsloc_plot_", datasets.list[i], ".html"), selfcontained = TRUE)
  
  } else {
    cat(paste0("NOTE: none of the mutated genes demonstrated significant q-value in dataset ", datasets.list[i], "!\n\n"))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

#### Significant cancer genes {.tabset}

##### dNdScv

*P-values* for substitutions are obtained by *likelihood-ratio tests* as described in [Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"} and *q-values* are obtained by *Benjamini-Hodgberg’s multiple testing correction*. The table(s) also include information on the number of substitutions of each class observed in each gene, as well as *maximum-likelihood estimates* (*MLEs*) of the *dN/dS ratios* for each gene, for **missense** (*wmis*), **nonsense** (*wnon*), essential **splice site** mutations (*wspl*) and **indels** (*wind*). The *global q-values* integrating all mutation types are available in the ***qglobal_cv*** and *qallsubs_cv* columns for analyses with and without indels, respectively.

```{r dndscv_results_summary, comment = NA, message=FALSE, warning=FALSE}
##### Present dndscv results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( params$ratios_ci) {
    
    widges.list[[i]] <- DT::datatable( data = signif_genes_table.datasets[[i]]$dNdScv, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_table.datasets[[i]]$dNdScv), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
          DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$dNdScv), 'text-align' = 'center' ) %>%
    formatRound(columns = c("wmis_cv","wnon_cv", "wspl_cv", "wind_cv", "mis_mle", "tru_mle", "mis_low", "tru_low", "mis_high", "tru_high"), 1) %>%
    formatRound(columns = c("pglobal_cv", "qglobal_cv", "pmis_cv", "ptrunc_cv", "pallsubs_cv", "pind_cv", "qallsubs_cv", "pglobal_cv", "qglobal_cv"), 6)
    
  } else {
    widges.list[[i]] <- DT::datatable( data = signif_genes_table.datasets[[i]]$dNdScv, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_table.datasets[[i]]$dNdScv), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
          DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$dNdScv), 'text-align' = 'center' ) %>%
    formatRound(columns = c("wmis_cv", "wnon_cv", "wspl_cv", "wind_cv"), 1) %>%
    formatRound(columns = c("pglobal_cv", "qglobal_cv", "pmis_cv", "ptrunc_cv", "pallsubs_cv", "qallsubs_cv", "pind_cv"), 6)
  }
}

##### Print a list of htmlwidgets
widges.list
```

<details>
<summary>Table legend</summary>
<font size="2">

* **syn** - synonymous mutations
* **mis** - missense mutations
* **non** - nonsense mutations
* **spl** - splice site mutations
* **trunc** - all truncating mutations together (including nonsense and splice site mutations)
* **ind** - indels
* **allsubs** - all mutation types without indels
* **global** - all mutation types including indels

</font> 
</details>

***

##### dNdSloc

*P-values* are obtained from per-gene neutrality tests performed using *traditional dN/dS model*, in which the local mutation rate for a gene is estimated exclusively from the synonymous mutations observed in individual genes ([Wong *et al*., 2014](https://www.ncbi.nlm.nih.gov/pubmed/24316979){target="_blank"}). *Q-values* are obtained by *Benjamini-Hodgberg’s multiple testing correction*. The table(s) also include information on the number of substitutions of each class observed in each gene, as well as *maximum-likelihood estimates* (*MLEs*) of the *dN/dS ratios* for each gene, for **missense** (*wmis*), **nonsense** (*wnon*) and essential **splice site** mutations (*wspl*). The *q-values* integrating all mutation types are available in the ***qall_loc*** column.

```{r dndsloc_results_summary, comment = NA, message=FALSE, warning=FALSE}
##### Present dndscv results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = signif_genes_table.datasets[[i]]$dNdSloc, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(signif_genes_table.datasets[[i]]$dNdSloc), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$dNdSloc), 'text-align' = 'center' ) %>%
  formatRound(columns = c("wmis_loc", "wnon_loc", "wspl_loc"), 1) %>%
  formatRound(columns = c("pall_loc", "qall_loc", "pmis_loc", "qmis_loc"), 6)
}

##### Print a list of htmlwidgets
widges.list
```

<details>
<summary>Table legend</summary>
<font size="2">

* **syn** - synonymous mutations
* **mis** - missense mutations
* **non** - nonsense mutations
* **spl** - splice site mutations
* **all** - all mutation types

</font> 
</details>

***

#### Global dN/dS estimates

Table(s) presenting global *maximum-likelihood estimates* (*MLEs*) for the *dN/dS ratios* across all genes. dN/dS ratios with associated confidence intervals are calculated for **missense** (*wmis*), **nonsense** (*wnon*) and essential **splice site** substitutions (*wspl*) separately, as well as for **all non-synonymous** substitutions (*wall*) and for **all truncating** substitutions together (*wtru*), which include nonsense and essential splice site mutations.

<details>
<summary>What global dN/dS ratios indicate?</summary>

Global dN/dS ratios in somatic evolution of cancer, and seemingly of healthy somatic tissues, appear to show a near-universal pattern of **dN/dS ~1**, with exome-wide dN/dS ratios typically slightly higher than 1 ([Martincorena et al., 2017](https://www.ncbi.nlm.nih.gov/pubmed/29056346){target="_blank"}). The global **dN/dS < 1** is typically caused by contamination of the catalogue of somatic mutations with germline SNPs. An exception are melanoma tumours, which show a bias towards slight underestimation of dN/dS due to the signature of ultraviolet-induced mutations extending beyond the trinucleotide model. The global **dN/dS << 1** reflects a problem of SNP contamination or an inadequate substitution model, and so the evaluation of global dN/dS values can help identify problems in certain datasets.

</details>

```{r global_dnds_estimates, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = globaldnds[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(globaldnds[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(globaldnds[[i]]), 'text-align' = 'center' ) %>%
    formatRound(columns = c("mle", "cilow", "cihigh"), 1) 
}

##### Print a list of htmlwidgets
widges.list
```

<details>
<summary>Table legend</summary>
<font size="2">

* **wmis** - global dN/dS ratios for missense mutations
* **wnon** - global dN/dS ratios for nonsense mutations
* **wspl** - global dN/dS ratios for splice site mutations
* **wtru** - global dN/dS ratios for all truncating mutations together (including nonsense and splice site mutations)
* **wall** - global dN/dS ratios for all non-synonymous mutation types

</font> 
</details>

***
#### Subsampled mutations

Table(s) listing coding mutations within genes with > `r params$max_muts_per_gene` mutations per gene in same sample. These have been removed from the analysis to protect against loss of sensitivity from clustered artefacts.

```{r subsampled_mutations, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
    
  widges.list[[i]] <- DT::datatable( data = exclmuts[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(exclmuts[[i]]), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(exclmuts[[i]]), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveClust {.tabset}

Cancer driver genes detection based on positional clustering using [OncodriveClust](http://bg.upf.edu/group/projects/oncodrive-clust.php){target="_blank"} algorithm is based on the fact that most of the variants in cancer causing genes are enriched at few specific loci (hot-spots). According to this concept mutations in these regions potentially change the function of these proteins in a manner that provides an adaptive advantage to cancer cells and consequently are positively selected during clonal evolution of tumours. This property can thus be used to nominate novel candidate driver genes, as described in the paper [OncodriveClust](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"} by [Tamborero *et al*, 2013](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"}.

<span style="color:#ff0000">NOTE</span>: **Only non-synonymous variants** are used for this analysis.

<details>
<summary>Variants consequence definitions</summary>
<font size="2">

* **Non-synonymous variants** are defined as variants with the following consequences: *`r paste(params$nonSyn_list, collapse = ", ")`*.
* **Silent variants** are defined as variants with the following consequences: *`r paste(silent_categories, collapse = ", ")`*.

</font> 
</details>

<details>
<summary>Input parameters</summary>
<font size="2">

* False discovery rate (FDR) threshold for reporting significant genes: **`r params$oncodriveclust_fdr`**

</font> 
</details>

***

#### Plot

The *size* of the points on the scatter-plot(s) is proportional to the *number of clusters* found in individual genes. *X-axis* indicates the *number of variants* observed in these clusters and *y-axis* illustrates *false discovery rate* (FDR) values in -log10 scale. The *colour* scale reflects *cluster scores*, with yellow and purple indicating high and low values, respectively. Cluster score of 1 means that a single hotspot hosts all observed variants.

```{r oncodriveCLUST_plot, comment = NA, message=FALSE, warning=FALSE}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) != 0 ) {
    if ( nrow(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) > 0 ) {
      
      ##### Avoid q-values of 0 by assigning 1*10^-16 to extremely low q-values
      oncodriveClust.res.table <- signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST
      fdr <- oncodriveClust.res.table$fdr
      fdr[ fdr == 0 ] <- 1*10^-16
      
      ##### Prepare data frame for plotting with plotly
      data.df <- data.frame(oncodriveClust.res.table$Hugo_Symbol, -log(fdr,10), oncodriveClust.res.table$muts_in_clusters, oncodriveClust.res.table$clusterScores, oncodriveClust.res.table$clusters )
      colnames(data.df) <- c("gene", "fdr", "mutations_no", "clusterScores", "clusters")
      
      ##### Calculate x and y axis rangeby adding 10% of the original range
      x_range <- c(0, max(data.df$mutations_no) + max(data.df$mutations_no)*0.1)
      y_range <- c(0, max(data.df$fdr) + max(data.df$fdr)*0.1)
      
      ##### Generate scatter-plot
      widges.list[[i]] <- plot_ly(data.df, x = ~mutations_no, y = data.df$fdr, color = data.df$clusterScores, size = data.df$clusters, text= ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
        add_text(textfont = list(size = 10), textposition = "top") %>%
        layout(title = datasets.list[i], xaxis = list(title = "Number of mutations in clusters", range = x_range), yaxis = list(title = "-log10( FDR )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = FALSE, legend = list(orientation = "v", y = 0.9))
      
      ##### Save the plot as html (PLOTLY)
      saveWidgetFix(as_widget(widges.list[[i]]), paste0(outDir, "/driver_analysis_oncodriveCLUST_plot_", datasets.list[i], ".html"), selfcontained = TRUE)
    
    } else {
      cat(paste("None of the mutated genes demonstrated significant cluster score in dataset", datasets.list[i], "\n\n", sep=" "))
    }
  } else {
      cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

#### Significant cancer genes

Table(s) presenting per-dataset [OncodriveClust](https://www.ncbi.nlm.nih.gov/pubmed/23884480){target="_blank"} results, including *cluster scores*, *p-values*, *false discovery rate (FDR) values*, *number of mutations in clusters*, as well as the *fraction of mutations in clusters*. Cluster score of 1 means that a single hotspot hosts all observed variants.

```{r oncodriveCLUST_table, comment=NA, warning=FALSE}
##### Generate tables with oncodriveCLUST results
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  if ( length(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) != 0 ) {
      
    widges.list[[i]] <- DT::datatable(data = signif_genes_table.datasets[[i]]$OncodriveCLUST, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$OncodriveCLUST), 'text-align' = 'center' ) %>%
  formatRound(columns = c("clusterScores", "zscore", "fract_muts_in_clusters"), 1) %>%
  formatRound(columns = c("pval", "fdr"), 6)
  
  } else {
    cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveFML {.tabset}

[OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} is a method designed to analyse the pattern of somatic mutations across tumours in both **coding and non-coding genomic regions** to identify signals of positive selection, and therefore, their involvement in tumorigenesis. The identification of protein coding genes, promoters, untranslated regions, intronic splice regions, and lncRNAs-containing driver mutations in several malignancies using [OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} is described by [Mularoni et al., 2016](https://www.ncbi.nlm.nih.gov/pubmed/27311963){target="_blank"}.

[OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} results are **`r if ( runOncodrivefmlChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

***

<details>
<summary>OncodriveFML settings</summary>
<font size="2">

`r if ( !is.null(oncodrivefml.conf) ) { c(gsub("],", "]: ", paste0(unlist(oncodrivefml.conf), collapse = ", "), perl = TRUE)) } else { c("OncodriveFML configuration file is not available.") }`

</font> 
</details>

<details>
<summary>Input parameters</summary>
<font size="2">

* P-value threshold for reporting significant genes: **`r params$oncodrivefml_p`**
* Q-value threshold for reporting significant genes: **`r params$oncodrivefml_q`**

</font> 
</details>

***

#### Plot {.tabset}

##### Interactive  {.tabset}

###### All genes

[Q-Q plot](https://en.wikipedia.org/wiki/Q%E2%80%93Q_plot){target="_blank"} with *y-axis* presenting -log10 of the *computed p-values* and *x-axis* the -log10 of the *expected p-values* for **all genes**. The *size* of the points is proportional to *number of mutations* found in the dataset for individual genes. The *colour* scale reflects -log10 *q-values*, with black indicating genomic elements for which the number of mutated samples does not reach the minimum required to perform multiple test correction.

```{r oncodriveFML_plot_interactive, comment = NA, message=FALSE, warning=FALSE, eval=runOncodrivefmlChunk}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( nrow(oncodriveFML.res.table[[datasets.list[i]]]) > 0 ) {
    
    ##### Avoid q-values of 0 by assigning 1*10^-16 to extremely low q-values
    q_obs <- oncodriveFML.res.table[[datasets.list[i]]]$Q_VALUE
    q_obs[ q_obs == 0 ] <- 1*10^-16
    p_obs <- oncodriveFML.res.table[[datasets.list[i]]]$P_VALUE
    p_obs[ p_obs == 0 ] <- 1*10^-16
    p_exp <- oncodriveFML.res.table[[datasets.list[i]]]$P_VALUE_EXP
    p_exp[ p_exp == 0 ] <- 1*10^-16
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(oncodriveFML.res.table[[datasets.list[i]]]$SYMBOL, -log10(q_obs), -log10(p_obs), -log10(p_exp), oncodriveFML.res.table[[datasets.list[i]]]$MUTS )
    colnames(data.df) <- c("gene", "q", "p_obs", "p_exp", "muts_no")
    
    ##### Get significant genes' names for the plotly add_text option
    genes_text <- data.df$gene[ 1:length(signif_genes.datasets[[datasets.list[i]]]$OncodriveFML) ]
    genes_text <- c(as.character(genes_text), rep(" ", nrow(data.df)-length(genes_text)))
    
    ##### Calculate x and y axis rangeby adding 10% of the original range
    x_range <- c(0, max(data.df$p_exp) + max(data.df$p_exp)*0.1)
    y_range <- c(0, max(data.df$p_obs) + max(data.df$p_obs)*0.1)
     
    ##### Generate scatter-plot
    widges.list[[i]] <- plot_ly(data.df, x = data.df$p_exp, y = data.df$p_obs, color = data.df$q, size = data.df$muts_no, text = ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
      add_text(textfont = list(size = 10), textposition = "top", text=genes_text) %>%
      add_lines(y = c(seq(min(data.df$p_obs), min(c(max(data.df$p_obs), max(data.df$p_exp))), length.out=nrow(data.df))), x = c(seq(min(data.df$p_obs), min(c(max(data.df$p_obs), max(data.df$p_exp))), length.out=nrow(data.df))), line = list(color = "grey", dash = "dash"), showlegend = FALSE, data = NULL, inherit = FALSE) %>%
      layout(title = datasets.list[i], xaxis = list(title = "-log10( expected p-values )", range = x_range), yaxis = list(title = "-log10( observed p-values )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = FALSE, legend = list(orientation = "v", y = 0.9))
    
    ##### Save the plot as html (PLOTLY)
    saveWidgetFix(as_widget(widges.list[[i]]), paste0(outDir, "/driver_analysis_oncodriveFML_plotly_", datasets.list[i], ".html"), selfcontained = TRUE)
  } else {
      cat(paste("None of the mutated genes demonstrated significant p- or q-value in dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

###### Significant cancer genes

[Q-Q plot](https://en.wikipedia.org/wiki/Q%E2%80%93Q_plot){target="_blank"} with *y-axis* presenting -log10 of the *computed p-values* and *x-axis* the -log10 of the *expected p-values* for **significant cancer genes** only (`r paste(paste0("p-value < ", params$oncodrivefml_p), paste0("q-value < ", params$oncodrivefml_q), sep = ", ")`). The *size* of the points is proportional to *number of mutations* found in the dataset for individual genes. The *colour* scale reflects -log10 *q-values*, with black indicating genomic elements for which the number of mutated samples does not reach the minimum required to perform multiple test correction.

```{r oncodriveFML_plot_interactive_signif, comment = NA, message=FALSE, warning=FALSE, eval=runOncodrivefmlChunk}
suppressMessages(library(plotly))

##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( nrow(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML) > 0 ) {
    
    ##### Avoid q-values of 0 by assigning 1*10^-16 to extremely low q-values
    q_obs <- signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML$Q_VALUE
    q_obs[ q_obs == 0 ] <- 1*10^-16
    p_obs <- signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML$P_VALUE
    p_obs[ p_obs == 0 ] <- 1*10^-16
    p_exp <- signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML$P_VALUE_EXP
    p_exp[ p_exp == 0 ] <- 1*10^-16
    
    ##### Prepare data frame for plotting with plotly
    data.df <- data.frame(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML$SYMBOL, -log10(q_obs), -log10(p_obs), -log10(p_exp), signif_genes_table.datasets[[datasets.list[i]]]$OncodriveFML$MUTS )
    colnames(data.df) <- c("gene", "q", "p_obs", "p_exp", "muts_no")
    
    ##### Calculate x and y axis rangeby adding 10% of the original range
    x_range <- c(min(data.df$p_exp) - min(data.df$p_exp)*0.1, max(data.df$p_exp) + max(data.df$p_exp)*0.1)
    y_range <- c(min(data.df$p_obs) - min(data.df$p_obs)*0.1, max(data.df$p_obs) + max(data.df$p_obs)*0.1)
    
    ##### Generate scatter-plot
    ##### Check if any of the significant genes have determined q-value
    if ( !all(is.na(data.df$q)) ) {
      
      widges.list[[i]] <- plot_ly(data.df, x = data.df$p_exp, y = data.df$p_obs, color = data.df$q, size = data.df$muts_no, text = ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
        add_text(textfont = list(size = 10), textposition = "top") %>%
        add_lines(y = c(seq(min(data.df$p_obs), min(c(max(data.df$p_obs), max(data.df$p_exp))), length.out=nrow(data.df))), x = c(seq(min(data.df$p_obs), min(c(max(data.df$p_obs), max(data.df$p_exp))), length.out=nrow(data.df))), line = list(color = "grey", dash = "dash"), showlegend = FALSE, data = NULL, inherit = FALSE) %>%
        layout(title = datasets.list[i], xaxis = list(title = "-log10( expected p-values )", range = x_range), yaxis = list(title = "-log10( observed p-values )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE, showlegend = FALSE, legend = list(orientation = "v", y = 0.9))
      
    } else {
      widges.list[[i]] <- plot_ly(data.df, x = data.df$p_exp, y = data.df$p_obs, size = data.df$muts_no, text = ~gene, mode = "markers",  marker = list(opacity = 0.8, line = list(color = "black", width = 1)), width = 800, height = 400) %>%
        add_text(textfont = list(size = 10), textposition = "top") %>%
        add_lines(y = c(seq(min(data.df$p_obs), min(c(max(data.df$p_obs), max(data.df$p_exp))), length.out=nrow(data.df))), x = c(seq(min(data.df$p_obs), min(c(max(data.df$p_obs), max(data.df$p_exp))), length.out=nrow(data.df))), line = list(color = "grey", dash = "dash"), showlegend = FALSE, data = NULL, inherit = FALSE) %>%
        layout(title = datasets.list[i], xaxis = list(title = "-log10( expected p-values )", range = x_range), yaxis = list(title = "-log10( observed p-values )", range = y_range), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE)
    }
  
  } else {
      cat(paste("None of the mutated genes demonstrated significant p- or q-value in dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)

##### Print a list of htmlwidgets
widges.list
```

***

##### Static

[Q-Q plot](https://en.wikipedia.org/wiki/Q%E2%80%93Q_plot){target="_blank"} with *y-axis* presenting -log10 of the *computed p-values* and *x-axis* the -log10 of the *expected p-values*. The genomic elements that have a lighter colour are the ones for which the number of mutated samples does not reach the minimum required to perform multiple test correction. All genomic regions above the red line are annotated and represent those with *Q-value* below *0.1*. The ones between the green line and the red line are the ones with a *Q-value* between *0.25* and *0.1*.

NOTE, in case of very long list of detected driver genes only 50 with the most significant *computed p-values* are indicated on the Q-Q plot (check table in the *Significant cancer genes* tab to see the full list).

```{r oncodriveFML_plot_static, comment = NA, message=FALSE, warning=FALSE, results="asis", eval=runOncodrivefmlChunk}
for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the OncodriveFML results plot (HTML) exists
  if ( file.exists(paste0(oncodriveFML.res[i], ".png")) ) {
    
    ##### Read in the oncodriveFML PNG files
    cat(paste("\n\n <b>", datasets.list[i], "</b> \n\n", sep=" "))
    cat("![](",paste(paste0(oncodriveFML.res[i], ".png")),")")
    cat("<br/><br/><br/>")

    ##### Copy the OncodriveFML results plot (HTML and PNG) to the report folder
    file.copy(paste0(oncodriveFML.res[i], ".png"), paste0(outDir, "/driver_analysis_oncodriveFML_plot_", datasets.list[i], ".png"), overwrite = TRUE, copy.mode = TRUE, copy.date = FALSE)
    file.copy(paste0(oncodriveFML.res[i], ".html"), paste0(outDir, "/driver_analysis_oncodriveFML_plot_", datasets.list[i], ".html"), overwrite = TRUE, copy.mode = TRUE, copy.date = FALSE)
    
  } else {
    cat(paste("OncodriveFML results plot \"", paste0(oncodriveFML.res[i], ".png"), "\" is not present for dataset", datasets.list[i], "\n\n", sep=" "))
  }
}
```

***

#### Significant cancer genes

Table(s) presenting per-dataset [OncodriveFML](https://oncodrivefml.readthedocs.io/en/latest/oncodriveFML.html){target="_blank"} results, including *p-values*, *q-values*, as well as the *number of mutations* that are *SNPs*, multi nucleotide polymorphisms (*MNPs*) and insertions or deletions (*INDELS*).

```{r oncodriveFML_table, comment=NA, warning=FALSE, eval=runOncodrivefmlChunk}
##### Generate tables with oncodriveFML results
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  ##### Check if the OncodriveFML results plot (HTML) exists
  if ( nrow(signif_genes_table.datasets[[i]]$OncodriveFML) > 0 ) {
    
    widges.list[[i]] <- DT::datatable(data = signif_genes_table.datasets[[i]]$OncodriveFML, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = names(signif_genes_table.datasets[[i]]$OncodriveFML), 'text-align' = 'center' ) %>%
  formatRound(columns = c("P_VALUE", "Q_VALUE", "P_VALUE_NEG", "Q_VALUE_NEG"), 6)
  } else {
    cat(paste("OncodriveFML results table \"", paste0(oncodriveFML.res[i], ".tsv"), "\" is not present for dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

<details>
<summary>Table legend</summary>
<font size="2">

* **MUTS** - number of mutations found in the dataset for that gene
* **MUTS_RECURRENCE** - number of mutations that do not occur in the same position
* **SAMPLES** - number of mutated samples in the gene
* **P_VALUE** - times that the observed value is higher than or equal to the expected value, divided by the number of randomisations
* **P_VALUE_EXP** - expected *P_VALUE*
* **Q_VALUE** - *P_VALUE* corrected using the *Benjamini-Hochberg* correction (for samples with at least 2 samples)
* **P_VALUE_NEG** - times that the observed value is lower than or equal to the expected value, divided by the number of randomisations
* **Q_VALUE_NEG** - *P_VALUE_NEG* corrected using the *Benjamini-Hochberg* correction (for samples with at least 2 samples)

</font> 
</details>

***

### Cancer Genome Interpreter {.tabset}

... work in progress

[Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/rest_api){target="_blank"} (CGI) (see paper by [Tamborero et al., 2018](https://www.ncbi.nlm.nih.gov/pubmed/29592813){target="_blank"} for details)

***

## Mutation maps {.tabset .tabset-fade}

Lollipop plot(s) showing mutation spots on protein structure for driver genes detected by the following methods: **`r paste(names(signif_genes.datasets[[i]]), collapse = ", ")`**. Many oncogenes have a preferential sites which are mutated more often than any other locus. These spots are considered to be mutational hot-spots and lollipop plots can be used to display them along with rest of the mutations. <span style="color:#ff0000">NOTE</span>, that lollipop plot(s) are generated for MAF files containing field with amino acid changes details. The longest transcript is used if multiple transcripts are available.

```{r pchange_field_check, comment = NA, message=FALSE, warning=FALSE}
##### Check if the protein change field is present in any of the MAFs
pchangeStatus <- FALSE

for ( i in 1:length(mafFiles) ) {
  pchange = c('HGVSp_Short', 'Protein_Change', 'AAChange')
        
  ##### Define the column with protein change info
  pchange = pchange[pchange %in% colnames(mafInfo[[i]]@data)]
  
  ##### Check if the protein change field is not empty
  if ( any(!is.na(as.data.frame(mafInfo[[i]]@data)[ , pchange  ]))  ) {
    pchangeStatus <- TRUE
    
    ##### Create directory for pdf files
    mutationMapsDir <- paste0(normalizePath(outDir), "/", "MAF_mutation_maps")
    
    if ( !file.exists(mutationMapsDir) ){
      dir.create(mutationMapsDir, recursive=TRUE)
    }
  }
}
```

```{r prot_structre, comment = NA, message=FALSE, warning=FALSE, eval=pchangeStatus}
##### Get list of proteins for which structure is available within maftools
gff = system.file('extdata', 'protein_domains.RDs', package = 'maftools')
gff = readRDS(file = gff)
```

### dNdScv {.tabset}

```{r lollipop_plots_dNdScv, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Generate lollipop plot for each dataset for top mutated genes
if ( pchangeStatus ) {
  
  output_plot <- list()
  genes <- unique(verify_genes(unlist(signif_genes.methods$dNdScv)))
  
  for( i in 1:length(genes) ){
    cat("\n#### ", genes[i], "\n")
    if ( nrow(gff[HGNC %in% genes[i]]) != 0 ) {
      try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = genes[i]), silent = TRUE)
      cat("\n\n***\n")
    } else {
      cat(paste("The protein structure for protein encoded by", unlist(signif_genes.methods$dNdScv)[i], "is not available\n\n", sep=" "))
      cat("\n***\n")
    }
  }
  
  ##### Clean the space
  rm(list = ls(pattern='^output*'))

} else {
  cat("\n***\n")
  cat("\nThis section was skipped since the field with **amino acid changes details** in provided MAF(s) is **NOT AVAILABLE**!\n")
  cat("\n***\n")
}
```

### dNdSloc {.tabset}

```{r lollipop_plots_dNdSloc, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Generate lollipop plot for each dataset for top mutated genes
if ( pchangeStatus ) {
  
  output_plot <- list()
  genes <- unique(verify_genes(unlist(signif_genes.methods$dNdSloc)))
  
  for( i in 1:length(genes) ){
    cat("\n#### ", verify_genes(genes)[i], "\n")
    if ( nrow(gff[HGNC %in% genes[i]]) != 0 ) {
      try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = genes[i]), silent = TRUE)
      cat("\n\n***\n")
    } else {
      cat(paste("The protein structure for protein encoded by", unlist(signif_genes.methods$dNdSloc)[i], "is not available\n\n", sep=" "))
      cat("\n***\n")
    }
  }
  
  ##### Clean the space
  rm(list = ls(pattern='^output*'))

} else {
  cat("\n***\n")
  cat("\nThis section was skipped since the field with **amino acid changes details** in provided MAF(s) is **NOT AVAILABLE**!\n")
  cat("\n***\n")
}
```

### OncodriveCLUST {.tabset}

```{r lollipop_plots_OncodriveCLUST, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Generate lollipop plot for each dataset for top mutated genes
if ( pchangeStatus ) {
  
  output_plot <- list()
  genes <- unique(verify_genes(unlist(signif_genes.methods$OncodriveCLUST)))
  
  for( i in 1:length(genes) ){
    cat("\n#### ", genes[i], "\n")
    if ( nrow(gff[HGNC %in% genes[i]]) != 0 ) {
      try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = genes[i]), silent = TRUE)
      cat("\n\n***\n")
    } else {
      cat(paste("The protein structure for protein encoded by", unlist(signif_genes.methods$OncodriveCLUST)[i], "is not available\n\n", sep=" "))
      cat("\n***\n")
    }
  }
  
  ##### Clean the space
  rm(list = ls(pattern='^output*'))

} else {
  cat("\n***\n")
  cat("\nThis section was skipped since the field with **amino acid changes details** in provided MAF(s) is **NOT AVAILABLE**!\n")
  cat("\n***\n")
}
```

### OncodriveFML {.tabset}

`r if ( runOncodrivefmlChunk ) { c(" ") } else { c("**OncodriveFML results are NOT AVAILABLE**.") }`

```{r lollipop_plots_OncodriveFML, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Generate lollipop plot for each dataset for top mutated genes
if ( pchangeStatus ) {
  
  output_plot <- list()
  genes <- unique(verify_genes(unlist(signif_genes.methods$OncodriveFML)))
  
  for( i in 1:length(genes) ){
    cat("\n#### ", genes[i], "\n")
    if ( nrow(gff[HGNC %in% genes[i]]) != 0 ) {
      try(lollipops.datasets(mafInfo = mafInfo, datasets  = datasets.list, gene  = genes[i]), silent = TRUE)
      cat("\n\n***\n")
    } else {
      cat(paste("The protein structure for protein encoded by", unlist(signif_genes.methods$OncodriveFML)[i], "is not available\n\n", sep=" "))
      cat("\n***\n")
    }
  }
  
  ##### Clean the space
  rm(list = ls(pattern='^output*'))

} else {
  cat("\n***\n")
  cat("\nThis section was skipped since the field with **amino acid changes details** in provided MAF(s) is **NOT AVAILABLE**!\n")
  cat("\n***\n")
}
```

## Mutations annotation {.tabset}

Table(s) with detailed annotation of **coding mutations** (detected by the following methods: **`r paste(names(signif_genes.datasets), collapse = ", ")`**) in affected samples.

<span style="color:#ff0000">NOTE</span>: mutations detected in non-coding genomic regions, e.g. those shortlisted by *OncodriveFML*, are not listed in the table(s) below.

### dNdScv

```{r mutations_annotation_dNdScv, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$dNdScv[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### dNdSloc

```{r mutations_annotation_dNdSloc, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$dNdSloc[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveCLUST

```{r mutations_annotation_OncodriveCLUST, comment = NA, message=FALSE, warning=FALSE}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) != 0 ) {
    
    annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$OncodriveCLUST[[i]], ]
  
    ##### Move gene name to the first column
    col_idx <- grep("gene", names(annotmuts))
    annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
    
    widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
  
  } else {
    cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveFML

`r if ( runOncodrivefmlChunk ) { c(" ") } else { c("**OncodriveFML results are NOT AVAILABLE**.") }`

```{r mutations_annotation_OncodriveFML, comment = NA, message=FALSE, warning=FALSE, eval=runOncodrivefmlChunk}
##### Present results summary table in the html report
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  annotmuts <- dndsout[[i]]$annotmuts[ dndsout[[i]]$annotmuts$gene %in% signif_genes.methods$OncodriveFML[[i]], ]
  
  ##### Move gene name to the first column
  col_idx <- grep("gene", names(annotmuts))
  annotmuts <- subset(annotmuts, select=c(names(annotmuts)[c(col_idx, c(1:ncol(annotmuts))[-col_idx])]))
  
  widges.list[[i]] <- DT::datatable( data = annotmuts, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = nrow(annotmuts), dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 2), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
        DT::formatStyle( columns = names(annotmuts), 'text-align' = 'center' )
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

## Mutation details {.tabset .tabset-fade}

Tables with detailed variant's information in affected samples, as as provided in corresponding MAF file(s), for cancer driver genes detected by the following methods: **`r paste(names(signif_genes.datasets), collapse = ", ")`**.

<details>
<summary>Variants consequence definitions</summary>
<font size="2">

* **Non-synonymous variants** are defined as variants with the following consequences: *`r paste(params$nonSyn_list, collapse = ", ")`*.
* **Silent variants** are defined as variants with the following consequences: *`r paste(silent_categories, collapse = ", ")`*.

</font> 
</details>

### dNdScv {.tabset .tabset-fade}

#### Non-synonymous

```{r details_mut_dNdScv_nonsynon, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$dNdScv[[i]], type = "nonsynonymous")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

#### Silent

```{r details_mut_dNdScv_silent, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$dNdScv[[i]], type = "silent")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### dNdSloc {.tabset .tabset-fade}

#### Non-synonymous

```{r details_mut_dNdSloc_nonsynon, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$dNdSloc[[i]], type = "nonsynonymous")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

#### Silent

```{r details_mut_dNdSloc_silent, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$dNdSloc[[i]], type = "silent")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveCLUST {.tabset .tabset-fade}

#### Non-synonymous

```{r details_mut_OncodriveCLUST_nonsynon, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) != 0 ) {
    widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$OncodriveCLUST[[i]], type = "nonsynonymous")
  } else {
    cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

#### Silent

```{r details_mut_OncodriveCLUST_silent, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes_table.datasets[[datasets.list[i]]]$OncodriveCLUST) != 0 ) {
    widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$OncodriveCLUST[[i]], type = "silent")
  } else {
    cat(paste("This section was skipped for dataset", datasets.list[i], "since the corresponding MAF does not contain field with amino acid changes details!\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### OncodriveFML {.tabset .tabset-fade}

`r if ( runOncodrivefmlChunk ) { c(" ") } else { c("**OncodriveFML results are NOT AVAILABLE**.") }`

#### Non-synonymous

```{r details_mut_OncodriveFML_nonsynon, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$OncodriveFML[[i]], type = "nonsynonymous")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

#### Silent

```{r details_mut_OncodriveFML_silent, comment = NA, message=FALSE, warning=FALSE}
##### Provide detiles information for each dataset for user-defined number of top mutated genes
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  widges.list[[i]] <- mut.details.datasets(mafInfo[i], datasets.list[i], signif_genes.methods$OncodriveFML[[i]], type = "silent")
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

## Summary {.tabset}

### Per-gene summary table

Table presenting cancer driver genes (rows) detected by the following methods (*columns*): **`r paste(names(signif_genes.datasets[[i]]), collapse = ", ")`**.

```{r driver_genes_summary_table, comment = NA, message=FALSE, warning=FALSE}
##### Presnet the intersections between cancer driver genes detected by various methods
##### Create a list for htmlwidgets
widges.list <- htmltools::tagList()

for ( i in 1:length(mafFiles) ) {
  
  if ( length(signif_genes[[i]]) > 0 ) {
    
    ##### Generate a table
    widges.list[[i]] <- DT::datatable( data = signif_genes.upset.mod[[i]], caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left;', htmltools::strong(datasets.list[i])), filter = "top", rownames = TRUE, extensions = c('Buttons','FixedColumns','Scroller'), options = list(pageLength = 5, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, fixedColumns = list(leftColumns = 1), deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE ) %>%
      DT::formatStyle( columns = colnames(signif_genes.upset.mod[[i]]), `font-size` = '12px', 'text-align' = 'center' ) %>%
      
      ##### Colour cells according to evidence level and trust rating
      DT::formatStyle(columns = colnames(signif_genes.upset.mod[[i]])[-c(length(signif_genes.upset.mod[[i]]))], 
                      backgroundColor = DT::styleEqual(c("No", "Yes"), c("transparent", "black")), color = DT::styleEqual(c("No", "Yes"), c("black", "white")))
    
  } else {
    cat(paste("None cancer driver gene have been detected by either method in dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Print a list of htmlwidgets
widges.list

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### Circos plot

Circos plot showing human chromosome (human genome reference build hg`r params$ucsc_genome_assembly`) ideogram with the cancer driver genes detected by the following methods (*columns*): **`r paste(names(signif_genes.datasets[[i]]), collapse = ", ")`**.

```{r circos_prep, comment = NA, message=FALSE, warning=FALSE}
##### Prepare circos plot with cancer driver genes detected by various methods
signif_genes.excl <- vector("list", length(mafFiles))
names(signif_genes.excl) <- datasets.list

signif_genes.incl <- vector("list", length(mafFiles))
names(signif_genes.incl) <- datasets.list

for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes[[i]]) > 0 ) {
    
    data(UCSC.HG19.Human.CytoBandIdeogram)
    cyto.info <- eval(parse( text=paste0("UCSC.HG", params$ucsc_genome_assembly, ".Human.CytoBandIdeogram ")))
    
    ##### Check if all driver genes are located in standard chromosomes
    signif_genes.excl[[i]] <- signif_genes.annot[[i]][ signif_genes.annot[[i]]$Chromosome %!in% cyto.info$Chromosome,  ]
    signif_genes.incl[[i]] <- signif_genes.annot[[i]][ signif_genes.annot[[i]]$Chromosome %in% cyto.info$Chromosome,  ]
    
    if ( nrow(signif_genes.incl[[i]]) > 100 ) {
      tracks.inside <- 8
    } else if ( nrow(signif_genes.incl[[i]]) > 50 ) {
      tracks.inside <- 6
    } else {
      tracks.inside <- 4
    }
    
    RCircos.Set.Core.Components ( cyto.info=cyto.info, chr.exclude=NULL, tracks.inside=tracks.inside, tracks.outside=0)
    
    ##### Save circos into a pdf file
    pdf(file = paste(outDir, "/driver_analysis_circos_", datasets.list[i], ".pdf", sep = ""), height = 14, width = 14, pointsize = 18) 
    
    RCircos.Set.Plot.Area()  
    RCircos.Chromosome.Ideogram.Plot()
    RCircos.Gene.Connector.Plot(genomic.data = signif_genes.incl[[i]], track.num = 1,  side="in") 
    RCircos.Gene.Name.Plot(gene.data = signif_genes.incl[[i]], name.col = 4, track.num = 2, side = "in")
    dev.off()
  }
}
```

```{r circos_plot, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Present circos plot with cancer driver genes detected by various methods
for ( i in 1:length(mafFiles) ) {
  if ( length(signif_genes[[i]]) > 0 ) {
    
    cat(paste("\n\n <b>", datasets.list[i], "</b> \n\n", sep=" "))
    
    ##### Report driver genes with missing genomic annotation
    if ( nrow(signif_genes.excl[[i]]) > 0 ) {
      cat("* The genomic location(s) for the following detected cancer driver gene(s) are not defined and thus are not presented on the circos plot: ", paste(signif_genes.excl[[i]]$Gene, collapse = ", "), " \n\n", sep=" ")
    }
    
    ##### Export pdf to png
    circos.image <- image_read_pdf(paste(outDir, "/driver_analysis_circos_", datasets.list[i], ".pdf", sep = ""), pages = NULL, density = 300)
    image_write(circos.image, path = paste(outDir, "/driver_analysis_circos_", datasets.list[i], ".png", sep = ""), format = "png")

    ##### Read in the PNG files
    cat("![](",paste(outDir, "/driver_analysis_circos_", datasets.list[i], ".png", sep = ""),")")
    
  } else {
    cat(paste("None cancer driver gene have been detected by either method in dataset", datasets.list[i], "\n\n", sep=" "))
  }
}

##### Add extra lines to make sure that this section doesn't overlap with the next one
cat("\n\n\n")
```

***

### Per-method summary plot

Plot(s) illustrating the intersections of driver analysis results between the following methods: **`r paste(names(signif_genes.datasets[[i]]), collapse = ", ")`**.

```{r driver_genes_summary_plot, comment = NA, message=FALSE, warning=FALSE, results="asis"}
##### Present the intersections between cancer driver genes detected by various methods
for ( i in 1:length(mafFiles) ) {
  
  if ( length(signif_genes[[i]]) > 0 ) {
    
    cat(paste("\n\n <b>", datasets.list[i], "</b> \n\n", sep=" "))
    
    png( file = paste(outDir, "/driver_analysis_upset_", datasets.list[i], ".png", sep = ""), width = 1800, height = 800, units = "px", res = 200, type="cairo" )
    
    upset.image <- capture.output(upset(as.data.frame(t(signif_genes.upset[[i]])), sets = colnames(t(signif_genes.upset[[i]])), sets.bar.color = "#56B4E9", order.by = "freq", empty.intersections = "on", sets.x.label = "Total genes no.", mb.ratio = c(0.5, 0.5)))
    invisible(dev.off())

    ##### Read in the PNG files
    cat("![](",paste(outDir, "/driver_analysis_upset_", datasets.list[i], ".png", sep = ""),")")
    cat("<br/><br/><br/>")

  } else {
    cat(paste("None cancer driver gene have been detected by either method in dataset", datasets.list[i], "\n\n", sep=" "))
  }
}
```

***

## Addendum

<details>
<summary>Parameters</summary>
<font size="2">

```{r params_info, comment = NA}
for ( i in 1:length(params) ) {

  cat(paste("Parameter: ", names(params)[i], "\nValue: ", paste(unlist(params[i]), collapse = ","), "\n\n", sep=""))
}
```

</font>
</details>

<details>
<summary>Session info</summary>
<font size="2">

```{r sessioninfo, comment = NA}
devtools::session_info()
```

</font>
</details>
